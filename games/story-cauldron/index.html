<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Story Cauldron</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0a1a;
            color: #e8e0d4;
            font-family: Georgia, 'Times New Roman', serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        #scene-container {
            width: 100%;
            flex: 1 1 0;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px 20px 0;
            min-height: 0;
        }

        #scene {
            max-width: 100%;
            max-height: 100%;
            border-radius: 12px;
            box-shadow: 0 0 60px rgba(230, 126, 34, 0.15), 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #narration {
            padding: 24px 48px 4px;
            text-align: center;
            font-size: 1.4rem;
            line-height: 1.7;
            max-width: 800px;
            white-space: pre-line;
            flex-shrink: 0;
            opacity: 0;
            animation: fadeIn 2s ease forwards;
            animation-delay: 0.5s;
        }

        #choices {
            padding: 16px 48px 32px;
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
            flex-shrink: 0;
            opacity: 0;
            animation: fadeIn 1.5s ease forwards;
            animation-delay: 2.5s;
        }

        .choice-btn {
            background: rgba(229, 152, 80, 0.1);
            border: 2px solid rgba(229, 152, 80, 0.35);
            color: #e8e0d4;
            font-family: Georgia, 'Times New Roman', serif;
            font-size: 1.15rem;
            padding: 14px 28px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.02em;
        }

        .choice-btn:hover {
            background: rgba(229, 152, 80, 0.25);
            border-color: rgba(229, 152, 80, 0.7);
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(229, 152, 80, 0.15);
        }

        .choice-btn:active {
            transform: translateY(0);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #transition-overlay {
            position: fixed;
            inset: 0;
            background: #0a0a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
            z-index: 100;
        }

        #transition-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        #loading-text {
            font-size: 1.5rem;
            font-style: italic;
            animation: pulse 2s ease-in-out infinite;
        }

        #loading-text a {
            color: #e8852a;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="scene-container">
        <canvas id="scene" width="1120" height="520"></canvas>
    </div>
    <div id="narration"></div>
    <div id="choices"></div>
    <div id="transition-overlay"><span id="loading-text">The story unfolds...</span></div>

    <script>
        // ========================================
        // Scene Data
        // ========================================

        const openingScene = {
            background: 'sunset-beach',
            sprites: [
                { type: 'catalog', name: 'mailbox', x: 0.50, groundY: 0.90, scale: 6 }
            ],
            narration: "You open your eyes to warm sunlight and the sound of gentle waves. Sand beneath your fingers. A soft breeze carries the smell of salt and something sweet.\n\nAs your vision clears, you notice something odd: a bright red mailbox, standing upright in the sand just a few feet away. Its little flag is up.",
            choices: [
                "Open the mailbox",
                "Look around the beach",
                "Walk toward the water"
            ]
        };

        // ========================================
        // Renderer
        // ========================================

        const canvas = document.getElementById('scene');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        function drawSky(sky) {
            const skyH = H * (sky.height || 0.45);
            const grad = ctx.createLinearGradient(0, 0, 0, skyH);
            const stops = sky.colors;
            for (let i = 0; i < stops.length; i++) {
                grad.addColorStop(i / (stops.length - 1), stops[i]);
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
        }

        function drawSun(sun) {
            const cx = W * sun.x;
            const cy = H * sun.y;

            // Wide atmospheric glow
            const atmo = ctx.createRadialGradient(cx, cy, 0, cx, cy, sun.glowRadius * 2);
            atmo.addColorStop(0, 'rgba(245, 192, 64, 0.3)');
            atmo.addColorStop(0.25, 'rgba(232, 133, 42, 0.12)');
            atmo.addColorStop(0.5, 'rgba(196, 74, 47, 0.04)');
            atmo.addColorStop(1, 'rgba(196, 74, 47, 0)');
            ctx.fillStyle = atmo;
            ctx.fillRect(0, 0, W, H * 0.55);

            // Inner glow
            const glow = ctx.createRadialGradient(cx, cy, sun.radius * 0.5, cx, cy, sun.glowRadius);
            glow.addColorStop(0, 'rgba(245, 192, 64, 0.5)');
            glow.addColorStop(0.4, 'rgba(245, 192, 64, 0.15)');
            glow.addColorStop(1, 'rgba(245, 192, 64, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(cx, cy, sun.glowRadius, 0, Math.PI * 2);
            ctx.fill();

            // Sun disc
            const disc = ctx.createRadialGradient(cx, cy, 0, cx, cy, sun.radius);
            disc.addColorStop(0, '#fffbe8');
            disc.addColorStop(0.5, '#f5d868');
            disc.addColorStop(0.85, '#eca530');
            disc.addColorStop(1, '#d4782a');
            ctx.beginPath();
            ctx.arc(cx, cy, sun.radius, 0, Math.PI * 2);
            ctx.fillStyle = disc;
            ctx.fill();
        }

        function drawClouds() {
            // Wispy sunset clouds — lit from below by golden light
            const clouds = [
                { x: 0.15, y: 0.12, w: 140, h: 12, opacity: 0.15 },
                { x: 0.22, y: 0.15, w: 100, h: 8, opacity: 0.10 },
                { x: 0.70, y: 0.10, w: 160, h: 14, opacity: 0.14 },
                { x: 0.78, y: 0.14, w: 90, h: 9, opacity: 0.09 },
                { x: 0.35, y: 0.22, w: 120, h: 10, opacity: 0.18 },
                { x: 0.60, y: 0.20, w: 110, h: 11, opacity: 0.12 },
            ];

            clouds.forEach(c => {
                const cx = W * c.x;
                const cy = H * c.y;

                // Cloud lit from below — warm orange/gold on bottom, cooler on top
                const grad = ctx.createLinearGradient(cx, cy - c.h, cx, cy + c.h);
                grad.addColorStop(0, `rgba(180, 120, 160, ${c.opacity * 0.5})`);
                grad.addColorStop(0.6, `rgba(232, 160, 80, ${c.opacity})`);
                grad.addColorStop(1, `rgba(245, 200, 100, ${c.opacity * 0.7})`);

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(cx, cy, c.w / 2, c.h / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Softer halo
                ctx.fillStyle = `rgba(245, 200, 120, ${c.opacity * 0.3})`;
                ctx.beginPath();
                ctx.ellipse(cx, cy, c.w / 2 + 10, c.h / 2 + 4, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawOcean(ocean) {
            const y = H * ocean.y;
            const h = H * ocean.height;

            // Ocean body
            const grad = ctx.createLinearGradient(0, y, 0, y + h);
            grad.addColorStop(0, ocean.shallowColor);
            grad.addColorStop(0.4, ocean.deepColor);
            grad.addColorStop(1, '#081c30');
            ctx.fillStyle = grad;
            ctx.fillRect(0, y, W, h);

            // Sun reflection path on water
            const refGrad = ctx.createRadialGradient(W * 0.5, y + 5, 0, W * 0.5, y + h * 0.5, 200);
            refGrad.addColorStop(0, 'rgba(245, 192, 64, 0.35)');
            refGrad.addColorStop(0.25, 'rgba(245, 192, 64, 0.15)');
            refGrad.addColorStop(0.6, 'rgba(245, 192, 64, 0.03)');
            refGrad.addColorStop(1, 'rgba(245, 192, 64, 0)');
            ctx.fillStyle = refGrad;
            ctx.fillRect(0, y, W, h);

            // Shimmer streaks on water
            ctx.globalAlpha = 0.1;
            ctx.strokeStyle = '#f5d868';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 6; i++) {
                const streakY = y + h * (0.2 + i * 0.12);
                const centerX = W * 0.5;
                const streakW = 40 + (3 - Math.abs(i - 3)) * 25;
                ctx.beginPath();
                ctx.moveTo(centerX - streakW / 2, streakY);
                ctx.lineTo(centerX + streakW / 2, streakY);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Subtle wave lines
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.04 + i * 0.015})`;
                ctx.beginPath();
                const waveY = y + h * (0.25 + i * 0.25);
                for (let x = 0; x < W; x += 2) {
                    const wy = waveY + Math.sin(x * 0.015 + i * 1.8) * 2;
                    if (x === 0) ctx.moveTo(x, wy);
                    else ctx.lineTo(x, wy);
                }
                ctx.stroke();
            }
        }

        function drawSand(sand) {
            const y = H * sand.y;
            const h = H - y;

            // Main sand gradient
            const grad = ctx.createLinearGradient(0, y, 0, H);
            grad.addColorStop(0, sand.color);
            grad.addColorStop(0.25, sand.wetColor);
            grad.addColorStop(1, sand.darkColor);
            ctx.fillStyle = grad;
            ctx.fillRect(0, y, W, h);

            // Wet sand strip near waterline
            const wetGrad = ctx.createLinearGradient(0, y, 0, y + 24);
            wetGrad.addColorStop(0, 'rgba(13, 40, 71, 0.25)');
            wetGrad.addColorStop(1, 'rgba(13, 40, 71, 0)');
            ctx.fillStyle = wetGrad;
            ctx.fillRect(0, y, W, 24);

            // Foam/surf line at water's edge
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < W; x += 2) {
                const fy = y + Math.sin(x * 0.03) * 2 + Math.sin(x * 0.07) * 1;
                if (x === 0) ctx.moveTo(x, fy);
                else ctx.lineTo(x, fy);
            }
            ctx.stroke();
            // Second softer foam line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let x = 0; x < W; x += 2) {
                const fy = y + 6 + Math.sin(x * 0.025 + 1) * 2.5;
                if (x === 0) ctx.moveTo(x, fy);
                else ctx.lineTo(x, fy);
            }
            ctx.stroke();

            // Sand wind ripples — subtle curved lines
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const rippleY = y + 30 + i * (h - 40) / 8;
                const alpha = 0.04 + (i % 2) * 0.02;
                ctx.strokeStyle = `rgba(255, 248, 220, ${alpha})`;
                ctx.beginPath();
                for (let x = 0; x < W; x += 3) {
                    const ry = rippleY + Math.sin(x * 0.008 + i * 0.7) * 6
                        + Math.sin(x * 0.02 + i * 1.3) * 2;
                    if (x === 0) ctx.moveTo(x, ry);
                    else ctx.lineTo(x, ry);
                }
                ctx.stroke();
            }

            // Sand texture — faint speckles
            ctx.globalAlpha = 0.05;
            ctx.fillStyle = '#fff8e0';
            for (let i = 0; i < 120; i++) {
                const sx = (i * 137.5 + 50) % W;
                const sy = y + 15 + ((i * 97.3 + 30) % (h - 20));
                ctx.fillRect(sx, sy, 1.5, 1.5);
            }
            ctx.globalAlpha = 1;

            // A few small shells scattered on the sand
            drawShell(W * 0.30, H * 0.72, 0.7);
            drawShell(W * 0.72, H * 0.88, 0.5);
            drawShell(W * 0.62, H * 0.76, 0.6);
        }

        function drawShell(x, y, scale) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            ctx.fillStyle = 'rgba(230, 210, 180, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI, true);
            ctx.closePath();
            ctx.fill();
            // Ridge lines
            ctx.strokeStyle = 'rgba(200, 180, 150, 0.2)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(-2, 0);
            ctx.lineTo(0, -3);
            ctx.lineTo(2, 0);
            ctx.stroke();
            ctx.restore();
        }

        function drawPalm(palm, groundY) {
            const baseX = W * palm.x;
            const baseY = H * (groundY || 0.53); // rooted at ground line
            const trunkH = palm.trunkHeight * palm.scale;
            const lean = palm.lean;

            const topX = baseX + lean * trunkH;
            const topY = baseY - trunkH;
            const cpX = baseX + lean * trunkH * 0.6;
            const cpY = baseY - trunkH * 0.5;

            // Trunk shadow
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 14 * palm.scale;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(baseX + 3, baseY + 3);
            ctx.quadraticCurveTo(cpX + 3, cpY + 3, topX + 3, topY + 3);
            ctx.stroke();

            // Trunk
            ctx.strokeStyle = '#1a0e08';
            ctx.lineWidth = 10 * palm.scale;
            ctx.beginPath();
            ctx.moveTo(baseX, baseY);
            ctx.quadraticCurveTo(cpX, cpY, topX, topY);
            ctx.stroke();

            // Trunk highlight edge
            ctx.strokeStyle = '#2d1a10';
            ctx.lineWidth = 6 * palm.scale;
            ctx.beginPath();
            ctx.moveTo(baseX, baseY);
            ctx.quadraticCurveTo(cpX, cpY, topX, topY);
            ctx.stroke();

            // Fronds — stem with leaflets (feather pattern)
            const frondDefs = [
                { angle: -2.8, len: 75 },
                { angle: -2.2, len: 90 },
                { angle: -1.6, len: 85 },
                { angle: -1.0, len: 95 },
                { angle: -0.4, len: 88 },
                { angle: 0.15, len: 80 },
                { angle: 0.65, len: 70 },
            ];

            frondDefs.forEach(({ angle, len }) => {
                const frondLen = len * palm.scale;
                const droop = 0.35; // how much the frond droops

                // Calculate stem curve points
                const stemPoints = [];
                const segments = 12;
                for (let t = 0; t <= segments; t++) {
                    const frac = t / segments;
                    // Stem curves outward then droops
                    const sx = topX + Math.cos(angle) * frondLen * frac;
                    const sy = topY + Math.sin(angle) * frondLen * frac * 0.5
                        + frondLen * droop * frac * frac; // quadratic droop
                    stemPoints.push({ x: sx, y: sy });
                }

                // Draw stem
                ctx.strokeStyle = '#0a1f0a';
                ctx.lineWidth = 2.5 * palm.scale;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(stemPoints[0].x, stemPoints[0].y);
                for (let i = 1; i < stemPoints.length; i++) {
                    ctx.lineTo(stemPoints[i].x, stemPoints[i].y);
                }
                ctx.stroke();

                // Draw leaflets along the stem
                for (let i = 1; i < stemPoints.length; i++) {
                    const frac = i / segments;
                    const pt = stemPoints[i];
                    const prev = stemPoints[i - 1];

                    // Direction of stem at this point
                    const dx = pt.x - prev.x;
                    const dy = pt.y - prev.y;
                    const stemAngle = Math.atan2(dy, dx);

                    // Leaflet length tapers toward tip
                    const leafletLen = (18 + (1 - frac) * 14) * palm.scale;

                    // Draw leaflet on each side
                    for (const side of [-1, 1]) {
                        const leafAngle = stemAngle + side * (0.6 + frac * 0.4);
                        const endLX = pt.x + Math.cos(leafAngle) * leafletLen;
                        const endLY = pt.y + Math.sin(leafAngle) * leafletLen + leafletLen * 0.15;

                        ctx.strokeStyle = i % 2 === 0 ? '#0a1f0a' : '#0f2a0f';
                        ctx.lineWidth = (2.0 - frac * 0.8) * palm.scale;
                        ctx.beginPath();
                        ctx.moveTo(pt.x, pt.y);
                        ctx.lineTo(endLX, endLY);
                        ctx.stroke();
                    }
                }
            });
        }

        // ========================================
        // Sprite System (oneshot-climb style)
        // ========================================

        const SPRITE_PALETTE = {
            '.': null,           // transparent
            'r': '#cc3a1e',      // red
            'R': '#9a2010',      // dark red
            'h': '#e85840',      // highlight red
            'w': '#fff8e7',      // warm white
            'b': '#5a3a22',      // brown (post)
            'B': '#3d2415',      // dark brown
            'k': '#1a0e08',      // outline/dark
            'f': '#e84c30',      // flag red
            'g': '#f5c040',      // gold/yellow
            'n': '#8b6030',      // mid brown
        };

        // 14 wide x 24 tall mailbox sprite
        const MAILBOX_SPRITE = [
            '..............',
            '..............',
            '....rrrrrrf...',
            '...rrrrrrrff..',
            '..hhrrrrrrfgf.',
            '..rrrrrrrrf.f.',
            '..rrrrrrrrf...',
            '..rrrrrrrrf...',
            '..rrrrrrrrr...',
            '..kkkkkkkkk...',
            '..RRRRRRRRR...',
            '..RRRRRRRRR...',
            '..RRRRRRRRR...',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......nnn.....',
            '..............',
        ];

        function drawSprite(sprite, palette, x, y, scale) {
            for (let row = 0; row < sprite.length; row++) {
                for (let col = 0; col < sprite[row].length; col++) {
                    const ch = sprite[row][col];
                    const color = palette[ch];
                    if (!color) continue; // transparent
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        x + col * scale,
                        y + row * scale,
                        scale,
                        scale
                    );
                }
            }
        }

        // 11 wide x 18 tall signpost sprite
        const SIGNPOST_SPRITE = [
            '...........',
            '.nnnnnnnn..',
            '.nwwwwwwn..',
            '.nnnnnnnn..',
            '.....bb....',
            '..nnnnnnnn.',
            '..nwwwwwwn.',
            '..nnnnnnnn.',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....nn....',
            '...........',
        ];

        // ========================================
        // Sprite Catalog
        // ========================================

        const SPRITE_CATALOG = {
            'mailbox': { grid: MAILBOX_SPRITE, palette: SPRITE_PALETTE },
            'signpost': { grid: SIGNPOST_SPRITE, palette: SPRITE_PALETTE },
        };

        function drawSceneSprite(spriteSpec) {
            let grid, palette;

            if (spriteSpec.type === 'catalog') {
                const entry = SPRITE_CATALOG[spriteSpec.name];
                if (!entry) {
                    console.warn(`Unknown catalog sprite: ${spriteSpec.name}`);
                    return;
                }
                grid = entry.grid;
                palette = entry.palette;
            } else if (spriteSpec.type === 'custom') {
                grid = spriteSpec.grid.split('\n');
                palette = { '.': null };
                spriteSpec.palette.forEach(p => { palette[p.char] = p.color; });
            } else {
                console.warn(`Unknown sprite type: ${spriteSpec.type}`);
                return;
            }

            const spriteW = grid[0].length;
            const spriteH = grid.length;
            const scale = spriteSpec.scale || 5;

            const px = Math.round(W * spriteSpec.x - (spriteW * scale) / 2);
            const py = Math.round(H * spriteSpec.groundY - spriteH * scale);

            drawSprite(grid, palette, px, py, scale);
        }

        function drawStars() {
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 80; i++) {
                const x = (i * 173.5 + 42) % W;
                const y = (i * 87.3 + 15) % (H * 0.45);
                const size = 0.5 + (i * 37.7 % 2);
                ctx.globalAlpha = 0.2 + (i * 47.3 % 5) / 10;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function drawForestGround(ground) {
            const y = H * ground.y;
            const h = H - y;

            // Main ground gradient
            const grad = ctx.createLinearGradient(0, y, 0, H);
            grad.addColorStop(0, ground.color);
            grad.addColorStop(0.4, ground.wetColor);
            grad.addColorStop(1, ground.darkColor);
            ctx.fillStyle = grad;
            ctx.fillRect(0, y, W, h);

            // Dirt path down the center
            const pathGrad = ctx.createLinearGradient(W * 0.35, 0, W * 0.65, 0);
            pathGrad.addColorStop(0, 'rgba(90, 60, 30, 0)');
            pathGrad.addColorStop(0.15, 'rgba(70, 45, 20, 0.3)');
            pathGrad.addColorStop(0.5, 'rgba(85, 55, 30, 0.45)');
            pathGrad.addColorStop(0.85, 'rgba(70, 45, 20, 0.3)');
            pathGrad.addColorStop(1, 'rgba(90, 60, 30, 0)');
            ctx.fillStyle = pathGrad;
            ctx.fillRect(0, y, W, h);

            // Grass tufts along edges
            for (let i = 0; i < 50; i++) {
                const gx = (i * 137.5 + 50) % W;
                const gy = y + 8 + ((i * 97.3 + 20) % (h - 12));
                if (gx > W * 0.36 && gx < W * 0.64) continue;
                ctx.globalAlpha = 0.25 + (i % 3) * 0.08;
                ctx.strokeStyle = i % 2 === 0 ? '#2a5a20' : '#1e4018';
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                ctx.moveTo(gx, gy);
                ctx.lineTo(gx - 2, gy - 5 - (i % 4));
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(gx + 2, gy);
                ctx.lineTo(gx + 4, gy - 4 - (i % 3));
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Scattered leaf debris
            ctx.globalAlpha = 0.07;
            const leafColors = ['#4a7030', '#6a5020', '#3a5a25'];
            for (let i = 0; i < 80; i++) {
                const lx = (i * 157.3 + 30) % W;
                const ly = y + 8 + ((i * 83.7 + 25) % (h - 12));
                ctx.fillStyle = leafColors[i % 3];
                ctx.fillRect(lx, ly, 2 + (i % 2), 1.5);
            }
            ctx.globalAlpha = 1;
        }

        function drawFireflies() {
            for (let i = 0; i < 20; i++) {
                const fx = (i * 197.3 + 80) % W;
                const fy = H * 0.15 + ((i * 127.7 + 40) % (H * 0.65));
                const size = 1.5 + (i % 3) * 0.5;

                // Glow
                const glow = ctx.createRadialGradient(fx, fy, 0, fx, fy, size * 8);
                glow.addColorStop(0, 'rgba(180, 230, 100, 0.25)');
                glow.addColorStop(0.4, 'rgba(180, 230, 100, 0.06)');
                glow.addColorStop(1, 'rgba(180, 230, 100, 0)');
                ctx.fillStyle = glow;
                ctx.fillRect(fx - size * 8, fy - size * 8, size * 16, size * 16);

                // Core dot
                ctx.fillStyle = 'rgba(220, 255, 150, 0.6)';
                ctx.beginPath();
                ctx.arc(fx, fy, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // ========================================
        // Backgrounds
        // ========================================

        const BACKGROUNDS = {
            'sunset-beach': function() {
                drawSky({ colors: ['#070422', '#1a0d44', '#4a1a6b', '#8b2252', '#c44a2f', '#e8852a', '#f5c040'] });
                drawClouds();
                drawSun({ x: 0.5, y: 0.35, radius: 32, glowRadius: 130 });
                drawOcean({ y: 0.40, height: 0.13, deepColor: '#0d2847', shallowColor: '#1a4a6b' });
                drawSand({ y: 0.53, color: '#c9a34e', wetColor: '#a08030', darkColor: '#7a6020' });

                [
                    { x: 0.08, trunkHeight: 220, lean: -0.16, scale: 1.0 },
                    { x: 0.02, trunkHeight: 160, lean: -0.22, scale: 0.8 },
                    { x: 0.92, trunkHeight: 210, lean: 0.14, scale: 0.95 },
                    { x: 0.98, trunkHeight: 140, lean: 0.26, scale: 0.75 },
                ].forEach(p => drawPalm(p, 0.53));

                // Warm golden hour light wash
                const warmWash = ctx.createRadialGradient(W * 0.5, H * 0.38, 50, W * 0.5, H * 0.55, W * 0.6);
                warmWash.addColorStop(0, 'rgba(245, 200, 80, 0.08)');
                warmWash.addColorStop(0.5, 'rgba(230, 160, 60, 0.04)');
                warmWash.addColorStop(1, 'rgba(230, 160, 60, 0)');
                ctx.fillStyle = warmWash;
                ctx.fillRect(0, H * 0.5, W, H * 0.5);

                // Vignette
                const vig = ctx.createRadialGradient(W * 0.5, H * 0.4, W * 0.25, W * 0.5, H * 0.4, W * 0.65);
                vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(1, 'rgba(0, 0, 0, 0.35)');
                ctx.fillStyle = vig;
                ctx.fillRect(0, 0, W, H);
            },

            'twilight-forest': function() {
                drawSky({ colors: ['#030318', '#050528', '#0a0a38', '#121250', '#1a1a60', '#202868'], height: 0.50 });
                drawStars();
                drawForestGround({ y: 0.50, color: '#2a4a20', wetColor: '#1a3515', darkColor: '#0f200a' });

                [
                    { x: 0.04, trunkHeight: 280, lean: -0.06, scale: 1.15 },
                    { x: 0.14, trunkHeight: 240, lean: -0.10, scale: 1.0 },
                    { x: 0.86, trunkHeight: 260, lean: 0.08, scale: 1.05 },
                    { x: 0.96, trunkHeight: 230, lean: 0.12, scale: 0.95 },
                    { x: -0.02, trunkHeight: 200, lean: -0.18, scale: 0.85 },
                    { x: 1.02, trunkHeight: 210, lean: 0.16, scale: 0.9 },
                ].forEach(p => drawPalm(p, 0.50));

                drawFireflies();

                // Cool moonlit wash
                const coolWash = ctx.createRadialGradient(W * 0.5, H * 0.3, 30, W * 0.5, H * 0.5, W * 0.5);
                coolWash.addColorStop(0, 'rgba(100, 140, 200, 0.06)');
                coolWash.addColorStop(0.5, 'rgba(80, 100, 160, 0.03)');
                coolWash.addColorStop(1, 'rgba(80, 100, 160, 0)');
                ctx.fillStyle = coolWash;
                ctx.fillRect(0, 0, W, H);

                // Vignette
                const vig = ctx.createRadialGradient(W * 0.5, H * 0.4, W * 0.25, W * 0.5, H * 0.4, W * 0.65);
                vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
                ctx.fillStyle = vig;
                ctx.fillRect(0, 0, W, H);
            },

            'cave-entrance': function() {
                // Dusky sky behind the cave opening
                drawSky({ colors: ['#0a0820', '#1a1040', '#3a2060', '#6a3050', '#8a5040'], height: 0.55 });
                drawStars();

                // Rocky cliff face — left and right walls framing a dark opening
                const rockGrad = ctx.createLinearGradient(0, 0, 0, H);
                rockGrad.addColorStop(0, '#2a2018');
                rockGrad.addColorStop(0.5, '#3a2a1a');
                rockGrad.addColorStop(1, '#1a1208');
                ctx.fillStyle = rockGrad;

                // Left rock wall
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(W * 0.32, 0);
                ctx.lineTo(W * 0.28, H * 0.25);
                ctx.lineTo(W * 0.22, H * 0.55);
                ctx.lineTo(W * 0.18, H);
                ctx.lineTo(0, H);
                ctx.closePath();
                ctx.fill();

                // Right rock wall
                ctx.beginPath();
                ctx.moveTo(W, 0);
                ctx.lineTo(W * 0.68, 0);
                ctx.lineTo(W * 0.72, H * 0.25);
                ctx.lineTo(W * 0.78, H * 0.55);
                ctx.lineTo(W * 0.82, H);
                ctx.lineTo(W, H);
                ctx.closePath();
                ctx.fill();

                // Rock overhang across top
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(W, 0);
                ctx.lineTo(W * 0.72, H * 0.25);
                ctx.quadraticCurveTo(W * 0.5, H * 0.18, W * 0.28, H * 0.25);
                ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();

                // Rock texture — faint cracks
                ctx.strokeStyle = 'rgba(60, 45, 30, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 15; i++) {
                    const sx = (i * 157 + 20) % W;
                    const sy = (i * 93 + 10) % H;
                    if (sx > W * 0.25 && sx < W * 0.75 && sy > H * 0.25) continue;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx + 15 - (i % 3) * 8, sy + 10 + (i % 4) * 5);
                    ctx.stroke();
                }

                // Mossy ground
                const groundY = H * 0.75;
                const groundGrad = ctx.createLinearGradient(0, groundY, 0, H);
                groundGrad.addColorStop(0, '#2a3a18');
                groundGrad.addColorStop(0.5, '#1a2a10');
                groundGrad.addColorStop(1, '#0f1a08');
                ctx.fillStyle = groundGrad;
                ctx.fillRect(0, groundY, W, H - groundY);

                // Warm glow from inside the cave
                const glow = ctx.createRadialGradient(W * 0.5, H * 0.65, 10, W * 0.5, H * 0.65, W * 0.25);
                glow.addColorStop(0, 'rgba(230, 140, 50, 0.15)');
                glow.addColorStop(0.4, 'rgba(200, 100, 30, 0.06)');
                glow.addColorStop(1, 'rgba(200, 100, 30, 0)');
                ctx.fillStyle = glow;
                ctx.fillRect(0, 0, W, H);

                // Vignette
                const vig = ctx.createRadialGradient(W * 0.5, H * 0.4, W * 0.2, W * 0.5, H * 0.4, W * 0.65);
                vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(0.6, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(1, 'rgba(0, 0, 0, 0.55)');
                ctx.fillStyle = vig;
                ctx.fillRect(0, 0, W, H);
            },

            'cave-inside': function() {
                // Dark cavern — no sky
                ctx.fillStyle = '#080808';
                ctx.fillRect(0, 0, W, H);

                // Stone walls — subtle gradient from dark gray
                const wallGrad = ctx.createRadialGradient(W * 0.5, H * 0.5, W * 0.1, W * 0.5, H * 0.5, W * 0.6);
                wallGrad.addColorStop(0, '#1a1818');
                wallGrad.addColorStop(0.5, '#121010');
                wallGrad.addColorStop(1, '#080808');
                ctx.fillStyle = wallGrad;
                ctx.fillRect(0, 0, W, H);

                // Stalactites hanging from ceiling
                for (let i = 0; i < 12; i++) {
                    const sx = W * 0.05 + (i * 137.7 + 30) % (W * 0.9);
                    const sLen = 30 + (i * 47.3 % 50);
                    const sWidth = 4 + (i % 3) * 3;
                    const grad = ctx.createLinearGradient(sx, 0, sx, sLen);
                    grad.addColorStop(0, '#2a2525');
                    grad.addColorStop(1, '#181515');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(sx - sWidth, 0);
                    ctx.lineTo(sx, sLen);
                    ctx.lineTo(sx + sWidth, 0);
                    ctx.closePath();
                    ctx.fill();
                }

                // Stalagmites rising from floor
                const floorY = H * 0.70;
                for (let i = 0; i < 10; i++) {
                    const sx = W * 0.05 + (i * 163.3 + 50) % (W * 0.9);
                    const sLen = 25 + (i * 53.7 % 40);
                    const sWidth = 5 + (i % 3) * 3;
                    const grad = ctx.createLinearGradient(sx, H, sx, floorY - sLen);
                    grad.addColorStop(0, '#2a2525');
                    grad.addColorStop(1, '#181515');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(sx - sWidth, H);
                    ctx.lineTo(sx, floorY - sLen);
                    ctx.lineTo(sx + sWidth, H);
                    ctx.closePath();
                    ctx.fill();
                }

                // Damp stone floor
                const floorGrad = ctx.createLinearGradient(0, floorY, 0, H);
                floorGrad.addColorStop(0, '#1a1818');
                floorGrad.addColorStop(0.3, '#151313');
                floorGrad.addColorStop(1, '#0e0c0c');
                ctx.fillStyle = floorGrad;
                ctx.fillRect(0, floorY, W, H - floorY);

                // Glowing crystals — scattered colored light sources
                const crystalColors = [
                    { r: 100, g: 180, b: 255 },
                    { r: 180, g: 100, b: 255 },
                    { r: 100, g: 255, b: 180 },
                    { r: 255, g: 180, b: 100 },
                ];
                for (let i = 0; i < 8; i++) {
                    const cx = W * 0.1 + (i * 173.5 + 60) % (W * 0.8);
                    const cy = H * 0.2 + (i * 97.3 + 30) % (H * 0.5);
                    const c = crystalColors[i % crystalColors.length];
                    const size = 2 + (i % 3);

                    // Glow halo
                    const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 15);
                    glow.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, 0.2)`);
                    glow.addColorStop(0.3, `rgba(${c.r}, ${c.g}, ${c.b}, 0.06)`);
                    glow.addColorStop(1, `rgba(${c.r}, ${c.g}, ${c.b}, 0)`);
                    ctx.fillStyle = glow;
                    ctx.fillRect(cx - size * 15, cy - size * 15, size * 30, size * 30);

                    // Crystal core
                    ctx.fillStyle = `rgba(${c.r}, ${c.g}, ${c.b}, 0.7)`;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - size * 2);
                    ctx.lineTo(cx + size, cy);
                    ctx.lineTo(cx, cy + size);
                    ctx.lineTo(cx - size, cy);
                    ctx.closePath();
                    ctx.fill();
                }

                // Vignette — extra strong for cave feel
                const vig = ctx.createRadialGradient(W * 0.5, H * 0.45, W * 0.15, W * 0.5, H * 0.45, W * 0.55);
                vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(0.5, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
                ctx.fillStyle = vig;
                ctx.fillRect(0, 0, W, H);
            },

            'winding-path': function() {
                // Bright daytime sky
                drawSky({ colors: ['#1a3a6a', '#2a5a9a', '#4a8acc', '#7ab8e8', '#a8d8f0'], height: 0.50 });

                // Fluffy white clouds
                const clouds = [
                    { x: 0.18, y: 0.10, w: 120, h: 20, opacity: 0.6 },
                    { x: 0.45, y: 0.08, w: 160, h: 24, opacity: 0.5 },
                    { x: 0.72, y: 0.14, w: 100, h: 18, opacity: 0.55 },
                    { x: 0.88, y: 0.06, w: 80, h: 16, opacity: 0.4 },
                ];
                clouds.forEach(c => {
                    const cx = W * c.x;
                    const cy = H * c.y;
                    ctx.fillStyle = `rgba(255, 255, 255, ${c.opacity})`;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, c.w / 2, c.h / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Softer edge
                    ctx.fillStyle = `rgba(255, 255, 255, ${c.opacity * 0.3})`;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, c.w / 2 + 15, c.h / 2 + 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Rolling green hills
                const hillY = H * 0.45;
                const hillGrad = ctx.createLinearGradient(0, hillY, 0, H);
                hillGrad.addColorStop(0, '#4a8a30');
                hillGrad.addColorStop(0.3, '#3a7025');
                hillGrad.addColorStop(0.7, '#2a5a1a');
                hillGrad.addColorStop(1, '#1a4010');
                ctx.fillStyle = hillGrad;
                ctx.fillRect(0, hillY, W, H - hillY);

                // Hill contours
                ctx.fillStyle = '#3a7828';
                ctx.beginPath();
                ctx.moveTo(0, H * 0.52);
                ctx.quadraticCurveTo(W * 0.2, H * 0.42, W * 0.4, H * 0.50);
                ctx.quadraticCurveTo(W * 0.6, H * 0.58, W * 0.8, H * 0.48);
                ctx.quadraticCurveTo(W * 0.95, H * 0.42, W, H * 0.50);
                ctx.lineTo(W, H);
                ctx.lineTo(0, H);
                ctx.closePath();
                ctx.fill();

                // Winding dirt path
                ctx.strokeStyle = '#8a6a3a';
                ctx.lineWidth = 30;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(W * 0.45, H);
                ctx.bezierCurveTo(W * 0.42, H * 0.80, W * 0.55, H * 0.65, W * 0.48, H * 0.50);
                ctx.stroke();
                // Path edge highlight
                ctx.strokeStyle = '#a08050';
                ctx.lineWidth = 18;
                ctx.beginPath();
                ctx.moveTo(W * 0.45, H);
                ctx.bezierCurveTo(W * 0.42, H * 0.80, W * 0.55, H * 0.65, W * 0.48, H * 0.50);
                ctx.stroke();

                // Wildflowers — small colored dots
                const flowerColors = ['#e84060', '#e8a040', '#e8e040', '#a040e8', '#40a0e8'];
                for (let i = 0; i < 40; i++) {
                    const fx = (i * 157.3 + 40) % W;
                    const fy = hillY + 20 + ((i * 83.7 + 15) % (H - hillY - 30));
                    // Skip if on the path
                    if (fx > W * 0.38 && fx < W * 0.58 && fy > H * 0.50) continue;
                    ctx.fillStyle = flowerColors[i % flowerColors.length];
                    ctx.globalAlpha = 0.5 + (i % 3) * 0.15;
                    ctx.beginPath();
                    ctx.arc(fx, fy, 2 + (i % 2), 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Warm sunlight wash
                const warmWash = ctx.createRadialGradient(W * 0.6, H * 0.15, 30, W * 0.5, H * 0.4, W * 0.6);
                warmWash.addColorStop(0, 'rgba(255, 240, 180, 0.1)');
                warmWash.addColorStop(0.5, 'rgba(255, 240, 180, 0.03)');
                warmWash.addColorStop(1, 'rgba(255, 240, 180, 0)');
                ctx.fillStyle = warmWash;
                ctx.fillRect(0, 0, W, H);

                // Vignette — lighter than night scenes
                const vig = ctx.createRadialGradient(W * 0.5, H * 0.4, W * 0.3, W * 0.5, H * 0.4, W * 0.7);
                vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(1, 'rgba(0, 0, 0, 0.25)');
                ctx.fillStyle = vig;
                ctx.fillRect(0, 0, W, H);
            },

            'moonlit-lake': function() {
                // Night sky
                drawSky({ colors: ['#020210', '#050520', '#0a0a35', '#101045', '#151555'], height: 0.50 });
                drawStars();

                // Moon — adapted from drawSun with silver palette
                const moonX = W * 0.7;
                const moonY = H * 0.18;
                const moonR = 22;

                // Moon glow
                const moonGlow = ctx.createRadialGradient(moonX, moonY, moonR * 0.5, moonX, moonY, moonR * 5);
                moonGlow.addColorStop(0, 'rgba(200, 220, 255, 0.3)');
                moonGlow.addColorStop(0.3, 'rgba(180, 200, 240, 0.08)');
                moonGlow.addColorStop(1, 'rgba(180, 200, 240, 0)');
                ctx.fillStyle = moonGlow;
                ctx.beginPath();
                ctx.arc(moonX, moonY, moonR * 5, 0, Math.PI * 2);
                ctx.fill();

                // Moon disc
                const moonDisc = ctx.createRadialGradient(moonX, moonY, 0, moonX, moonY, moonR);
                moonDisc.addColorStop(0, '#f0f0ff');
                moonDisc.addColorStop(0.6, '#d8dce8');
                moonDisc.addColorStop(1, '#b0b8c8');
                ctx.beginPath();
                ctx.arc(moonX, moonY, moonR, 0, Math.PI * 2);
                ctx.fillStyle = moonDisc;
                ctx.fill();

                // Lake water
                const lakeY = H * 0.50;
                const lakeGrad = ctx.createLinearGradient(0, lakeY, 0, H);
                lakeGrad.addColorStop(0, '#0a1530');
                lakeGrad.addColorStop(0.3, '#081020');
                lakeGrad.addColorStop(1, '#050a15');
                ctx.fillStyle = lakeGrad;
                ctx.fillRect(0, lakeY, W, H - lakeY);

                // Moon reflection on water
                const refGrad = ctx.createRadialGradient(moonX, lakeY + 10, 0, moonX, lakeY + H * 0.2, 80);
                refGrad.addColorStop(0, 'rgba(200, 220, 255, 0.2)');
                refGrad.addColorStop(0.3, 'rgba(180, 200, 240, 0.08)');
                refGrad.addColorStop(1, 'rgba(180, 200, 240, 0)');
                ctx.fillStyle = refGrad;
                ctx.fillRect(0, lakeY, W, H - lakeY);

                // Reflection shimmer streaks
                ctx.globalAlpha = 0.08;
                ctx.strokeStyle = '#c0d0ff';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 5; i++) {
                    const sy = lakeY + 15 + i * 20;
                    const sw = 20 + (3 - Math.abs(i - 2)) * 15;
                    ctx.beginPath();
                    ctx.moveTo(moonX - sw / 2, sy);
                    ctx.lineTo(moonX + sw / 2, sy);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // Reeds along shore — left and right clusters
                for (let i = 0; i < 20; i++) {
                    const rx = i < 10
                        ? W * 0.02 + (i * 23)
                        : W * 0.78 + ((i - 10) * 25);
                    const ry = lakeY;
                    const rh = 25 + (i * 37 % 20);
                    ctx.strokeStyle = i % 2 === 0 ? '#1a2a15' : '#152210';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(rx, ry);
                    ctx.lineTo(rx + (i % 3 - 1) * 3, ry - rh);
                    ctx.stroke();
                }

                // Mist hovering over water
                for (let i = 0; i < 4; i++) {
                    const my = lakeY + 5 + i * 18;
                    const mx = W * (0.1 + i * 0.2);
                    const mw = 150 + (i * 50);
                    ctx.fillStyle = `rgba(150, 170, 200, ${0.04 - i * 0.008})`;
                    ctx.beginPath();
                    ctx.ellipse(mx, my, mw / 2, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Cool wash
                const coolWash = ctx.createRadialGradient(W * 0.5, H * 0.3, 30, W * 0.5, H * 0.5, W * 0.5);
                coolWash.addColorStop(0, 'rgba(80, 120, 180, 0.05)');
                coolWash.addColorStop(1, 'rgba(80, 120, 180, 0)');
                ctx.fillStyle = coolWash;
                ctx.fillRect(0, 0, W, H);

                // Vignette
                const vig = ctx.createRadialGradient(W * 0.5, H * 0.4, W * 0.2, W * 0.5, H * 0.4, W * 0.6);
                vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(0.6, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
                ctx.fillStyle = vig;
                ctx.fillRect(0, 0, W, H);
            },

            'meadow-clearing': function() {
                // Golden hour sky — different palette than sunset-beach
                drawSky({ colors: ['#2a3a5a', '#4a5a7a', '#7a8a60', '#a8a850', '#c8b840', '#e0d060'], height: 0.45 });

                // Soft sun glow (lower, more diffuse than beach)
                const sunGlow = ctx.createRadialGradient(W * 0.4, H * 0.35, 20, W * 0.4, H * 0.35, 150);
                sunGlow.addColorStop(0, 'rgba(240, 220, 100, 0.25)');
                sunGlow.addColorStop(0.3, 'rgba(240, 200, 80, 0.08)');
                sunGlow.addColorStop(1, 'rgba(240, 200, 80, 0)');
                ctx.fillStyle = sunGlow;
                ctx.fillRect(0, 0, W, H * 0.5);

                // Grassland ground
                const groundY = H * 0.48;
                const grassGrad = ctx.createLinearGradient(0, groundY, 0, H);
                grassGrad.addColorStop(0, '#5a8a30');
                grassGrad.addColorStop(0.3, '#4a7a28');
                grassGrad.addColorStop(0.7, '#3a6820');
                grassGrad.addColorStop(1, '#2a5018');
                ctx.fillStyle = grassGrad;
                ctx.fillRect(0, groundY, W, H - groundY);

                // Tall grass strokes
                for (let i = 0; i < 120; i++) {
                    const gx = (i * 97.3 + 15) % W;
                    const gy = groundY + ((i * 67.7 + 20) % (H - groundY - 5));
                    const gh = 8 + (i * 37.3 % 12);
                    const lean = (i % 5 - 2) * 1.5;
                    ctx.strokeStyle = i % 3 === 0 ? '#6a9a38' : i % 3 === 1 ? '#5a8830' : '#4a7528';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4 + (i % 4) * 0.1;
                    ctx.beginPath();
                    ctx.moveTo(gx, gy);
                    ctx.lineTo(gx + lean, gy - gh);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // Wildflowers scattered
                const flowerColors = ['#e85060', '#f0a030', '#f0e040', '#d060d0', '#f0f0f0'];
                for (let i = 0; i < 25; i++) {
                    const fx = (i * 143.7 + 30) % W;
                    const fy = groundY + 15 + ((i * 77.3 + 20) % (H - groundY - 25));
                    ctx.fillStyle = flowerColors[i % flowerColors.length];
                    ctx.globalAlpha = 0.6 + (i % 3) * 0.1;
                    ctx.beginPath();
                    ctx.arc(fx, fy, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Butterflies — similar to fireflies but daytime colors
                for (let i = 0; i < 6; i++) {
                    const bx = W * 0.1 + (i * 187.3 + 50) % (W * 0.8);
                    const by = H * 0.25 + (i * 117.7 + 30) % (H * 0.45);
                    const bc = flowerColors[i % flowerColors.length];

                    ctx.fillStyle = bc;
                    ctx.globalAlpha = 0.5;
                    // Two little wing dots
                    ctx.beginPath();
                    ctx.ellipse(bx - 2, by, 2.5, 1.5, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(bx + 2, by, 2.5, 1.5, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Warm golden wash
                const warmWash = ctx.createRadialGradient(W * 0.4, H * 0.35, 50, W * 0.5, H * 0.5, W * 0.6);
                warmWash.addColorStop(0, 'rgba(240, 210, 80, 0.08)');
                warmWash.addColorStop(0.5, 'rgba(230, 190, 60, 0.03)');
                warmWash.addColorStop(1, 'rgba(230, 190, 60, 0)');
                ctx.fillStyle = warmWash;
                ctx.fillRect(0, 0, W, H);

                // Light vignette
                const vig = ctx.createRadialGradient(W * 0.5, H * 0.4, W * 0.3, W * 0.5, H * 0.4, W * 0.7);
                vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
                ctx.fillStyle = vig;
                ctx.fillRect(0, 0, W, H);
            },
        };

        // ========================================
        // Scene Renderer
        // ========================================

        function renderScene(scene, isFirstScene) {
            ctx.clearRect(0, 0, W, H);

            // Draw background
            BACKGROUNDS[scene.background]();

            // Draw foreground sprites
            if (scene.sprites) {
                scene.sprites.forEach(drawSceneSprite);
            }

            // Display narration
            const narrationEl = document.getElementById('narration');
            narrationEl.textContent = scene.narration;

            // Display choices
            const choicesEl = document.getElementById('choices');
            choicesEl.innerHTML = '';
            scene.choices.forEach((choice) => {
                const btn = document.createElement('button');
                btn.className = 'choice-btn';
                btn.textContent = choice;
                btn.addEventListener('click', () => handleChoice(choice));
                choicesEl.appendChild(btn);
            });

            // Retrigger fade-in animations for scene transitions
            if (!isFirstScene) {
                narrationEl.style.animation = 'none';
                narrationEl.offsetHeight;
                narrationEl.style.animation = 'fadeIn 0.8s ease 0.1s forwards';

                choicesEl.style.animation = 'none';
                choicesEl.offsetHeight;
                choicesEl.style.animation = 'fadeIn 0.8s ease 1.0s forwards';
            }
        }

        // ========================================
        // AI Generation
        // ========================================

        const SCENE_SCHEMA = {
            type: 'object',
            properties: {
                background: {
                    type: 'string',
                    enum: Object.keys(BACKGROUNDS),
                    description: 'Background scene name from the available catalog'
                },
                narration: {
                    type: 'string',
                    description: 'Scene narration, 1-4 sentences'
                },
                choices: {
                    type: 'array',
                    items: { type: 'string' },
                    description: '2-3 choices for the player'
                },
                sprites: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            type: { type: 'string', enum: ['catalog', 'custom'] },
                            name: { type: 'string', description: 'Sprite identifier' },
                            x: { type: 'number', description: '0.0 (left) to 1.0 (right)' },
                            groundY: { type: 'number', description: '0.7-0.95, vertical base position' },
                            scale: { type: 'number', description: '3-7, pixel scale factor' },
                            grid: { type: 'string', description: 'For custom sprites: rows separated by \\n, each char maps to a palette color, . = transparent' },
                            palette: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        char: { type: 'string' },
                                        color: { type: 'string' }
                                    },
                                    required: ['char', 'color'],
                                    additionalProperties: false
                                },
                                description: 'For custom sprites: color mappings'
                            }
                        },
                        required: ['type', 'name', 'x', 'groundY', 'scale'],
                        additionalProperties: false
                    },
                    description: '0-2 foreground sprites'
                }
            },
            required: ['background', 'narration', 'choices', 'sprites'],
            additionalProperties: false
        };

        const SYSTEM_PROMPT = `You are the narrator of Story Cauldron, a whimsical choose-your-own-adventure game set on a mysterious island. You speak in second person ("You see...", "You hear..."). Your tone is warm, playful, and full of wonder — like a storybook read aloud to a family. This is a family-friendly game.

RULES:
- Narration: 1-4 sentences. Vivid but concise. Describe what the player sees, hears, smells.
- Choices: Exactly 2-3 options. Short action phrases. At least one should be unexpected or whimsical.
- Background: Pick the most fitting background from the available set.
- Sprites: 0-2 sprites per scene. Use catalog sprites when they fit. Create custom sprites for new objects the story calls for (keep grids small: 8-16 wide, 8-20 tall, use single characters for colors, '.' for transparent).
- Continuity: Remember what happened in previous scenes. Reference earlier events naturally.
- Never break character. Never mention AI, tokens, or the game engine.
- The island is mysterious but friendly. Not scary. Think whimsical bedtime story.

AVAILABLE BACKGROUNDS: ${Object.keys(BACKGROUNDS).join(', ')}

SPRITE CATALOG (use type "catalog" with these names): ${Object.keys(SPRITE_CATALOG).join(', ')}

CUSTOM SPRITES (type "custom"):
- grid: A string with rows separated by \\n. Each character maps to a color. Use '.' for transparent.
- palette: Array of {char, color} pairs. Only include non-transparent characters.
- Keep sprites small and charming. 8-16 characters wide, 8-20 rows tall.
- x: 0.0 (left) to 1.0 (right), groundY: 0.7-0.95 (vertical position where sprite base sits)
- scale: 3-7 (pixel scale factor)`;

        const conversationHistory = [];

        async function generateScene(choiceText) {
            const userMessage = conversationHistory.length === 0
                ? `The player chose: "${choiceText}"\n\nThis is their first choice after waking up on a beach at sunset and finding a bright red mailbox standing in the sand with its flag up. Generate the next scene.`
                : `The player chose: "${choiceText}"`;

            conversationHistory.push({ role: 'user', content: userMessage });

            const response = await fetch('/api/inference/anthropic/messages', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    model: 'claude-haiku-4-5-20251001',
                    max_tokens: 1024,
                    system: SYSTEM_PROMPT,
                    messages: [...conversationHistory],
                    output_config: {
                        format: {
                            type: 'json_schema',
                            schema: SCENE_SCHEMA
                        }
                    }
                })
            });

            if (!response.ok) {
                const err = await response.json().catch(() => ({ error: 'Unknown error' }));
                if (response.status === 401) throw new Error('AUTH_REQUIRED');
                throw new Error(err.error || err.message || `API error ${response.status}`);
            }

            const data = await response.json();
            const sceneText = data.content[0].text;
            const scene = JSON.parse(sceneText);

            // Validate background exists
            if (!BACKGROUNDS[scene.background]) {
                console.warn(`AI picked unknown background "${scene.background}", falling back`);
                scene.background = 'twilight-forest';
            }

            // Add assistant response to history
            conversationHistory.push({ role: 'assistant', content: sceneText });

            return scene;
        }

        // ========================================
        // Scene Transition
        // ========================================

        async function handleChoice(choice) {
            console.log(`Choice selected: ${choice}`);

            const overlay = document.getElementById('transition-overlay');
            const loadingText = document.getElementById('loading-text');

            // Disable choice buttons
            document.querySelectorAll('.choice-btn').forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
            });

            // Show overlay
            loadingText.textContent = 'The story unfolds...';
            loadingText.style.animation = 'pulse 2s ease-in-out infinite';
            overlay.classList.add('active');

            try {
                const scene = await generateScene(choice);

                // Let overlay fully appear before rendering behind it
                await new Promise(r => setTimeout(r, 400));

                renderScene(scene, false);

                // Fade out overlay
                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 300);
            } catch (err) {
                console.error('Scene generation failed:', err);
                loadingText.style.animation = 'none';

                if (err.message === 'AUTH_REQUIRED') {
                    loadingText.innerHTML = 'Please <a href="/login.html" style="color: #e8852a;">log in</a> to play.';
                } else {
                    loadingText.textContent = 'Something went wrong. Click to try again.';
                    overlay.style.cursor = 'pointer';
                    const retry = () => {
                        overlay.style.cursor = '';
                        overlay.removeEventListener('click', retry);
                        overlay.classList.remove('active');
                        // Re-enable choice buttons
                        document.querySelectorAll('.choice-btn').forEach(btn => {
                            btn.disabled = false;
                            btn.style.opacity = '1';
                        });
                        // Remove the failed user message from history
                        conversationHistory.pop();
                    };
                    overlay.addEventListener('click', retry);
                }
            }
        }

        // ========================================
        // Init
        // ========================================

        renderScene(openingScene, true);
    </script>
</body>
</html>
