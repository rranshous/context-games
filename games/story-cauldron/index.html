<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Story Cauldron</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0a1a;
            color: #e8e0d4;
            font-family: Georgia, 'Times New Roman', serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        #scene-container {
            width: 100%;
            flex: 1 1 0;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px 20px 0;
            min-height: 0;
        }

        #scene {
            max-width: 100%;
            max-height: 100%;
            border-radius: 12px;
            box-shadow: 0 0 60px rgba(230, 126, 34, 0.15), 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #narration {
            padding: 24px 48px 4px;
            text-align: center;
            font-size: 1.4rem;
            line-height: 1.7;
            max-width: 800px;
            white-space: pre-line;
            flex-shrink: 0;
            opacity: 0;
            animation: fadeIn 2s ease forwards;
            animation-delay: 0.5s;
        }

        #choices {
            padding: 16px 48px 32px;
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
            flex-shrink: 0;
            opacity: 0;
            animation: fadeIn 1.5s ease forwards;
            animation-delay: 2.5s;
        }

        .choice-btn {
            background: rgba(229, 152, 80, 0.1);
            border: 2px solid rgba(229, 152, 80, 0.35);
            color: #e8e0d4;
            font-family: Georgia, 'Times New Roman', serif;
            font-size: 1.15rem;
            padding: 14px 28px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.02em;
        }

        .choice-btn:hover {
            background: rgba(229, 152, 80, 0.25);
            border-color: rgba(229, 152, 80, 0.7);
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(229, 152, 80, 0.15);
        }

        .choice-btn:active {
            transform: translateY(0);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #transition-overlay {
            position: fixed;
            inset: 0;
            background: #0a0a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
            z-index: 100;
        }

        #transition-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        #loading-text {
            font-size: 1.5rem;
            font-style: italic;
            animation: pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div id="scene-container">
        <canvas id="scene" width="1120" height="520"></canvas>
    </div>
    <div id="narration"></div>
    <div id="choices"></div>
    <div id="transition-overlay"><span id="loading-text">The story unfolds...</span></div>

    <script>
        // ========================================
        // Scene Data
        // ========================================

        const openingScene = {
            background: 'sunset-beach',
            mailbox: { x: 0.50, groundY: 0.90, spriteScale: 6 },
            narration: "You open your eyes to warm sunlight and the sound of gentle waves. Sand beneath your fingers. A soft breeze carries the smell of salt and something sweet.\n\nAs your vision clears, you notice something odd: a bright red mailbox, standing upright in the sand just a few feet away. Its little flag is up.",
            choices: [
                "Open the mailbox",
                "Look around the beach",
                "Walk toward the water"
            ]
        };

        const forestScene = {
            background: 'twilight-forest',
            signpost: { x: 0.50, groundY: 0.88, spriteScale: 5 },
            narration: "You follow a narrow trail away from the beach, pushing through broad leaves and dangling vines. The air grows cooler, thick with the smell of earth and flowers you can't name.\n\nThe path forks at a weathered wooden signpost. One arrow reads \"The Garden.\" The other: \"The Workshop.\" Tiny lights drift lazily between the trees.",
            choices: [
                "Take the path to The Garden",
                "Head toward The Workshop",
                "Go back to the beach"
            ]
        };

        // ========================================
        // Renderer
        // ========================================

        const canvas = document.getElementById('scene');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        function drawSky(sky) {
            const skyH = H * (sky.height || 0.45);
            const grad = ctx.createLinearGradient(0, 0, 0, skyH);
            const stops = sky.colors;
            for (let i = 0; i < stops.length; i++) {
                grad.addColorStop(i / (stops.length - 1), stops[i]);
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
        }

        function drawSun(sun) {
            const cx = W * sun.x;
            const cy = H * sun.y;

            // Wide atmospheric glow
            const atmo = ctx.createRadialGradient(cx, cy, 0, cx, cy, sun.glowRadius * 2);
            atmo.addColorStop(0, 'rgba(245, 192, 64, 0.3)');
            atmo.addColorStop(0.25, 'rgba(232, 133, 42, 0.12)');
            atmo.addColorStop(0.5, 'rgba(196, 74, 47, 0.04)');
            atmo.addColorStop(1, 'rgba(196, 74, 47, 0)');
            ctx.fillStyle = atmo;
            ctx.fillRect(0, 0, W, H * 0.55);

            // Inner glow
            const glow = ctx.createRadialGradient(cx, cy, sun.radius * 0.5, cx, cy, sun.glowRadius);
            glow.addColorStop(0, 'rgba(245, 192, 64, 0.5)');
            glow.addColorStop(0.4, 'rgba(245, 192, 64, 0.15)');
            glow.addColorStop(1, 'rgba(245, 192, 64, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(cx, cy, sun.glowRadius, 0, Math.PI * 2);
            ctx.fill();

            // Sun disc
            const disc = ctx.createRadialGradient(cx, cy, 0, cx, cy, sun.radius);
            disc.addColorStop(0, '#fffbe8');
            disc.addColorStop(0.5, '#f5d868');
            disc.addColorStop(0.85, '#eca530');
            disc.addColorStop(1, '#d4782a');
            ctx.beginPath();
            ctx.arc(cx, cy, sun.radius, 0, Math.PI * 2);
            ctx.fillStyle = disc;
            ctx.fill();
        }

        function drawClouds() {
            // Wispy sunset clouds — lit from below by golden light
            const clouds = [
                { x: 0.15, y: 0.12, w: 140, h: 12, opacity: 0.15 },
                { x: 0.22, y: 0.15, w: 100, h: 8, opacity: 0.10 },
                { x: 0.70, y: 0.10, w: 160, h: 14, opacity: 0.14 },
                { x: 0.78, y: 0.14, w: 90, h: 9, opacity: 0.09 },
                { x: 0.35, y: 0.22, w: 120, h: 10, opacity: 0.18 },
                { x: 0.60, y: 0.20, w: 110, h: 11, opacity: 0.12 },
            ];

            clouds.forEach(c => {
                const cx = W * c.x;
                const cy = H * c.y;

                // Cloud lit from below — warm orange/gold on bottom, cooler on top
                const grad = ctx.createLinearGradient(cx, cy - c.h, cx, cy + c.h);
                grad.addColorStop(0, `rgba(180, 120, 160, ${c.opacity * 0.5})`);
                grad.addColorStop(0.6, `rgba(232, 160, 80, ${c.opacity})`);
                grad.addColorStop(1, `rgba(245, 200, 100, ${c.opacity * 0.7})`);

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(cx, cy, c.w / 2, c.h / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Softer halo
                ctx.fillStyle = `rgba(245, 200, 120, ${c.opacity * 0.3})`;
                ctx.beginPath();
                ctx.ellipse(cx, cy, c.w / 2 + 10, c.h / 2 + 4, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawOcean(ocean) {
            const y = H * ocean.y;
            const h = H * ocean.height;

            // Ocean body
            const grad = ctx.createLinearGradient(0, y, 0, y + h);
            grad.addColorStop(0, ocean.shallowColor);
            grad.addColorStop(0.4, ocean.deepColor);
            grad.addColorStop(1, '#081c30');
            ctx.fillStyle = grad;
            ctx.fillRect(0, y, W, h);

            // Sun reflection path on water
            const refGrad = ctx.createRadialGradient(W * 0.5, y + 5, 0, W * 0.5, y + h * 0.5, 200);
            refGrad.addColorStop(0, 'rgba(245, 192, 64, 0.35)');
            refGrad.addColorStop(0.25, 'rgba(245, 192, 64, 0.15)');
            refGrad.addColorStop(0.6, 'rgba(245, 192, 64, 0.03)');
            refGrad.addColorStop(1, 'rgba(245, 192, 64, 0)');
            ctx.fillStyle = refGrad;
            ctx.fillRect(0, y, W, h);

            // Shimmer streaks on water
            ctx.globalAlpha = 0.1;
            ctx.strokeStyle = '#f5d868';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 6; i++) {
                const streakY = y + h * (0.2 + i * 0.12);
                const centerX = W * 0.5;
                const streakW = 40 + (3 - Math.abs(i - 3)) * 25;
                ctx.beginPath();
                ctx.moveTo(centerX - streakW / 2, streakY);
                ctx.lineTo(centerX + streakW / 2, streakY);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Subtle wave lines
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.04 + i * 0.015})`;
                ctx.beginPath();
                const waveY = y + h * (0.25 + i * 0.25);
                for (let x = 0; x < W; x += 2) {
                    const wy = waveY + Math.sin(x * 0.015 + i * 1.8) * 2;
                    if (x === 0) ctx.moveTo(x, wy);
                    else ctx.lineTo(x, wy);
                }
                ctx.stroke();
            }
        }

        function drawSand(sand) {
            const y = H * sand.y;
            const h = H - y;

            // Main sand gradient
            const grad = ctx.createLinearGradient(0, y, 0, H);
            grad.addColorStop(0, sand.color);
            grad.addColorStop(0.25, sand.wetColor);
            grad.addColorStop(1, sand.darkColor);
            ctx.fillStyle = grad;
            ctx.fillRect(0, y, W, h);

            // Wet sand strip near waterline
            const wetGrad = ctx.createLinearGradient(0, y, 0, y + 24);
            wetGrad.addColorStop(0, 'rgba(13, 40, 71, 0.25)');
            wetGrad.addColorStop(1, 'rgba(13, 40, 71, 0)');
            ctx.fillStyle = wetGrad;
            ctx.fillRect(0, y, W, 24);

            // Foam/surf line at water's edge
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < W; x += 2) {
                const fy = y + Math.sin(x * 0.03) * 2 + Math.sin(x * 0.07) * 1;
                if (x === 0) ctx.moveTo(x, fy);
                else ctx.lineTo(x, fy);
            }
            ctx.stroke();
            // Second softer foam line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let x = 0; x < W; x += 2) {
                const fy = y + 6 + Math.sin(x * 0.025 + 1) * 2.5;
                if (x === 0) ctx.moveTo(x, fy);
                else ctx.lineTo(x, fy);
            }
            ctx.stroke();

            // Sand wind ripples — subtle curved lines
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const rippleY = y + 30 + i * (h - 40) / 8;
                const alpha = 0.04 + (i % 2) * 0.02;
                ctx.strokeStyle = `rgba(255, 248, 220, ${alpha})`;
                ctx.beginPath();
                for (let x = 0; x < W; x += 3) {
                    const ry = rippleY + Math.sin(x * 0.008 + i * 0.7) * 6
                        + Math.sin(x * 0.02 + i * 1.3) * 2;
                    if (x === 0) ctx.moveTo(x, ry);
                    else ctx.lineTo(x, ry);
                }
                ctx.stroke();
            }

            // Sand texture — faint speckles
            ctx.globalAlpha = 0.05;
            ctx.fillStyle = '#fff8e0';
            for (let i = 0; i < 120; i++) {
                const sx = (i * 137.5 + 50) % W;
                const sy = y + 15 + ((i * 97.3 + 30) % (h - 20));
                ctx.fillRect(sx, sy, 1.5, 1.5);
            }
            ctx.globalAlpha = 1;

            // A few small shells scattered on the sand
            drawShell(W * 0.30, H * 0.72, 0.7);
            drawShell(W * 0.72, H * 0.88, 0.5);
            drawShell(W * 0.62, H * 0.76, 0.6);
        }

        function drawShell(x, y, scale) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            ctx.fillStyle = 'rgba(230, 210, 180, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI, true);
            ctx.closePath();
            ctx.fill();
            // Ridge lines
            ctx.strokeStyle = 'rgba(200, 180, 150, 0.2)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(-2, 0);
            ctx.lineTo(0, -3);
            ctx.lineTo(2, 0);
            ctx.stroke();
            ctx.restore();
        }

        function drawPalm(palm, groundY) {
            const baseX = W * palm.x;
            const baseY = H * (groundY || 0.53); // rooted at ground line
            const trunkH = palm.trunkHeight * palm.scale;
            const lean = palm.lean;

            const topX = baseX + lean * trunkH;
            const topY = baseY - trunkH;
            const cpX = baseX + lean * trunkH * 0.6;
            const cpY = baseY - trunkH * 0.5;

            // Trunk shadow
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 14 * palm.scale;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(baseX + 3, baseY + 3);
            ctx.quadraticCurveTo(cpX + 3, cpY + 3, topX + 3, topY + 3);
            ctx.stroke();

            // Trunk
            ctx.strokeStyle = '#1a0e08';
            ctx.lineWidth = 10 * palm.scale;
            ctx.beginPath();
            ctx.moveTo(baseX, baseY);
            ctx.quadraticCurveTo(cpX, cpY, topX, topY);
            ctx.stroke();

            // Trunk highlight edge
            ctx.strokeStyle = '#2d1a10';
            ctx.lineWidth = 6 * palm.scale;
            ctx.beginPath();
            ctx.moveTo(baseX, baseY);
            ctx.quadraticCurveTo(cpX, cpY, topX, topY);
            ctx.stroke();

            // Fronds — stem with leaflets (feather pattern)
            const frondDefs = [
                { angle: -2.8, len: 75 },
                { angle: -2.2, len: 90 },
                { angle: -1.6, len: 85 },
                { angle: -1.0, len: 95 },
                { angle: -0.4, len: 88 },
                { angle: 0.15, len: 80 },
                { angle: 0.65, len: 70 },
            ];

            frondDefs.forEach(({ angle, len }) => {
                const frondLen = len * palm.scale;
                const droop = 0.35; // how much the frond droops

                // Calculate stem curve points
                const stemPoints = [];
                const segments = 12;
                for (let t = 0; t <= segments; t++) {
                    const frac = t / segments;
                    // Stem curves outward then droops
                    const sx = topX + Math.cos(angle) * frondLen * frac;
                    const sy = topY + Math.sin(angle) * frondLen * frac * 0.5
                        + frondLen * droop * frac * frac; // quadratic droop
                    stemPoints.push({ x: sx, y: sy });
                }

                // Draw stem
                ctx.strokeStyle = '#0a1f0a';
                ctx.lineWidth = 2.5 * palm.scale;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(stemPoints[0].x, stemPoints[0].y);
                for (let i = 1; i < stemPoints.length; i++) {
                    ctx.lineTo(stemPoints[i].x, stemPoints[i].y);
                }
                ctx.stroke();

                // Draw leaflets along the stem
                for (let i = 1; i < stemPoints.length; i++) {
                    const frac = i / segments;
                    const pt = stemPoints[i];
                    const prev = stemPoints[i - 1];

                    // Direction of stem at this point
                    const dx = pt.x - prev.x;
                    const dy = pt.y - prev.y;
                    const stemAngle = Math.atan2(dy, dx);

                    // Leaflet length tapers toward tip
                    const leafletLen = (18 + (1 - frac) * 14) * palm.scale;

                    // Draw leaflet on each side
                    for (const side of [-1, 1]) {
                        const leafAngle = stemAngle + side * (0.6 + frac * 0.4);
                        const endLX = pt.x + Math.cos(leafAngle) * leafletLen;
                        const endLY = pt.y + Math.sin(leafAngle) * leafletLen + leafletLen * 0.15;

                        ctx.strokeStyle = i % 2 === 0 ? '#0a1f0a' : '#0f2a0f';
                        ctx.lineWidth = (2.0 - frac * 0.8) * palm.scale;
                        ctx.beginPath();
                        ctx.moveTo(pt.x, pt.y);
                        ctx.lineTo(endLX, endLY);
                        ctx.stroke();
                    }
                }
            });
        }

        // ========================================
        // Sprite System (oneshot-climb style)
        // ========================================

        const SPRITE_PALETTE = {
            '.': null,           // transparent
            'r': '#cc3a1e',      // red
            'R': '#9a2010',      // dark red
            'h': '#e85840',      // highlight red
            'w': '#fff8e7',      // warm white
            'b': '#5a3a22',      // brown (post)
            'B': '#3d2415',      // dark brown
            'k': '#1a0e08',      // outline/dark
            'f': '#e84c30',      // flag red
            'g': '#f5c040',      // gold/yellow
            'n': '#8b6030',      // mid brown
        };

        // 14 wide x 24 tall mailbox sprite
        const MAILBOX_SPRITE = [
            '..............',
            '..............',
            '....rrrrrrf...',
            '...rrrrrrrff..',
            '..hhrrrrrrfgf.',
            '..rrrrrrrrf.f.',
            '..rrrrrrrrf...',
            '..rrrrrrrrf...',
            '..rrrrrrrrr...',
            '..kkkkkkkkk...',
            '..RRRRRRRRR...',
            '..RRRRRRRRR...',
            '..RRRRRRRRR...',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......bBb.....',
            '......nnn.....',
            '..............',
        ];

        function drawSprite(sprite, palette, x, y, scale) {
            for (let row = 0; row < sprite.length; row++) {
                for (let col = 0; col < sprite[row].length; col++) {
                    const ch = sprite[row][col];
                    const color = palette[ch];
                    if (!color) continue; // transparent
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        x + col * scale,
                        y + row * scale,
                        scale,
                        scale
                    );
                }
            }
        }

        function drawMailboxSprite(mailbox) {
            const spriteW = MAILBOX_SPRITE[0].length;
            const spriteH = MAILBOX_SPRITE.length;
            const scale = mailbox.spriteScale;

            // Position: center horizontally at mailbox.x, bottom at mailbox.groundY
            const px = Math.round(W * mailbox.x - (spriteW * scale) / 2);
            const py = Math.round(H * mailbox.groundY - spriteH * scale);

            // Shadow on sand (still smooth — it's part of the background)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.ellipse(
                px + (spriteW * scale) / 2 + 6,
                H * mailbox.groundY + 2,
                spriteW * scale * 0.4,
                4, 0, 0, Math.PI * 2
            );
            ctx.fill();

            drawSprite(MAILBOX_SPRITE, SPRITE_PALETTE, px, py, scale);
        }

        // 11 wide x 18 tall signpost sprite
        const SIGNPOST_SPRITE = [
            '...........',
            '.nnnnnnnn..',
            '.nwwwwwwn..',
            '.nnnnnnnn..',
            '.....bb....',
            '..nnnnnnnn.',
            '..nwwwwwwn.',
            '..nnnnnnnn.',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....bb....',
            '.....nn....',
            '...........',
        ];

        function drawStars() {
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 80; i++) {
                const x = (i * 173.5 + 42) % W;
                const y = (i * 87.3 + 15) % (H * 0.45);
                const size = 0.5 + (i * 37.7 % 2);
                ctx.globalAlpha = 0.2 + (i * 47.3 % 5) / 10;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function drawForestGround(ground) {
            const y = H * ground.y;
            const h = H - y;

            // Main ground gradient
            const grad = ctx.createLinearGradient(0, y, 0, H);
            grad.addColorStop(0, ground.color);
            grad.addColorStop(0.4, ground.wetColor);
            grad.addColorStop(1, ground.darkColor);
            ctx.fillStyle = grad;
            ctx.fillRect(0, y, W, h);

            // Dirt path down the center
            const pathGrad = ctx.createLinearGradient(W * 0.35, 0, W * 0.65, 0);
            pathGrad.addColorStop(0, 'rgba(90, 60, 30, 0)');
            pathGrad.addColorStop(0.15, 'rgba(70, 45, 20, 0.3)');
            pathGrad.addColorStop(0.5, 'rgba(85, 55, 30, 0.45)');
            pathGrad.addColorStop(0.85, 'rgba(70, 45, 20, 0.3)');
            pathGrad.addColorStop(1, 'rgba(90, 60, 30, 0)');
            ctx.fillStyle = pathGrad;
            ctx.fillRect(0, y, W, h);

            // Grass tufts along edges
            for (let i = 0; i < 50; i++) {
                const gx = (i * 137.5 + 50) % W;
                const gy = y + 8 + ((i * 97.3 + 20) % (h - 12));
                if (gx > W * 0.36 && gx < W * 0.64) continue;
                ctx.globalAlpha = 0.25 + (i % 3) * 0.08;
                ctx.strokeStyle = i % 2 === 0 ? '#2a5a20' : '#1e4018';
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                ctx.moveTo(gx, gy);
                ctx.lineTo(gx - 2, gy - 5 - (i % 4));
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(gx + 2, gy);
                ctx.lineTo(gx + 4, gy - 4 - (i % 3));
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Scattered leaf debris
            ctx.globalAlpha = 0.07;
            const leafColors = ['#4a7030', '#6a5020', '#3a5a25'];
            for (let i = 0; i < 80; i++) {
                const lx = (i * 157.3 + 30) % W;
                const ly = y + 8 + ((i * 83.7 + 25) % (h - 12));
                ctx.fillStyle = leafColors[i % 3];
                ctx.fillRect(lx, ly, 2 + (i % 2), 1.5);
            }
            ctx.globalAlpha = 1;
        }

        function drawFireflies() {
            for (let i = 0; i < 20; i++) {
                const fx = (i * 197.3 + 80) % W;
                const fy = H * 0.15 + ((i * 127.7 + 40) % (H * 0.65));
                const size = 1.5 + (i % 3) * 0.5;

                // Glow
                const glow = ctx.createRadialGradient(fx, fy, 0, fx, fy, size * 8);
                glow.addColorStop(0, 'rgba(180, 230, 100, 0.25)');
                glow.addColorStop(0.4, 'rgba(180, 230, 100, 0.06)');
                glow.addColorStop(1, 'rgba(180, 230, 100, 0)');
                ctx.fillStyle = glow;
                ctx.fillRect(fx - size * 8, fy - size * 8, size * 16, size * 16);

                // Core dot
                ctx.fillStyle = 'rgba(220, 255, 150, 0.6)';
                ctx.beginPath();
                ctx.arc(fx, fy, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawSignpostSprite(signpost) {
            const spriteW = SIGNPOST_SPRITE[0].length;
            const spriteH = SIGNPOST_SPRITE.length;
            const scale = signpost.spriteScale;

            const px = Math.round(W * signpost.x - (spriteW * scale) / 2);
            const py = Math.round(H * signpost.groundY - spriteH * scale);

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(
                px + (spriteW * scale) / 2 + 4,
                H * signpost.groundY + 2,
                spriteW * scale * 0.3,
                3, 0, 0, Math.PI * 2
            );
            ctx.fill();

            drawSprite(SIGNPOST_SPRITE, SPRITE_PALETTE, px, py, scale);
        }

        // ========================================
        // Backgrounds
        // ========================================

        const BACKGROUNDS = {
            'sunset-beach': function() {
                drawSky({ colors: ['#070422', '#1a0d44', '#4a1a6b', '#8b2252', '#c44a2f', '#e8852a', '#f5c040'] });
                drawClouds();
                drawSun({ x: 0.5, y: 0.35, radius: 32, glowRadius: 130 });
                drawOcean({ y: 0.40, height: 0.13, deepColor: '#0d2847', shallowColor: '#1a4a6b' });
                drawSand({ y: 0.53, color: '#c9a34e', wetColor: '#a08030', darkColor: '#7a6020' });

                [
                    { x: 0.08, trunkHeight: 220, lean: -0.16, scale: 1.0 },
                    { x: 0.02, trunkHeight: 160, lean: -0.22, scale: 0.8 },
                    { x: 0.92, trunkHeight: 210, lean: 0.14, scale: 0.95 },
                    { x: 0.98, trunkHeight: 140, lean: 0.26, scale: 0.75 },
                ].forEach(p => drawPalm(p, 0.53));

                // Warm golden hour light wash
                const warmWash = ctx.createRadialGradient(W * 0.5, H * 0.38, 50, W * 0.5, H * 0.55, W * 0.6);
                warmWash.addColorStop(0, 'rgba(245, 200, 80, 0.08)');
                warmWash.addColorStop(0.5, 'rgba(230, 160, 60, 0.04)');
                warmWash.addColorStop(1, 'rgba(230, 160, 60, 0)');
                ctx.fillStyle = warmWash;
                ctx.fillRect(0, H * 0.5, W, H * 0.5);

                // Vignette
                const vig = ctx.createRadialGradient(W * 0.5, H * 0.4, W * 0.25, W * 0.5, H * 0.4, W * 0.65);
                vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(1, 'rgba(0, 0, 0, 0.35)');
                ctx.fillStyle = vig;
                ctx.fillRect(0, 0, W, H);
            },

            'twilight-forest': function() {
                drawSky({ colors: ['#030318', '#050528', '#0a0a38', '#121250', '#1a1a60', '#202868'], height: 0.50 });
                drawStars();
                drawForestGround({ y: 0.50, color: '#2a4a20', wetColor: '#1a3515', darkColor: '#0f200a' });

                [
                    { x: 0.04, trunkHeight: 280, lean: -0.06, scale: 1.15 },
                    { x: 0.14, trunkHeight: 240, lean: -0.10, scale: 1.0 },
                    { x: 0.86, trunkHeight: 260, lean: 0.08, scale: 1.05 },
                    { x: 0.96, trunkHeight: 230, lean: 0.12, scale: 0.95 },
                    { x: -0.02, trunkHeight: 200, lean: -0.18, scale: 0.85 },
                    { x: 1.02, trunkHeight: 210, lean: 0.16, scale: 0.9 },
                ].forEach(p => drawPalm(p, 0.50));

                drawFireflies();

                // Cool moonlit wash
                const coolWash = ctx.createRadialGradient(W * 0.5, H * 0.3, 30, W * 0.5, H * 0.5, W * 0.5);
                coolWash.addColorStop(0, 'rgba(100, 140, 200, 0.06)');
                coolWash.addColorStop(0.5, 'rgba(80, 100, 160, 0.03)');
                coolWash.addColorStop(1, 'rgba(80, 100, 160, 0)');
                ctx.fillStyle = coolWash;
                ctx.fillRect(0, 0, W, H);

                // Vignette
                const vig = ctx.createRadialGradient(W * 0.5, H * 0.4, W * 0.25, W * 0.5, H * 0.4, W * 0.65);
                vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
                vig.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
                ctx.fillStyle = vig;
                ctx.fillRect(0, 0, W, H);
            },
        };

        // ========================================
        // Scene Renderer
        // ========================================

        function renderScene(scene, isFirstScene) {
            ctx.clearRect(0, 0, W, H);

            // Draw background
            BACKGROUNDS[scene.background]();

            // Draw foreground sprites
            if (scene.mailbox) drawMailboxSprite(scene.mailbox);
            if (scene.signpost) drawSignpostSprite(scene.signpost);

            // Display narration
            const narrationEl = document.getElementById('narration');
            narrationEl.textContent = scene.narration;

            // Display choices
            const choicesEl = document.getElementById('choices');
            choicesEl.innerHTML = '';
            scene.choices.forEach((choice) => {
                const btn = document.createElement('button');
                btn.className = 'choice-btn';
                btn.textContent = choice;
                btn.addEventListener('click', () => handleChoice(choice));
                choicesEl.appendChild(btn);
            });

            // Retrigger fade-in animations for scene transitions
            if (!isFirstScene) {
                narrationEl.style.animation = 'none';
                narrationEl.offsetHeight;
                narrationEl.style.animation = 'fadeIn 0.8s ease 0.1s forwards';

                choicesEl.style.animation = 'none';
                choicesEl.offsetHeight;
                choicesEl.style.animation = 'fadeIn 0.8s ease 1.0s forwards';
            }
        }

        // ========================================
        // Scene Transition
        // ========================================

        function handleChoice(choice) {
            console.log(`Choice selected: ${choice}`);
            transitionToScene(forestScene);
        }

        function transitionToScene(newScene) {
            const overlay = document.getElementById('transition-overlay');

            // Disable choice buttons
            document.querySelectorAll('.choice-btn').forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
            });

            // Fade in overlay
            overlay.classList.add('active');

            setTimeout(() => {
                // Render new scene behind overlay
                renderScene(newScene, false);

                // Fade out overlay to reveal new scene
                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 600);
            }, 1000);
        }

        // ========================================
        // Init
        // ========================================

        renderScene(openingScene, true);
    </script>
</body>
</html>
