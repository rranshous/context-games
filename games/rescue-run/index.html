<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rescue Run</title>
    <!-- CodeMirror for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .game-panel {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #e94560;
        }
        
        h2 {
            font-size: 1rem;
            margin-bottom: 10px;
            color: #0f3460;
            background: #e94560;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        #game-canvas {
            border: 3px solid #0f3460;
            border-radius: 8px;
            background: #2d4a3e;
            image-rendering: pixelated;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
        }
        
        .control-group {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 8px;
        }
        
        .control-group h3 {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button {
            background: #0f3460;
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
            width: 100%;
            margin-bottom: 5px;
        }
        
        button:hover {
            background: #e94560;
        }
        
        button:disabled {
            background: #333;
            cursor: not-allowed;
        }
        
        .direction-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }
        
        .direction-buttons button {
            padding: 10px;
            font-size: 1.2rem;
        }
        
        .direction-buttons .empty {
            visibility: hidden;
        }
        
        #log {
            background: #0a0a15;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
            color: #8f8;
        }
        
        #log .entry {
            margin-bottom: 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid #222;
        }
        
        #log .error {
            color: #f88;
        }
        
        #log .success {
            color: #8f8;
        }
        
        #log .info {
            color: #88f;
        }
        
        .status {
            font-size: 0.9rem;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }
        
        .status.playing {
            background: #0f3460;
        }
        
        .status.won {
            background: #2e7d32;
        }
        
        .legend {
            font-size: 0.8rem;
            color: #888;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .ai-panel {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 8px;
        }
        
        .ai-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .ai-controls button {
            flex: 1;
        }
        
        #btn-run-ai {
            background: #e94560;
        }
        
        #btn-run-ai:hover {
            background: #ff6b8a;
        }
        
        #btn-run-ai:disabled {
            background: #333;
        }
        
        #btn-stop-ai {
            background: #ff9800;
        }
        
        #btn-stop-ai:hover {
            background: #ffb74d;
        }
        
        #ai-log {
            background: #0a0a15;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.75rem;
            max-height: 300px;
            overflow-y: auto;
            color: #ccc;
        }
        
        #ai-log .ai-thinking {
            color: #ff9800;
            font-style: italic;
        }
        
        #ai-log .ai-tool {
            color: #4fc3f7;
        }
        
        #ai-log .ai-result {
            color: #8f8;
            margin-left: 10px;
        }
        
        #ai-log .ai-error {
            color: #f88;
        }
        
        .ai-status {
            font-size: 0.85rem;
            padding: 6px;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 8px;
            background: #333;
        }
        
        .ai-status.running {
            background: #e94560;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Tools List */
        #tools-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .tool-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        .tool-item .tool-name {
            font-family: monospace;
            color: #4fc3f7;
        }
        
        .tool-item button {
            padding: 4px 8px;
            font-size: 0.75rem;
        }
        
        #btn-reset-tools {
            padding: 8px 12px;
            font-size: 0.85rem;
            background: #666;
        }
        
        /* Level selector */
        .level-btn {
            padding: 6px 12px;
            font-size: 0.8rem;
            background: #333;
            border: 1px solid #555;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .level-btn:hover {
            background: #444;
            color: #fff;
        }
        
        .level-btn.selected {
            background: #e94560;
            border-color: #e94560;
            color: #fff;
        }
        
        .level-btn.completed {
            border-color: #4caf50;
        }
        
        .level-btn.completed::after {
            content: ' ‚úì';
            color: #4caf50;
        }
        
        .level-btn.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: #16213e;
            border-radius: 8px;
            width: 95%;
            max-width: 900px;
            height: 90vh;
            max-height: 90vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #333;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.1rem;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
        }
        
        .close-btn:hover {
            color: #fff;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85rem;
            color: #aaa;
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            background: #0a0a15;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            font-size: 0.9rem;
            box-sizing: border-box;
        }
        
        .form-group textarea {
            resize: vertical;
            font-family: monospace;
        }
        
        .stdlib-reference {
            margin-top: 10px;
        }
        
        .stdlib-reference summary {
            cursor: pointer;
            color: #4fc3f7;
            font-size: 0.85rem;
        }
        
        .stdlib-reference pre {
            background: #0a0a15;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            overflow-x: auto;
            margin: 10px 0 0 0;
        }
        
        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .modal-footer button {
            padding: 8px 16px;
        }
        
        #btn-save-tool {
            background: #4caf50;
        }
        
        #btn-save-tool:hover {
            background: #66bb6a;
        }
        
        #btn-cancel-edit {
            background: #666;
        }
        
        /* CodeMirror editor styling */
        #edit-implementation-wrapper {
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
            flex: 1;
            min-height: 300px;
        }
        
        #edit-implementation-wrapper .CodeMirror {
            height: 100%;
            font-size: 0.85rem;
        }
        
        /* Make the implementation form-group grow */
        .form-group:has(#edit-implementation-wrapper) {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        /* Review Panel */
        .review-panel {
            margin-top: 15px;
            padding: 15px;
            background: #1a1a2e;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .review-panel h3 {
            margin: 0 0 12px 0;
            font-size: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .review-result {
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            margin-bottom: 12px;
        }
        
        .review-result.success {
            background: rgba(76, 175, 80, 0.2);
            color: #8f8;
        }
        
        .review-result.failure {
            background: rgba(233, 69, 96, 0.2);
            color: #f88;
        }
        
        .review-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .review-stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: #0a0a15;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        .review-stat-item .tool-name {
            font-family: monospace;
            color: #4fc3f7;
        }
        
        .review-stat-item .stat-counts {
            display: flex;
            gap: 10px;
            font-size: 0.8rem;
        }
        
        .review-stat-item .stat-counts .calls {
            color: #aaa;
        }
        
        .review-stat-item .stat-counts .success-count {
            color: #8f8;
        }
        
        .review-stat-item .stat-counts .fail-count {
            color: #f88;
        }
        
        .review-stat-item.never-used {
            opacity: 0.5;
        }
        
        .review-stat-item.never-used .tool-name::after {
            content: " (never used)";
            color: #888;
            font-style: italic;
        }
        
        .review-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
        }
        
        .review-actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.85rem;
        }
        
        .review-story {
            font-family: monospace;
            font-size: 0.8rem;
            color: #aaa;
            padding: 10px;
            background: #0a0a15;
            border-radius: 4px;
            margin-bottom: 10px;
            line-height: 1.6;
            word-wrap: break-word;
        }
        
        .review-story .story-fail {
            color: #f88;
        }
        
        .review-story .story-success {
            color: #8f8;
        }
        
        .review-story .story-stuck {
            background: rgba(255, 152, 0, 0.3);
            padding: 1px 3px;
            border-radius: 2px;
            border-bottom: 2px solid #ff9800;
        }
        
        .review-tool-stats {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .review-hints {
            background: rgba(255, 152, 0, 0.15);
            border: 1px solid #ff9800;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }
        
        .review-hints h4 {
            margin: 0 0 8px 0;
            color: #ff9800;
            font-size: 0.9rem;
        }
        
        .review-hints ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .review-hints li {
            margin-bottom: 4px;
            color: #ddd;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-panel">
            <h1>üöó Rescue Run</h1>
            <canvas id="game-canvas" width="256" height="256"></canvas>
            <div class="legend" style="margin-top: 10px;">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4a7c59;"></div>
                    <span>Grass</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #555;"></div>
                    <span>Road</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e94560;"></div>
                    <span>Person (rescue target)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4fc3f7;"></div>
                    <span>Safe Zone</span>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="game-panel">
                <h2>üìç Level</h2>
                <div id="level-info">
                    <div id="level-name" style="font-weight: bold; margin-bottom: 5px;">Level 1: Tutorial</div>
                    <div id="level-turns" style="font-size: 0.85rem; color: #aaa;">Turn limit: 50</div>
                </div>
                <div id="level-selector" style="margin-top: 10px; display: flex; gap: 5px; flex-wrap: wrap;">
                    <button class="level-btn selected" data-level="1">Level 1</button>
                </div>
            </div>
            
            <div class="game-panel">
                <h2>Status</h2>
                <div id="status" class="status playing">Ready</div>
                <button id="btn-reset" style="margin-top: 10px; display: none;">üîÑ Reset Game</button>
            </div>
            
            <div class="game-panel">
                <h2>ü§ñ AI Control</h2>
                <div class="ai-panel">
                    <div id="ai-status" class="ai-status">AI Ready</div>
                    <div class="ai-controls">
                        <button id="btn-run-ai">‚ñ∂Ô∏è Run AI</button>
                        <button id="btn-stop-ai" disabled>‚èπÔ∏è Stop</button>
                    </div>
                    <div id="ai-log"></div>
                    
                    <!-- Review Panel (hidden until run completes) -->
                    <div id="review-panel" class="review-panel" style="display: none;">
                        <h3>üìä Review <button id="btn-close-review" style="padding: 2px 8px; font-size: 0.75rem;">√ó</button></h3>
                        <div id="review-result" class="review-result"></div>
                        <div id="review-hints" class="review-hints" style="display: none;"></div>
                        <div id="review-stats" class="review-stats"></div>
                        <div class="review-actions">
                            <button id="btn-edit-after-review">‚úèÔ∏è Edit Tools</button>
                            <button id="btn-run-again">‚ñ∂Ô∏è Run Again</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="game-panel">
                <h2>üîß Tools</h2>
                <div id="tools-list"></div>
                <div style="margin-top: 10px;">
                    <button id="btn-reset-tools">‚Ü©Ô∏è Reset Tools</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Tool Editor Modal -->
    <div id="tool-editor-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Edit Tool: <span id="edit-tool-name"></span></h2>
                <button id="btn-close-modal" class="close-btn">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Name:</label>
                    <input type="text" id="edit-name" />
                </div>
                <div class="form-group">
                    <label>Description (AI sees this):</label>
                    <textarea id="edit-description" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label>Parameters:</label>
                    <div id="edit-parameters"></div>
                </div>
                <div class="form-group">
                    <label>Implementation (JS using stdlib.*):</label>
                    <div id="edit-implementation-wrapper"></div>
                </div>
                <div class="stdlib-reference">
                    <details>
                        <summary>üìö Stdlib Reference</summary>
                        <pre>
Position/State:
  stdlib.getCarPosition()      ‚Üí {x, y}
  stdlib.getCarDirection()     ‚Üí "north"|"south"|"east"|"west"
  stdlib.getPersonPosition()   ‚Üí {x, y} or null
  stdlib.getSafeZonePosition() ‚Üí {x, y}
  stdlib.isPersonInCar()       ‚Üí boolean

Map:
  stdlib.getGridSize()         ‚Üí {width, height}
  stdlib.isValidPosition(x,y)  ‚Üí boolean
  stdlib.getTileAt(x,y)        ‚Üí {type, passable}

Actions:
  stdlib.moveCarOneStep(dir)   ‚Üí {success, error?}
  stdlib.pickupPerson()        ‚Üí {success, error?}
  stdlib.dropoffPerson()       ‚Üí {success, error?}
                        </pre>
                    </details>
                </div>
            </div>
            <div class="modal-footer">
                <button id="btn-cancel-edit">Cancel</button>
                <button id="btn-save-tool">üíæ Save Tool</button>
            </div>
        </div>
    </div>

    <script>
        // ===========================================
        // GAME CONSTANTS
        // ===========================================
        const TILE_SIZE = 32;
        const GRID_SIZE = 8;
        const CANVAS_SIZE = TILE_SIZE * GRID_SIZE;

        // Tile types
        const TILE = {
            GRASS: 0,
            ROAD: 1,
            BUILDING: 2
        };

        // ===========================================
        // GAME STATE
        // ===========================================
        // ===========================================
        // LEVEL DEFINITIONS (ASCII FORMAT)
        // ===========================================
        // Legend:
        //   = : grass (impassable)
        //   . : road (passable)
        //   # : building (impassable)
        //   C : car start (on road)
        //   P : person (on road)
        //   S : safe zone (on road)
        
        const LEVELS = {
            1: {
                name: "Tutorial",
                turns: 50,
                map: `
========
=C.....=
=.====.=
=.=##=.=
=.=##=.=
=.....P=
=S====.=
========
`
            }
        };
        
        // ===========================================
        // LEVEL PARSER
        // ===========================================
        
        function parseLevel(levelData) {
            const lines = levelData.map.trim().split('\n');
            const height = lines.length;
            const width = lines[0].length;
            
            const map = [];
            let car = null;
            let person = null;
            let safeZone = null;
            
            for (let y = 0; y < height; y++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const char = lines[y][x] || '=';
                    
                    switch (char) {
                        case '=': // grass
                            row.push(0);
                            break;
                        case '.': // road
                            row.push(1);
                            break;
                        case '#': // building
                            row.push(2);
                            break;
                        case 'C': // car (on road)
                            row.push(1);
                            car = { x, y, direction: 'east' };
                            break;
                        case 'P': // person (on road)
                            row.push(1);
                            person = { x, y, rescued: false };
                            break;
                        case 'S': // safe zone (on road)
                            row.push(1);
                            safeZone = { x, y };
                            break;
                        default:
                            row.push(0); // unknown = grass
                    }
                }
                map.push(row);
            }
            
            return {
                name: levelData.name,
                turns: levelData.turns,
                map,
                car,
                person,
                safeZone,
                width,
                height
            };
        }
        
        // Current level (default to 1)
        let currentLevelNum = 1;
        let currentLevel = parseLevel(LEVELS[1]);
        
        // Track completed levels
        let completedLevels = new Set();
        
        function loadCompletedLevels() {
            try {
                const saved = localStorage.getItem('rescue-run-completed');
                if (saved) {
                    completedLevels = new Set(JSON.parse(saved));
                }
            } catch (e) {
                console.error('Failed to load completed levels:', e);
            }
        }
        
        function saveCompletedLevels() {
            localStorage.setItem('rescue-run-completed', JSON.stringify([...completedLevels]));
        }
        
        function markLevelCompleted(levelNum) {
            completedLevels.add(levelNum);
            saveCompletedLevels();
            updateLevelButtons();
        }
        
        function updateLevelButtons() {
            document.querySelectorAll('.level-btn').forEach(btn => {
                const levelNum = parseInt(btn.dataset.level);
                if (completedLevels.has(levelNum)) {
                    btn.classList.add('completed');
                }
            });
        }
        
        // ===========================================
        // GAME STATE
        // ===========================================
        
        const gameState = {
            // Car state
            car: { ...currentLevel.car },
            
            // Person to rescue
            person: { ...currentLevel.person },
            
            // Safe zone location
            safeZone: { ...currentLevel.safeZone },
            
            // Is person in car?
            personInCar: false,
            
            // Game status
            status: 'playing', // 'playing', 'won'
            
            // The map grid
            map: currentLevel.map
        };

        // ===========================================
        // ASSETS
        // ===========================================
        const assets = {
            carSprite: null,
            loaded: false
        };

        function loadAssets() {
            return new Promise((resolve, reject) => {
                const carImg = new Image();
                carImg.onload = () => {
                    assets.carSprite = carImg;
                    assets.loaded = true;
                    resolve();
                };
                carImg.onerror = () => {
                    assets.loaded = true;
                    resolve(); // Continue anyway with fallback rendering
                };
                carImg.src = 'assets/Cars/Player_blue%20(16%20x%2016).png';
            });
        }

        // ===========================================
        // RENDERING
        // ===========================================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        function render() {
            // Clear
            ctx.fillStyle = '#2d4a3e';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Draw tiles
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const tile = gameState.map[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;
                    
                    switch (tile) {
                        case TILE.GRASS:
                            ctx.fillStyle = '#4a7c59';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Add some texture
                            ctx.fillStyle = '#3d6b4a';
                            ctx.fillRect(px + 4, py + 4, 2, 2);
                            ctx.fillRect(px + 20, py + 12, 2, 2);
                            ctx.fillRect(px + 10, py + 24, 2, 2);
                            break;
                        case TILE.ROAD:
                            ctx.fillStyle = '#555';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Road markings
                            ctx.fillStyle = '#777';
                            ctx.fillRect(px, py, TILE_SIZE, 1);
                            ctx.fillRect(px, py + TILE_SIZE - 1, TILE_SIZE, 1);
                            break;
                        case TILE.BUILDING:
                            ctx.fillStyle = '#8b7355';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Building detail
                            ctx.fillStyle = '#6b5344';
                            ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#ffeb3b';
                            ctx.fillRect(px + 8, py + 8, 6, 6);
                            break;
                    }
                }
            }
            
            // Draw safe zone
            const sz = gameState.safeZone;
            ctx.fillStyle = 'rgba(79, 195, 247, 0.5)';
            ctx.fillRect(sz.x * TILE_SIZE, sz.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.strokeRect(sz.x * TILE_SIZE + 2, sz.y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
            // Safe zone icon
            ctx.fillStyle = '#4fc3f7';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üè†', sz.x * TILE_SIZE + TILE_SIZE/2, sz.y * TILE_SIZE + TILE_SIZE/2 + 5);
            
            // Draw person (if not rescued/in car)
            if (!gameState.personInCar && !gameState.person.rescued) {
                const p = gameState.person;
                ctx.fillStyle = '#e94560';
                ctx.beginPath();
                ctx.arc(p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2, 8, 0, Math.PI * 2);
                ctx.fill();
                // Person icon
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üßç', p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2 + 4);
            }
            
            // Draw car
            const car = gameState.car;
            const carX = car.x * TILE_SIZE + TILE_SIZE/2;
            const carY = car.y * TILE_SIZE + TILE_SIZE/2;
            
            ctx.save();
            ctx.translate(carX, carY);
            
            // Rotate based on direction (sprite faces north/up by default)
            const angles = { north: 0, east: Math.PI/2, south: Math.PI, west: -Math.PI/2 };
            ctx.rotate(angles[car.direction] || 0);
            
            if (assets.carSprite) {
                // Draw sprite (first frame, 16x16, scaled to ~24px)
                const scale = 1.5;
                const spriteSize = 16;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(
                    assets.carSprite,
                    0, 0, spriteSize, spriteSize,  // Source
                    -spriteSize * scale / 2, -spriteSize * scale / 2, spriteSize * scale, spriteSize * scale  // Dest
                );
            } else {
                // Fallback: draw a simple car shape
                ctx.fillStyle = '#2196f3';
                ctx.fillRect(-10, -6, 20, 12);
                ctx.fillStyle = '#1565c0';
                ctx.fillRect(6, -4, 4, 8);
            }
            
            ctx.restore();
            
            // If person is in car, show indicator
            if (gameState.personInCar) {
                ctx.fillStyle = '#e94560';
                ctx.font = '12px Arial';
                ctx.fillText('üßç', carX + 12, carY - 12);
            }
        }

        // ===========================================
        // ===========================================
        // STANDARD LIBRARY (stdlib)
        // Low-level game primitives for tool implementations
        // ===========================================
        /*
         * STDLIB API REFERENCE (for tool implementations)
         * 
         * Position/State:
         *   stdlib.getCarPosition()      ‚Üí {x, y}
         *   stdlib.getCarDirection()     ‚Üí "north"|"south"|"east"|"west"
         *   stdlib.getPersonPosition()   ‚Üí {x, y} or null if rescued
         *   stdlib.getSafeZonePosition() ‚Üí {x, y}
         *   stdlib.isPersonInCar()       ‚Üí boolean
         *   stdlib.isPersonRescued()     ‚Üí boolean
         * 
         * Map:
         *   stdlib.getGridSize()         ‚Üí {width, height}
         *   stdlib.isValidPosition(x,y)  ‚Üí boolean
         *   stdlib.getTileAt(x,y)        ‚Üí {type, passable}
         *                                  type: "grass"|"road"|"building"|"edge"
         * 
         * Actions:
         *   stdlib.moveCarOneStep(dir)   ‚Üí {success, error?}
         *   stdlib.pickupPerson()        ‚Üí {success, error?}
         *   stdlib.dropoffPerson()       ‚Üí {success, error?}
         */
        const stdlib = {
            // === Position/State ===
            getCarPosition: () => ({ x: gameState.car.x, y: gameState.car.y }),
            getCarDirection: () => gameState.car.direction,
            getPersonPosition: () => gameState.person.rescued ? null : { x: gameState.person.x, y: gameState.person.y },
            getSafeZonePosition: () => ({ x: gameState.safeZone.x, y: gameState.safeZone.y }),
            isPersonInCar: () => gameState.personInCar,
            isPersonRescued: () => gameState.person.rescued,
            
            // === Map ===
            getGridSize: () => ({ width: GRID_SIZE, height: GRID_SIZE }),
            isValidPosition: (x, y) => x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE,
            getTileAt: (x, y) => {
                if (!stdlib.isValidPosition(x, y)) {
                    return { type: 'edge', passable: false };
                }
                const tile = gameState.map[y][x];
                const typeNames = { [TILE.GRASS]: 'grass', [TILE.ROAD]: 'road', [TILE.BUILDING]: 'building' };
                return {
                    type: typeNames[tile] || 'unknown',
                    passable: tile === TILE.ROAD
                };
            },
            
            // === Actions ===
            moveCarOneStep: (direction) => {
                const moves = {
                    north: { dx: 0, dy: -1 },
                    south: { dx: 0, dy: 1 },
                    east: { dx: 1, dy: 0 },
                    west: { dx: -1, dy: 0 }
                };
                
                if (!moves[direction]) {
                    return { success: false, error: `Invalid direction: ${direction}` };
                }
                
                const move = moves[direction];
                const newX = gameState.car.x + move.dx;
                const newY = gameState.car.y + move.dy;
                
                // Always update facing direction
                gameState.car.direction = direction;
                
                if (!stdlib.isValidPosition(newX, newY)) {
                    return { success: false, error: 'Would go off the map' };
                }
                
                const tile = stdlib.getTileAt(newX, newY);
                if (!tile.passable) {
                    return { success: false, error: `${tile.type} is not passable` };
                }
                
                // Move the car
                gameState.car.x = newX;
                gameState.car.y = newY;
                return { success: true };
            },
            
            pickupPerson: () => {
                if (gameState.personInCar) {
                    return { success: false, error: 'Person already in car' };
                }
                if (gameState.person.rescued) {
                    return { success: false, error: 'Person already rescued' };
                }
                const car = gameState.car;
                const person = gameState.person;
                if (car.x !== person.x || car.y !== person.y) {
                    return { success: false, error: 'No person at current location' };
                }
                gameState.personInCar = true;
                return { success: true };
            },
            
            dropoffPerson: () => {
                if (!gameState.personInCar) {
                    return { success: false, error: 'No person in car' };
                }
                const car = gameState.car;
                const sz = gameState.safeZone;
                if (car.x !== sz.x || car.y !== sz.y) {
                    return { success: false, error: 'Not at safe zone' };
                }
                gameState.personInCar = false;
                gameState.person.rescued = true;
                gameState.status = 'won';
                checkWinCondition();
                return { success: true };
            }
        };

        // ===========================================
        // WIN DETECTION & RESET
        // ===========================================
        
        function checkWinCondition() {
            if (gameState.person.rescued) {
                gameState.status = 'won';
                const statusEl = document.getElementById('status');
                statusEl.textContent = 'üéâ RESCUE COMPLETE!';
                statusEl.className = 'status won';
                
                // Show reset button
                document.getElementById('btn-reset').style.display = 'block';
            }
        }
        
        function loadLevel(levelNum) {
            if (!LEVELS[levelNum]) {
                console.error(`Level ${levelNum} not found`);
                return false;
            }
            
            currentLevelNum = levelNum;
            currentLevel = parseLevel(LEVELS[levelNum]);
            
            // Update game state with level data
            gameState.car = { ...currentLevel.car };
            gameState.person = { ...currentLevel.person };
            gameState.safeZone = { ...currentLevel.safeZone };
            gameState.map = currentLevel.map;
            gameState.personInCar = false;
            gameState.status = 'playing';
            
            // Update level info display
            updateLevelDisplay();
            
            return true;
        }
        
        function updateLevelDisplay() {
            document.getElementById('level-name').textContent = 
                `Level ${currentLevelNum}: ${currentLevel.name}`;
            document.getElementById('level-turns').textContent = 
                `Turn limit: ${currentLevel.turns}`;
            
            // Update button selection
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (parseInt(btn.dataset.level) === currentLevelNum) {
                    btn.classList.add('selected');
                }
            });
        }
        
        function setupLevelSelector() {
            const selector = document.getElementById('level-selector');
            
            // Add click handlers to level buttons
            selector.addEventListener('click', (e) => {
                const btn = e.target.closest('.level-btn');
                if (!btn || btn.classList.contains('locked')) return;
                
                const levelNum = parseInt(btn.dataset.level);
                if (levelNum !== currentLevelNum) {
                    selectLevel(levelNum);
                }
            });
            
            // Initialize display
            updateLevelDisplay();
        }
        
        function selectLevel(levelNum) {
            if (!LEVELS[levelNum]) return;
            
            // Load the level
            loadLevel(levelNum);
            
            // Reset game UI
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'Ready';
            statusEl.className = 'status playing';
            document.getElementById('btn-reset').style.display = 'none';
            
            // Clear AI log
            clearAiLog();
            aiLog(`Level ${levelNum}: ${currentLevel.name} loaded. Turn limit: ${currentLevel.turns}`, 'ai-result');
            
            // Hide review panel
            hideReview();
            
            render();
        }
        
        function resetGame() {
            // Reload current level
            loadLevel(currentLevelNum);
            
            // Reset UI
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'Ready';
            statusEl.className = 'status playing';
            document.getElementById('btn-reset').style.display = 'none';
            
            // Clear AI log
            clearAiLog();
            aiLog('Game reset. Ready to run AI.', 'ai-result');
            
            render();
        }

        // ===========================================
        // AI INTEGRATION (Claude Haiku)
        // ===========================================
        
        // Tool definitions with implementations
        // Players can edit these - implementation is JS using stdlib.*
        const DEFAULT_TOOLS = [
            {
                name: "scan",
                description: "Check your current status. Returns your position, whether you have a person in the car, and whether you're at the person or safe zone.",
                parameters: [],
                implementation: `
// ========================================
// SCAN TOOL - Check current status
// ========================================
// This is a BASIC scan - it tells you:
// - Where you are (current_position)
// - Whether you have a person in the car
// - Whether person or safe zone is at your location
//
// TIP: To navigate better, you might want to 
// improve this tool to show what's AROUND you!

const pos = stdlib.getCarPosition();

const result = {
    current_position: pos,
    person_in_car: stdlib.isPersonInCar()
};

// Check if person is at current location
const personPos = stdlib.getPersonPosition();
if (personPos && personPos.x === pos.x && personPos.y === pos.y) {
    result.person_here = true;
}

// Check if safe zone is at current location
const szPos = stdlib.getSafeZonePosition();
if (szPos.x === pos.x && szPos.y === pos.y) {
    result.at_safe_zone = true;
}

return result;
`
            },
            {
                name: "move",
                description: "Move the car one tile in the specified direction. The car can only move on road tiles. Returns success status and your new position.",
                parameters: [
                    {
                        name: "direction",
                        type: "string",
                        enum: ["north", "south", "east", "west"],
                        description: "The direction to move: north (up), south (down), east (right), or west (left)",
                        required: true
                    }
                ],
                implementation: `
// ========================================
// MOVE TOOL - Move the car one tile
// ========================================
// input.direction contains the direction the AI wants to move
// (north, south, east, or west)

// Try to move - returns {success: true} or {success: false, error: "..."}
const result = stdlib.moveCarOneStep(input.direction);

// TIP: You could improve this tool to tell you
// what's at your new location after moving!

return result;
`
            },
            {
                name: "pickup",
                description: "Pick up a person if they are at your current location. You must be on the same tile as the person to pick them up.",
                parameters: [],
                implementation: `
// ========================================
// PICKUP TOOL - Pick up the person
// ========================================
// The car must be on the same tile as the person

// Try to pick up - returns {success: true} or {success: false, error: "..."}
const result = stdlib.pickupPerson();

// Add a friendly message on success
if (result.success) {
    result.message = 'Person picked up! Now take them to the safe zone.';
}

return result;
`
            },
            {
                name: "dropoff",
                description: "Drop off the person you're carrying. You must be at the safe zone and have a person in the car to drop them off. This completes the rescue!",
                parameters: [],
                implementation: `
// ========================================
// DROPOFF TOOL - Drop off at safe zone
// ========================================
// Must have person in car AND be at safe zone

// Try to drop off - returns {success: true} or {success: false, error: "..."}
const result = stdlib.dropoffPerson();

// Add a celebration message on success!
if (result.success) {
    result.message = 'Person dropped off at safe zone! RESCUE COMPLETE!';
}

return result;
`
            }
        ];
        
        // Current tools (can be modified by player)
        let currentTools = JSON.parse(JSON.stringify(DEFAULT_TOOLS));
        
        // Convert tool definitions to Claude API format
        function getClaudeTools() {
            return currentTools.map(tool => ({
                name: tool.name,
                description: tool.description,
                input_schema: {
                    type: "object",
                    properties: tool.parameters.reduce((props, param) => {
                        props[param.name] = {
                            type: param.type,
                            description: param.description
                        };
                        if (param.enum) {
                            props[param.name].enum = param.enum;
                        }
                        return props;
                    }, {}),
                    required: tool.parameters.filter(p => p.required).map(p => p.name)
                }
            }));
        }
        
        // Execute a tool by running its implementation
        function executeTool(toolName, toolInput) {
            const tool = currentTools.find(t => t.name === toolName);
            if (!tool) {
                return { success: false, error: `Unknown tool: ${toolName}` };
            }
            
            try {
                // Create a function from the implementation string
                // It has access to 'stdlib' and 'input'
                const fn = new Function('stdlib', 'input', tool.implementation);
                const result = fn(stdlib, toolInput || {});
                
                // If result is undefined, the tool forgot to return
                if (result === undefined) {
                    return { 
                        success: false, 
                        error: `Tool "${toolName}" didn't return anything. Add a return statement.` 
                    };
                }
                
                return result;
            } catch (e) {
                // Parse error messages to be more helpful
                const errorMsg = e.message;
                let friendlyError = errorMsg;
                
                // Common JS errors
                if (errorMsg.includes('is not defined')) {
                    const match = errorMsg.match(/(\w+) is not defined/);
                    const varName = match ? match[1] : 'variable';
                    friendlyError = `"${varName}" is not defined. Did you mean stdlib.${varName}() or misspell something?`;
                } else if (errorMsg.includes('is not a function')) {
                    const match = errorMsg.match(/(\w+) is not a function/);
                    const fnName = match ? match[1] : 'something';
                    friendlyError = `"${fnName}" is not a function. Check the stdlib reference for available functions.`;
                } else if (errorMsg.includes('Unexpected token')) {
                    friendlyError = `Syntax error: ${errorMsg}. Check for missing brackets, quotes, or semicolons.`;
                } else if (errorMsg.includes('Cannot read properties of undefined')) {
                    friendlyError = `Tried to access a property on undefined. A stdlib function might have returned null/undefined.`;
                }
                
                return { success: false, error: friendlyError };
            }
        }
        
        // AI state
        const aiState = {
            running: false,
            messages: [],
            stopRequested: false,
            // Review tracking
            toolStats: {},      // { toolName: { calls: 0, successes: 0, failures: 0 } }
            toolHistory: [],    // [{ name: 'scan', args: {}, success: true }, ...]
            totalTurns: 0,
            result: null        // 'success' | 'failure' | 'stopped' | 'error'
        };
        
        function resetToolStats() {
            aiState.toolStats = {};
            aiState.toolHistory = [];
            aiState.totalTurns = 0;
            aiState.result = null;
            // Initialize stats for all tools
            currentTools.forEach(tool => {
                aiState.toolStats[tool.name] = { calls: 0, successes: 0, failures: 0 };
            });
        }
        
        function trackToolCall(toolName, toolInput, result) {
            if (!aiState.toolStats[toolName]) {
                aiState.toolStats[toolName] = { calls: 0, successes: 0, failures: 0 };
            }
            aiState.toolStats[toolName].calls++;
            const success = result.success !== false;
            if (success) {
                aiState.toolStats[toolName].successes++;
            } else {
                aiState.toolStats[toolName].failures++;
            }
            // Record in history
            aiState.toolHistory.push({ name: toolName, args: toolInput, success });
        }
        
        // AI logging
        const aiLogEl = document.getElementById('ai-log');
        
        function aiLog(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = type;
            entry.textContent = message;
            aiLogEl.appendChild(entry);
            aiLogEl.scrollTop = aiLogEl.scrollHeight;
        }
        
        function clearAiLog() {
            aiLogEl.innerHTML = '';
        }
        
        // Build minimal system prompt - AI must discover through tools
        function buildSystemPrompt() {
            return `You are controlling a rescue vehicle. Your goal is to rescue the person and bring them to the safe zone.

Use your available tools to:
1. Explore and understand your environment
2. Find and pick up the person
3. Navigate to the safe zone
4. Drop off the person to complete the rescue

Good luck!`;
        }
        
        // Call Claude API via vanilla platform proxy
        async function callClaude(messages) {
            const response = await fetch('/api/inference/anthropic/messages', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    model: 'claude-haiku-4-5-20251001',
                    max_tokens: 1024,
                    system: buildSystemPrompt(),
                    tools: getClaudeTools(),
                    messages: messages
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                const errorMsg = error.error || 'API call failed';
                
                // Handle specific error types
                if (response.status === 401) {
                    throw new Error('AUTH_REQUIRED');
                } else if (errorMsg.toLowerCase().includes('token') || errorMsg.toLowerCase().includes('limit')) {
                    throw new Error('TOKEN_LIMIT');
                }
                throw new Error(errorMsg);
            }
            
            return await response.json();
        }
        
        // Main agentic loop
        async function runAI() {
            if (aiState.running) return;
            
            // Check auth before starting
            if (!currentUser) {
                aiLog('‚ùå Please login first', 'ai-error');
                return;
            }
            
            aiState.running = true;
            aiState.stopRequested = false;
            aiState.messages = [];
            
            // Reset tracking for review
            resetToolStats();
            hideReview();
            
            clearAiLog();
            updateAiStatus('Running...', true);
            
            document.getElementById('btn-run-ai').disabled = true;
            document.getElementById('btn-stop-ai').disabled = false;
            
            // Disable manual controls while AI runs
            document.querySelectorAll('.control-group button').forEach(btn => {
                btn.disabled = true;
            });
            
            aiLog('ü§ñ AI starting rescue mission...', 'ai-thinking');
            
            // Start with a user message asking to complete the rescue
            aiState.messages.push({
                role: 'user',
                content: 'Please rescue the person and bring them to the safe zone. Use the tools available to you. Start by scanning your surroundings to understand the situation.'
            });
            
            let iterations = 0;
            const maxIterations = currentLevel.turns || 50; // Use level turn limit
            
            try {
                while (aiState.running && !aiState.stopRequested && iterations < maxIterations) {
                    iterations++;
                    
                    if (gameState.status === 'won') {
                        aiLog('üéâ RESCUE COMPLETE! Mission successful!', 'ai-result');
                        markLevelCompleted(currentLevelNum);
                        break;
                    }
                    
                    // Call Claude
                    aiLog(`[Turn ${iterations}] Thinking...`, 'ai-thinking');
                    const response = await callClaude(aiState.messages);
                    
                    // Process response
                    const assistantContent = response.content;
                    aiState.messages.push({ role: 'assistant', content: assistantContent });
                    
                    // Check if Claude wants to use tools
                    const toolUses = assistantContent.filter(block => block.type === 'tool_use');
                    const textBlocks = assistantContent.filter(block => block.type === 'text');
                    
                    // Log any text Claude says
                    for (const text of textBlocks) {
                        if (text.text.trim()) {
                            aiLog(`üí≠ ${text.text}`, 'ai-thinking');
                        }
                    }
                    
                    if (toolUses.length === 0) {
                        // No tool use, check if we're done
                        if (response.stop_reason === 'end_turn') {
                            aiLog('AI finished without completing rescue', 'ai-error');
                            break;
                        }
                    }
                    
                    // Execute each tool and collect results
                    const toolResults = [];
                    for (const toolUse of toolUses) {
                        aiLog(`üîß ${toolUse.name}(${JSON.stringify(toolUse.input)})`, 'ai-tool');
                        
                        const result = executeTool(toolUse.name, toolUse.input);
                        
                        // Track for review
                        trackToolCall(toolUse.name, toolUse.input, result);
                        
                        // Log result
                        if (result.success === false) {
                            aiLog(`   ‚ùå ${result.error}`, 'ai-error');
                        } else if (result.success === true) {
                            aiLog(`   ‚úÖ ${result.message || 'OK'}`, 'ai-result');
                        } else {
                            // Scan result - summarize it
                            aiLog(`   üìç Pos: (${result.current_position.x},${result.current_position.y})`, 'ai-result');
                        }
                        
                        toolResults.push({
                            type: 'tool_result',
                            tool_use_id: toolUse.id,
                            content: JSON.stringify(result)
                        });
                        
                        // Update display
                        render();
                        
                        // Small delay for visual feedback
                        await new Promise(r => setTimeout(r, 300));
                    }
                    
                    // Add tool results to messages
                    if (toolResults.length > 0) {
                        aiState.messages.push({ role: 'user', content: toolResults });
                    }
                    
                    // Small delay between turns
                    await new Promise(r => setTimeout(r, 200));
                }
                
                if (iterations >= maxIterations) {
                    aiLog('‚ö†Ô∏è Max iterations reached', 'ai-error');
                    aiState.result = 'failure';
                }
                
                // Set result based on game state
                if (gameState.status === 'won') {
                    aiState.result = 'success';
                } else if (aiState.stopRequested) {
                    aiState.result = 'stopped';
                } else if (!aiState.result) {
                    aiState.result = 'failure';
                }
                
                aiState.totalTurns = iterations;
                
            } catch (error) {
                aiState.result = 'error';
                aiState.totalTurns = iterations;
                
                // Handle specific error types with user-friendly messages
                if (error.message === 'AUTH_REQUIRED') {
                    aiLog('‚ùå Session expired. Please login again.', 'ai-error');
                    currentUser = null;
                    showLoginPrompt();
                } else if (error.message === 'TOKEN_LIMIT') {
                    aiLog('‚ùå Token limit reached! Contact admin for more tokens.', 'ai-error');
                } else {
                    aiLog(`‚ùå Error: ${error.message}`, 'ai-error');
                }
                console.error('AI error:', error);
            }
            
            // Cleanup
            aiState.running = false;
            updateAiStatus('AI Ready', false);
            document.getElementById('btn-run-ai').disabled = currentUser ? false : true;
            document.getElementById('btn-stop-ai').disabled = true;
            
            // Show review panel
            showReview();
        }
        
        function stopAI() {
            aiState.stopRequested = true;
            aiLog('‚èπÔ∏è Stop requested...', 'ai-thinking');
        }
        
        // ===========================================
        // REVIEW PANEL
        // ===========================================
        
        function generateHints(state) {
            const hints = [];
            const stats = state.toolStats;
            const history = state.toolHistory;
            
            // Check if failed
            if (state.result !== 'success') {
                // Never used pickup
                if (stats.pickup?.calls === 0) {
                    hints.push("The AI never tried to pick up the person. Does your <code>scan</code> tool tell the AI where the person is?");
                }
                
                // Never used dropoff but has person
                if (stats.dropoff?.calls === 0 && stats.pickup?.calls > 0) {
                    hints.push("The AI picked up the person but never found the safe zone. Does <code>scan</code> reveal safe zone locations?");
                }
                
                // Lots of move failures
                const moveFailures = stats.move?.failures || 0;
                if (moveFailures > 5) {
                    hints.push(`The AI hit walls ${moveFailures} times. Does <code>scan</code> tell it which directions are passable?`);
                }
                
                // Scan not used or barely used
                if ((stats.scan?.calls || 0) < 3) {
                    hints.push("The AI barely scanned its surroundings. Is the <code>scan</code> tool description clear about what it does?");
                }
            }
            
            // Even on success, check for inefficiency
            if (state.result === 'success' && state.totalTurns > 40) {
                hints.push("Success! But the AI took many turns. Could your tools provide better information to help it navigate more directly?");
            }
            
            // Check for looping patterns
            const loopPattern = detectLoopPattern(history);
            if (loopPattern) {
                hints.push(`The AI seemed to loop (${loopPattern}). It might not have enough info to make good decisions.`);
            }
            
            return hints;
        }
        
        function detectLoopPattern(history) {
            if (!history || history.length < 8) return null;
            
            // Look for repeating direction patterns (e.g., north-south-north-south)
            const moves = history.filter(h => h.name === 'move').map(h => h.args?.direction);
            if (moves.length < 6) return null;
            
            // Check last 6 moves for back-and-forth
            const last6 = moves.slice(-6);
            const backForth = last6.filter((m, i) => {
                if (i === 0) return false;
                const prev = last6[i - 1];
                return (m === 'north' && prev === 'south') ||
                       (m === 'south' && prev === 'north') ||
                       (m === 'east' && prev === 'west') ||
                       (m === 'west' && prev === 'east');
            }).length;
            
            if (backForth >= 3) {
                return 'back-and-forth movement';
            }
            
            return null;
        }
        
        function showReview() {
            const panel = document.getElementById('review-panel');
            const resultEl = document.getElementById('review-result');
            const statsEl = document.getElementById('review-stats');
            
            // Result summary
            const resultMessages = {
                success: `‚úÖ SUCCESS! Rescued in ${aiState.totalTurns} turns`,
                failure: `‚ùå FAILED after ${aiState.totalTurns} turns`,
                stopped: `‚èπÔ∏è STOPPED at turn ${aiState.totalTurns}`,
                error: `‚ö†Ô∏è ERROR at turn ${aiState.totalTurns}`
            };
            
            resultEl.textContent = resultMessages[aiState.result] || 'Unknown result';
            resultEl.className = `review-result ${aiState.result === 'success' ? 'success' : 'failure'}`;
            
            // Generate hints based on what happened
            const hints = generateHints(aiState);
            const hintsEl = document.getElementById('review-hints');
            if (hints.length > 0) {
                hintsEl.innerHTML = `<h4>üí° Suggestions</h4><ul>${hints.map(h => `<li>${h}</li>`).join('')}</ul>`;
                hintsEl.style.display = 'block';
            } else {
                hintsEl.style.display = 'none';
            }
            
            // Build the story - compress consecutive same calls
            const story = buildToolStory(aiState.toolHistory);
            
            // Tool stats
            const toolNames = currentTools.map(t => t.name);
            let statsHtml = '';
            
            // Story section
            statsHtml += `<div class="review-story">${story}</div>`;
            
            // Stats per tool
            statsHtml += '<div class="review-tool-stats">';
            for (const toolName of toolNames) {
                const stats = aiState.toolStats[toolName] || { calls: 0, successes: 0, failures: 0 };
                const neverUsed = stats.calls === 0;
                
                statsHtml += `
                    <div class="review-stat-item ${neverUsed ? 'never-used' : ''}">
                        <span class="tool-name">${toolName}()</span>
                        <span class="stat-counts">
                            ${neverUsed ? '' : `
                                ${stats.failures > 0 ? `<span class="fail-count">‚úó${stats.failures}</span>` : ''}
                                ${stats.successes > 0 ? `<span class="success-count">‚úì${stats.successes}</span>` : ''}
                            `}
                        </span>
                    </div>
                `;
            }
            statsHtml += '</div>';
            
            statsEl.innerHTML = statsHtml;
            panel.style.display = 'block';
        }
        
        function buildToolStory(history) {
            if (!history || history.length === 0) return '<em>No tool calls</em>';
            
            const parts = [];
            let i = 0;
            
            while (i < history.length) {
                const call = history[i];
                let count = 1;
                
                // For move, group by same direction
                if (call.name === 'move') {
                    const dir = call.args?.direction;
                    while (i + count < history.length && 
                           history[i + count].name === 'move' && 
                           history[i + count].args?.direction === dir) {
                        count++;
                    }
                    const failCount = history.slice(i, i + count).filter(c => !c.success).length;
                    let text = `move(${dir})`;
                    if (count > 1) text += `√ó${count}`;
                    if (failCount > 0) text = `<span class="story-fail">${text}</span>`;
                    parts.push({ text, startIdx: i, endIdx: i + count - 1 });
                }
                // For scan, just count consecutive scans
                else if (call.name === 'scan') {
                    while (i + count < history.length && history[i + count].name === 'scan') {
                        count++;
                    }
                    let text = 'scan';
                    if (count > 1) text += `√ó${count}`;
                    parts.push({ text, startIdx: i, endIdx: i + count - 1 });
                }
                // For pickup/dropoff, show success/fail
                else {
                    let text = call.name;
                    if (!call.success) text = `<span class="story-fail">${text}!</span>`;
                    else text = `<span class="story-success">${text}‚úì</span>`;
                    parts.push({ text, startIdx: i, endIdx: i });
                }
                
                i += count;
            }
            
            // Detect stuck patterns: back-and-forth moves
            const stuckIndices = new Set();
            for (let p = 1; p < parts.length; p++) {
                const curr = parts[p].text;
                const prev = parts[p - 1].text;
                // Check for opposite directions
                if ((curr.includes('north') && prev.includes('south')) ||
                    (curr.includes('south') && prev.includes('north')) ||
                    (curr.includes('east') && prev.includes('west')) ||
                    (curr.includes('west') && prev.includes('east'))) {
                    stuckIndices.add(p - 1);
                    stuckIndices.add(p);
                }
            }
            
            // Also mark consecutive failures as stuck
            for (let p = 0; p < parts.length; p++) {
                if (parts[p].text.includes('story-fail')) {
                    // Check if next is also a failure
                    if (p + 1 < parts.length && parts[p + 1].text.includes('story-fail')) {
                        stuckIndices.add(p);
                        stuckIndices.add(p + 1);
                    }
                }
            }
            
            // Build final story with stuck highlights
            return parts.map((p, idx) => {
                if (stuckIndices.has(idx)) {
                    return `<span class="story-stuck">${p.text}</span>`;
                }
                return p.text;
            }).join(' ‚Üí ');
        }
        
        function hideReview() {
            document.getElementById('review-panel').style.display = 'none';
        }
        
        function updateAiStatus(text, running) {
            const statusEl = document.getElementById('ai-status');
            statusEl.textContent = text;
            statusEl.className = running ? 'ai-status running' : 'ai-status';
        }

        // ===========================================
        // TOOL EDITOR
        // ===========================================
        
        let editingToolIndex = -1;
        let codeEditor = null; // CodeMirror instance
        
        function renderToolsList() {
            const listEl = document.getElementById('tools-list');
            listEl.innerHTML = currentTools.map((tool, i) => `
                <div class="tool-item">
                    <span class="tool-name">${tool.name}(${tool.parameters.map(p => p.name).join(', ')})</span>
                    <button onclick="openToolEditor(${i})">Edit</button>
                </div>
            `).join('');
        }
        
        function initCodeEditor() {
            const wrapper = document.getElementById('edit-implementation-wrapper');
            wrapper.innerHTML = '';
            codeEditor = CodeMirror(wrapper, {
                mode: 'javascript',
                theme: 'dracula',
                lineNumbers: true,
                lineWrapping: true,
                tabSize: 2,
                indentWithTabs: false
            });
        }
        
        function openToolEditor(index) {
            editingToolIndex = index;
            const tool = currentTools[index];
            
            document.getElementById('edit-tool-name').textContent = tool.name;
            document.getElementById('edit-name').value = tool.name;
            document.getElementById('edit-description').value = tool.description;
            
            // Initialize CodeMirror if not already done
            if (!codeEditor) {
                initCodeEditor();
            }
            codeEditor.setValue(tool.implementation.trim());
            
            // Render parameters (simplified - just show as text for now)
            const paramsEl = document.getElementById('edit-parameters');
            if (tool.parameters.length === 0) {
                paramsEl.innerHTML = '<em style="color: #666;">None</em>';
            } else {
                paramsEl.innerHTML = tool.parameters.map(p => 
                    `<code style="background: #0a0a15; padding: 2px 6px; border-radius: 2px; margin-right: 5px;">${p.name}: ${p.type}</code>`
                ).join('');
            }
            
            document.getElementById('tool-editor-modal').style.display = 'flex';
            
            // Hide any previous errors
            hideToolError();
            
            // Refresh CodeMirror after modal is visible
            setTimeout(() => codeEditor.refresh(), 10);
        }
        
        function closeToolEditor() {
            document.getElementById('tool-editor-modal').style.display = 'none';
            editingToolIndex = -1;
        }
        
        function saveTool() {
            if (editingToolIndex < 0) return;
            
            const name = document.getElementById('edit-name').value;
            const description = document.getElementById('edit-description').value;
            const implementation = codeEditor.getValue();
            
            // Validate the implementation - try to create the function
            const validationError = validateToolImplementation(implementation);
            if (validationError) {
                showToolError(validationError);
                return;
            }
            
            const tool = currentTools[editingToolIndex];
            tool.name = name;
            tool.description = description;
            tool.implementation = implementation;
            
            // Save to localStorage
            saveTools();
            renderToolsList();
            closeToolEditor();
        }
        
        function validateToolImplementation(code) {
            try {
                // Try to create the function - catches syntax errors
                new Function('stdlib', 'input', code);
                return null; // No error
            } catch (e) {
                let errorMsg = e.message;
                
                // Make syntax errors more friendly
                if (errorMsg.includes('Unexpected token')) {
                    errorMsg = `Syntax error: ${errorMsg}. Check for missing brackets, quotes, or semicolons.`;
                } else if (errorMsg.includes('Unexpected end of input')) {
                    errorMsg = 'Unexpected end of code. You might be missing a closing bracket } or )';
                } else if (errorMsg.includes('Unexpected identifier')) {
                    errorMsg = `Syntax error: ${errorMsg}. Check for missing operators or semicolons.`;
                }
                
                return errorMsg;
            }
        }
        
        function showToolError(message) {
            // Show error in the modal
            let errorEl = document.getElementById('tool-error');
            if (!errorEl) {
                errorEl = document.createElement('div');
                errorEl.id = 'tool-error';
                errorEl.style.cssText = 'background: rgba(255,80,80,0.2); border: 1px solid #f55; color: #f88; padding: 10px; border-radius: 4px; margin-bottom: 10px; font-size: 0.85rem;';
                const wrapper = document.getElementById('edit-implementation-wrapper');
                wrapper.parentNode.insertBefore(errorEl, wrapper.nextSibling);
            }
            errorEl.innerHTML = `<strong>‚ö†Ô∏è Error:</strong> ${message}`;
            errorEl.style.display = 'block';
        }
        
        function hideToolError() {
            const errorEl = document.getElementById('tool-error');
            if (errorEl) {
                errorEl.style.display = 'none';
            }
        }
        
        function saveTools() {
            localStorage.setItem('rescue-run-tools', JSON.stringify(currentTools));
        }
        
        function loadTools() {
            const saved = localStorage.getItem('rescue-run-tools');
            if (saved) {
                try {
                    currentTools = JSON.parse(saved);
                } catch (e) {
                    console.error('Failed to load saved tools:', e);
                    currentTools = JSON.parse(JSON.stringify(DEFAULT_TOOLS));
                }
            }
        }
        
        function resetTools() {
            if (confirm('Reset all tools to defaults? Your changes will be lost.')) {
                currentTools = JSON.parse(JSON.stringify(DEFAULT_TOOLS));
                localStorage.removeItem('rescue-run-tools');
                renderToolsList();
            }
        }

        // ===========================================
        // UI SETUP
        // ===========================================
        
        function setupUI() {
            // Level selector
            setupLevelSelector();
            
            // Reset button
            document.getElementById('btn-reset').addEventListener('click', () => {
                resetGame();
            });
            
            // AI buttons
            document.getElementById('btn-run-ai').addEventListener('click', () => {
                runAI();
            });
            
            document.getElementById('btn-stop-ai').addEventListener('click', () => {
                stopAI();
            });
            
            // Tool editor buttons
            document.getElementById('btn-reset-tools').addEventListener('click', () => {
                resetTools();
            });
            
            // Modal buttons
            document.getElementById('btn-close-modal').addEventListener('click', closeToolEditor);
            document.getElementById('btn-cancel-edit').addEventListener('click', closeToolEditor);
            document.getElementById('btn-save-tool').addEventListener('click', saveTool);
            
            // Close modal on background click
            document.getElementById('tool-editor-modal').addEventListener('click', (e) => {
                if (e.target.id === 'tool-editor-modal') {
                    closeToolEditor();
                }
            });
            
            // Review panel buttons
            document.getElementById('btn-close-review').addEventListener('click', hideReview);
            document.getElementById('btn-edit-after-review').addEventListener('click', () => {
                if (currentTools.length > 0) {
                    openToolEditor(0);
                }
            });
            document.getElementById('btn-run-again').addEventListener('click', () => {
                resetGame();
                hideReview();
                runAI();
            });
        }

        // ===========================================
        // INITIALIZATION & AUTH
        // ===========================================
        
        let currentUser = null;
        
        async function checkAuth() {
            try {
                const res = await fetch('/auth/me', { credentials: 'include' });
                if (!res.ok) {
                    return null;
                }
                const data = await res.json();
                return data.user;
            } catch (e) {
                console.error('Auth check failed:', e);
                return null;
            }
        }
        
        function showLoginPrompt() {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = `
                <div style="color: #ff9800;">‚ö†Ô∏è Login Required</div>
                <div style="font-size: 0.8rem; margin-top: 5px;">
                    <a href="/" style="color: #4fc3f7;">Go to login page</a>
                </div>
            `;
            statusEl.className = 'status';
            
            // Disable AI button
            document.getElementById('btn-run-ai').disabled = true;
            
            aiLog('Please login to use AI features', 'ai-error');
        }
        
        async function init() {
            // Load saved tools
            loadTools();
            renderToolsList();
            
            // Load completed levels
            loadCompletedLevels();
            
            await loadAssets();
            render();
            setupUI();
            
            // Update level buttons with completion status
            updateLevelButtons();
            
            // Check authentication
            currentUser = await checkAuth();
            
            if (currentUser) {
                aiLog(`Logged in as ${currentUser.username}`, 'ai-result');
            } else {
                showLoginPrompt();
            }
        }

        init();
    </script>
</body>
</html>