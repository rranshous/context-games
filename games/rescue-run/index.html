<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rescue Run</title>
    <!-- CodeMirror for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #1a1a2e;
            color: #eee;
            height: 100vh;
            padding: 4px;
            overflow: hidden;
            box-sizing: border-box;
        }
        
        /* v0.7: Four-column layout - Game | Prompt | Tools | Review */
        /* Workflow: edit ‚Üí run ‚Üí review ‚Üí edit */
        .game-container {
            display: grid;
            grid-template-columns: auto minmax(200px, 300px) 1fr minmax(280px, 400px);
            gap: 6px;
            max-width: 100%;
            margin: 0;
            height: 100%;
        }
        
        /* Left column: Game + Controls - auto width based on canvas */
        .game-column {
            display: flex;
            flex-direction: column;
            gap: 4px;
            overflow-y: auto;
            min-width: 180px;
        }
        
        /* Second column: System Prompt */
        .prompt-column {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 0;
        }
        
        /* v0.7: Disabled state for prompt column during runs */
        .prompt-column.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Third column: Tools */
        .tools-column {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 0; /* Allow flex shrinking */
        }
        
        /* v0.7: Disabled state for tools column during runs */
        .tools-column.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Right column: Review */
        .ai-column {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 0; /* Allow flex shrinking */
        }
        
        .game-panel {
            background: #16213e;
            border-radius: 4px;
            padding: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        h1 {
            font-size: 1rem;
            margin-bottom: 6px;
            color: #e94560;
        }
        
        h2 {
            font-size: 0.8rem;
            margin-bottom: 4px;
            color: #0f3460;
            background: #e94560;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        #game-canvas {
            border: 2px solid #0f3460;
            border-radius: 4px;
            background: #2d4a3e;
            image-rendering: pixelated;
            max-width: 100%;
        }
        
        /* Level buttons - compact */
        .level-btn {
            padding: 4px 8px !important;
            font-size: 0.75rem !important;
            width: auto !important;
            min-width: 36px;
        }
        
        .control-group {
            background: #1a1a2e;
            padding: 6px;
            border-radius: 4px;
        }
        
        .control-group h3 {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button {
            background: #0f3460;
            color: #fff;
            border: none;
            padding: 5px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.2s;
            width: 100%;
            margin-bottom: 3px;
        }
        
        button:hover {
            background: #e94560;
        }
        
        button:disabled {
            background: #333;
            cursor: not-allowed;
        }
        
        .direction-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
        }
        
        .direction-buttons button {
            padding: 6px;
            font-size: 1rem;
        }
        
        .direction-buttons .empty {
            visibility: hidden;
        }
        
        #log {
            background: #0a0a15;
            border-radius: 3px;
            padding: 6px;
            font-family: monospace;
            font-size: 0.75rem;
            max-height: 150px;
            overflow-y: auto;
            color: #8f8;
        }
        
        #log .entry {
            margin-bottom: 2px;
            padding-bottom: 2px;
            border-bottom: 1px solid #222;
        }
        
        #log .error {
            color: #f88;
        }
        
        #log .success {
            color: #8f8;
        }
        
        #log .info {
            color: #88f;
        }
        
        .status {
            font-size: 0.8rem;
            padding: 5px;
            border-radius: 3px;
            text-align: center;
        }
        
        .status.playing {
            background: #0f3460;
        }
        
        .status.won {
            background: #2e7d32;
            animation: celebrate 0.5s ease-in-out;
        }
        
        @keyframes celebrate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .legend {
            font-size: 0.7rem;
            color: #888;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 2px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .ai-panel {
            background: #1a1a2e;
            padding: 6px;
            border-radius: 4px;
        }
        
        .ai-controls {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
        }
        
        .ai-controls button {
            flex: 1;
        }
        
        #btn-run-ai {
            background: #e94560;
        }
        
        #btn-run-ai:hover {
            background: #ff6b8a;
        }
        
        #btn-run-ai:disabled {
            background: #333;
        }
        
        #btn-stop-ai {
            background: #ff9800;
        }
        
        #btn-stop-ai:hover {
            background: #ffb74d;
        }
        
        #ai-log {
            background: #0a0a15;
            border-radius: 3px;
            padding: 6px;
            font-family: monospace;
            font-size: 0.65rem;
            overflow-y: auto;
            color: #ccc;
            /* flex: 1 in inline style handles height - no max-height cap */
            min-height: 0; /* Allow flex shrinking */
        }
        
        #ai-log .ai-thinking {
            color: #ff9800;
            font-style: italic;
        }
        
        #ai-log .ai-tool {
            color: #4fc3f7;
        }
        
        #ai-log .ai-result {
            color: #8f8;
            margin-left: 10px;
        }
        
        #ai-log .ai-error {
            color: #f88;
        }
        
        .ai-status {
            font-size: 0.75rem;
            padding: 4px;
            border-radius: 3px;
            text-align: center;
            margin-bottom: 6px;
            background: #333;
        }
        
        .ai-status.running {
            background: #e94560;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Tools List */
        #tools-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .tool-item {
            background: #1a1a2e;
            border-radius: 4px;
            border: 1px solid #333;
            overflow: hidden;
        }
        
        .tool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .tool-header:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .tool-header-left {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            min-width: 0;
        }
        
        .tool-expand-icon {
            font-size: 0.7rem;
            color: #888;
            transition: transform 0.2s;
        }
        
        .tool-item.expanded .tool-expand-icon {
            transform: rotate(90deg);
        }
        
        .tool-name {
            font-family: monospace;
            color: #4fc3f7;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .tool-body {
            display: none;
            padding: 8px;
            border-top: 1px solid #333;
            background: #0f1628;
        }
        
        .tool-item.expanded .tool-body {
            display: block;
        }
        
        .tool-form-group {
            margin-bottom: 8px;
        }
        
        .tool-form-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 0.75rem;
            color: #888;
        }
        
        .tool-form-group input,
        .tool-form-group textarea {
            width: 100%;
            padding: 5px;
            background: #0a0a15;
            border: 1px solid #333;
            border-radius: 3px;
            color: #fff;
            font-size: 0.8rem;
            box-sizing: border-box;
        }
        
        .tool-form-group textarea {
            resize: vertical;
            font-family: monospace;
        }
        
        .tool-editor-wrapper {
            border: 1px solid #333;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .tool-editor-wrapper .CodeMirror {
            height: 300px; /* v0.7: More space for code editing */
            font-size: 0.75rem;
        }
        
        .tool-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }
        
        .tool-actions button {
            padding: 4px 10px;
            font-size: 0.75rem;
        }
        
        .tool-save-btn {
            background: #4caf50 !important;
        }
        
        .tool-save-btn:hover {
            background: #66bb6a !important;
        }
        
        /* Tool Toggle Switch */
        .tool-toggle {
            position: relative;
            width: 32px;
            height: 18px;
            flex-shrink: 0;
        }
        
        .tool-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .tool-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: 0.2s;
            border-radius: 18px;
        }
        
        .tool-toggle-slider:before {
            position: absolute;
            content: "";
            height: 12px;
            width: 12px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.2s;
            border-radius: 50%;
        }
        
        .tool-toggle input:checked + .tool-toggle-slider {
            background-color: #4caf50;
        }
        
        .tool-toggle input:checked + .tool-toggle-slider:before {
            transform: translateX(14px);
        }
        
        .tool-item.disabled {
            opacity: 0.5;
        }
        
        .tool-item.disabled .tool-name {
            text-decoration: line-through;
            color: #888;
        }
        
        .tool-error {
            background: rgba(255,80,80,0.2);
            border: 1px solid #f55;
            color: #f88;
            padding: 6px;
            border-radius: 3px;
            margin-top: 6px;
            font-size: 0.75rem;
            display: none;
        }
        
        .tool-stdlib-ref {
            margin-top: 6px;
        }
        
        .tool-stdlib-ref summary {
            cursor: pointer;
            color: #4fc3f7;
            font-size: 0.75rem;
        }
        
        .tool-stdlib-ref pre {
            background: #0a0a15;
            padding: 6px;
            border-radius: 3px;
            font-size: 0.65rem;
            overflow-x: auto;
            margin: 6px 0 0 0;
        }
        
        #btn-reset-tools {
            padding: 5px 10px;
            font-size: 0.75rem;
            background: #666;
        }
        
        /* Level selector */
        .level-btn {
            padding: 4px 8px;
            font-size: 0.75rem;
            background: #333;
            border: 1px solid #555;
            color: #aaa;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .level-btn:hover {
            background: #444;
            color: #fff;
        }
        
        .level-btn.selected {
            background: #e94560;
            border-color: #e94560;
            color: #fff;
        }
        
        .level-btn.completed {
            border-color: #4caf50;
        }
        
        .level-btn.completed::after {
            content: ' ‚úì';
            color: #4caf50;
        }
        
        .level-btn.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Review Panel */
        .review-panel {
            margin-top: 8px;
            padding: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            border: 1px solid #333;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        
        .review-panel h3 {
            margin: 0 0 8px 0;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .review-result {
            padding: 6px 10px;
            border-radius: 3px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .review-result.success {
            background: rgba(76, 175, 80, 0.2);
            color: #8f8;
        }
        
        .review-result.failure {
            background: rgba(233, 69, 96, 0.2);
            color: #f88;
        }
        
        .review-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .review-stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: #0a0a15;
            border-radius: 3px;
            font-size: 0.75rem;
        }
        
        .review-stat-item .tool-name {
            font-family: monospace;
            color: #4fc3f7;
        }
        
        .review-stat-item .stat-counts {
            display: flex;
            gap: 8px;
            font-size: 0.7rem;
        }
        
        .review-stat-item .stat-counts .calls {
            color: #aaa;
        }
        
        .review-stat-item .stat-counts .success-count {
            color: #8f8;
        }
        
        .review-stat-item .stat-counts .fail-count {
            color: #f88;
        }
        
        .review-stat-item.never-used {
            opacity: 0.5;
        }
        
        .review-stat-item.never-used .tool-name::after {
            content: " (never used)";
            color: #888;
            font-style: italic;
        }
        
        .review-actions {
            margin-top: 8px;
            display: flex;
            gap: 6px;
        }
        
        .review-actions button {
            flex: 1;
            padding: 6px;
            font-size: 0.75rem;
        }
        
        .review-story {
            font-family: monospace;
            font-size: 0.7rem;
            color: #aaa;
            padding: 8px;
            background: #0a0a15;
            border-radius: 3px;
            margin-bottom: 8px;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .review-story .story-fail {
            color: #f88;
        }
        
        .review-story .story-success {
            color: #8f8;
        }
        
        .review-story .story-stuck {
            background: rgba(255, 152, 0, 0.3);
            padding: 1px 3px;
            border-radius: 2px;
            border-bottom: 2px solid #ff9800;
        }
        
        .review-tool-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .review-hints {
            background: rgba(255, 152, 0, 0.15);
            border: 1px solid #ff9800;
            border-radius: 3px;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 0.75rem;
        }
        
        /* v0.6: Tool Call History */
        .call-history-section {
            margin-top: 10px;
            border-top: 1px solid #333;
            padding-top: 8px;
        }
        
        .call-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 6px;
            background: #1a1a2e;
            border-radius: 3px;
            margin-bottom: 6px;
        }
        
        .call-history-header:hover {
            background: #222244;
        }
        
        .call-history-header h4 {
            margin: 0;
            font-size: 0.8rem;
            color: #4fc3f7;
        }
        
        .call-history-toggle {
            font-size: 0.7rem;
            color: #888;
        }
        
        .call-history-list {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 2px; /* v0.7: Tighter spacing */
        }
        
        .call-history-item {
            background: #0a0a15;
            border-radius: 3px;
            border: 1px solid #333;
        }
        
        .call-history-item.success {
            border-left: 2px solid #4caf50;
        }
        
        .call-history-item.failure {
            border-left: 2px solid #f44336;
        }
        
        .call-history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 0.75rem;
        }
        
        .call-history-item-header:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .call-history-item-left {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .call-history-turn {
            color: #888;
            font-size: 0.65rem;
            min-width: 30px;
        }
        
        .call-history-name {
            font-family: monospace;
            color: #4fc3f7;
        }
        
        .call-history-summary {
            color: #aaa;
            font-size: 0.7rem;
            max-width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .call-history-expand {
            color: #888;
            font-size: 0.65rem;
            transition: transform 0.2s;
        }
        
        .call-history-item.expanded .call-history-expand {
            transform: rotate(90deg);
        }
        
        .call-history-detail {
            display: none; /* v0.7: Collapsed by default */
            padding: 8px;
            border-top: 1px solid #333;
            background: #0f1628;
        }
        
        /* v0.7: Show detail when item is expanded */
        .call-history-item.expanded .call-history-detail {
            display: block;
        }
        
        .call-history-json {
            font-family: monospace;
            font-size: 0.7rem;
            margin-bottom: 6px;
        }
        
        .call-history-json-label {
            color: #888;
            margin-bottom: 3px;
            font-size: 0.65rem;
            text-transform: uppercase;
        }
        
        .call-history-json pre {
            background: #0a0a15;
            padding: 6px;
            border-radius: 3px;
            margin: 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #ddd;
        }
        
        .call-history-copy-btn {
            padding: 3px 6px !important;
            font-size: 0.65rem !important;
            background: #333 !important;
            margin-left: 6px;
        }
        
        .call-history-copy-btn:hover {
            background: #4fc3f7 !important;
        }
        
        .review-hints h4 {
            margin: 0 0 6px 0;
            color: #ff9800;
            font-size: 0.8rem;
        }
        
        .review-hints ul {
            margin: 0;
            padding-left: 16px;
        }
        
        .review-hints li {
            margin-bottom: 3px;
            color: #ddd;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- LEFT COLUMN: Game -->
        <div class="game-column">
            <div class="game-panel">
                <h1>üöó Rescue Run <span style="font-size: 0.5em; color: #666;">v0.7</span></h1>
                <canvas id="game-canvas" width="280" height="252"></canvas>
                <div class="legend" style="margin-top: 10px;">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4a7c59;"></div>
                        <span>Grass</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #555;"></div>
                        <span>Road</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e94560;"></div>
                        <span>Person (rescue target)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4fc3f7;"></div>
                        <span>Safe Zone</span>
                    </div>
                </div>
            </div>
            
            <div class="game-panel">
                <h2>üìç Level</h2>
                <div id="level-info">
                    <div id="level-name" style="font-weight: bold; margin-bottom: 5px;">Level 1: Tutorial</div>
                    <div id="level-turns" style="font-size: 0.85rem; color: #aaa;">Turn limit: 50</div>
                </div>
                <div id="level-selector" style="margin-top: 10px; display: flex; gap: 5px; flex-wrap: wrap;">
                    <button class="level-btn selected" data-level="1">L1</button>
                    <button class="level-btn" data-level="2">L2</button>
                    <button class="level-btn" data-level="3">L3</button>
                    <button class="level-btn" data-level="4">L4</button>
                    <button class="level-btn" data-level="5">L5</button>
                    <button class="level-btn" data-level="6">L6</button>
                    <button class="level-btn" data-level="7">L7</button>
                </div>
            </div>
            
            <div class="game-panel">
                <h2>Status</h2>
                <div id="status" class="status playing">Ready</div>
                <div id="turn-counter" style="margin-top: 8px; font-size: 0.85rem; color: #aaa;">Turn: 0</div>
            </div>
            
            <!-- Game Controls: Run, Stop, Reset -->
            <div class="game-panel">
                <h2>üéÆ Controls</h2>
                <div id="ai-status" class="ai-status">Ready</div>
                <div style="display: flex; flex-direction: column; gap: 4px; margin-top: 6px;">
                    <button id="btn-run-ai" style="background: #e94560;">‚ñ∂Ô∏è Run AI</button>
                    <button id="btn-stop-ai" style="background: #ff9800;" disabled>‚èπÔ∏è Stop</button>
                    <button id="btn-reset">üîÑ Reset Level</button>
                </div>
                <!-- Post-run actions (shown after AI completes) -->
                <div id="post-run-actions" style="display: none; margin-top: 8px; padding-top: 8px; border-top: 1px solid #333;">
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        <button id="btn-edit-after-review">‚úèÔ∏è Edit Tools</button>
                        <button id="btn-run-again">‚ñ∂Ô∏è Run Again</button>
                        <button id="btn-next-level" style="display: none; background: #4CAF50;">‚û°Ô∏è Next Level</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- SECOND COLUMN: System Prompt -->
        <div class="prompt-column">
            <div class="game-panel" style="flex: 1; display: flex; flex-direction: column;">
                <h2>üìù System Prompt</h2>
                <textarea id="system-prompt" style="flex: 1; width: 100%; background: #0a0a15; border: 1px solid #333; border-radius: 4px; color: #fff; font-size: 0.8rem; padding: 6px; resize: none; font-family: inherit; min-height: 100px;"></textarea>
                <div style="font-size: 0.7rem; color: #666; margin-top: 3px;">Prompt sent to AI</div>
            </div>
        </div>
        
        <!-- THIRD COLUMN: Tools -->
        <div class="tools-column">
            <div class="game-panel" style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                <h2>üîß Tools</h2>
                <div id="tools-list" style="flex: 1; overflow-y: auto;"></div>
                <div style="margin-top: 8px; display: flex; gap: 6px;">
                    <button id="btn-add-tool" style="background: #4caf50; flex: 1;">‚ûï Add Tool</button>
                    <button id="btn-reset-tools" style="flex: 1;">‚Ü©Ô∏è Reset</button>
                </div>
            </div>
        </div>
        
        <!-- FOURTH COLUMN: Review -->
        <div class="ai-column">
            <div class="game-panel" style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                <h2>üìä Review</h2>
                <div id="ai-log" style="flex: 1; overflow-y: auto;"></div>
                
                <!-- Review Panel (hidden until run completes) -->
                <div id="review-panel" class="review-panel" style="display: none;">
                    <div id="review-result" class="review-result"></div>
                    <div id="review-hints" class="review-hints" style="display: none;"></div>
                    <div id="review-stats" class="review-stats"></div>
                    
                    <!-- v0.6: Tool Call History -->
                    <div class="call-history-section">
                        <h4 style="margin: 0 0 6px 0; font-size: 0.8rem; color: #4fc3f7;">üîç Tool Call History</h4>
                        <div id="call-history-list" class="call-history-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===========================================
        // GAME CONSTANTS
        // ===========================================
        const TILE_SIZE = 14; // v0.7: Compact layout (20x18 grid @ 14px = 280x252)
        // Grid size is now dynamic per level

        // Tile types
        const TILE = {
            GRASS: 0,
            ROAD: 1,
            BUILDING: 2
        };

        // ===========================================
        // GAME STATE
        // ===========================================
        // ===========================================
        // LEVEL DEFINITIONS (ASCII FORMAT)
        // ===========================================
        // Legend:
        //   = : grass (impassable)
        //   . : road (passable)
        //   # : building (impassable)
        //   C : car start (on road)
        //   P : person (on road)
        //   S : safe zone (on road)
        
        const LEVELS = {
            1: {
                name: "Tutorial",
                turns: 50,
                map: `
========
=C.....=
=.====.=
=.=##=.=
=.=##=.=
=.....P=
=S====.=
========
`
            },
            2: {
                name: "Hidden Alley",
                turns: 50,
                map: `
========
=C.....=
=.====.=
=.=##P.=
=.=##=.=
=......=
=S====.=
========
`
            },
            3: {
                name: "Fork in the Road",
                turns: 55,
                map: `
==========
=C.......=
=.==.===.=
=.==.=...=
=....=.=.=
=.==.=.=.=
=S==...=P=
==========
`
            },
            4: {
                name: "Dead End Alley",
                turns: 65,
                map: `
============
=C.........=
=.========.=
=.=......=.=
=.=.====.=.=
=.=....=.=.=
=.====.=...=
=......=.=P=
=.======.=.=
=S=#=#=#...=
============
`
            },
            5: {
                name: "The Long Way",
                turns: 85,
                map: `
==============
=C...........=
=.==========.=
=.=........=.=
=.=.======.=.=
=.=.=....=.=.=
=.=.=.==.=.=.=
=.=.=.==.=.=P=
=.=......=...=
=.==========.=
=S...........=
==============
`
            },
            6: {
                name: "Crossroads",
                turns: 75,
                map: `
================
=C.....=.......=
=.===..=..===..=
=...=..=..=....=
=...=.....=....=
=...=..=..=....=
=......=.......=
=====..=..=====.
=......=.......=
=...=..=..=....=
=...=.....=...P=
=...=..=..=....=
=.===..=..===..=
=S.....=.......=
================
`
            },
            7: {
                name: "The Labyrinth",
                turns: 130,
                map: `
====================
=C.=...=.....=.....=
=.===.===.=..=.===.=
=.....=...=..=.=...=
=====.=.===.===.=.==
=.....=.=.....=.=..=
=.=====.=.===.=.==.=
=.=.....=...=.=....=
=.=.=======.=.====.=
=.=.=.......=.......
=.=.=.=====.=======.
=...=.=...=.......=.
=.===.=.=.=======.=.
=.=...=.=.........=.
=.=.===.=.=======.=.
=.=.....=.=.....=.=P
=.=======.=.===.=.==
=S........=...=....=
====================
`
            }
        };
        
        // ===========================================
        // LEVEL PARSER
        // ===========================================
        
        function parseLevel(levelData) {
            const lines = levelData.map.trim().split('\n');
            const height = lines.length;
            const width = lines[0].length;
            
            const map = [];
            let car = null;
            let person = null;
            let safeZone = null;
            
            for (let y = 0; y < height; y++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const char = lines[y][x] || '=';
                    
                    switch (char) {
                        case '=': // grass
                            row.push(0);
                            break;
                        case '.': // road
                            row.push(1);
                            break;
                        case '#': // building
                            row.push(2);
                            break;
                        case 'C': // car (on road)
                            row.push(1);
                            car = { x, y, direction: 'east' };
                            break;
                        case 'P': // person (on road)
                            row.push(1);
                            person = { x, y, rescued: false };
                            break;
                        case 'S': // safe zone (on road)
                            row.push(1);
                            safeZone = { x, y };
                            break;
                        default:
                            row.push(0); // unknown = grass
                    }
                }
                map.push(row);
            }
            
            return {
                name: levelData.name,
                turns: levelData.turns,
                map,
                car,
                person,
                safeZone,
                width,
                height
            };
        }
        
        // Current level (default to 1)
        let currentLevelNum = 1;
        let currentLevel = parseLevel(LEVELS[1]);
        
        // Track completed levels
        let completedLevels = new Set();
        
        function loadCompletedLevels() {
            try {
                const saved = localStorage.getItem('rescue-run-completed');
                if (saved) {
                    completedLevels = new Set(JSON.parse(saved));
                }
            } catch (e) {
                console.error('Failed to load completed levels:', e);
            }
        }
        
        function saveCompletedLevels() {
            localStorage.setItem('rescue-run-completed', JSON.stringify([...completedLevels]));
        }
        
        function markLevelCompleted(levelNum) {
            completedLevels.add(levelNum);
            saveCompletedLevels();
            updateLevelButtons();
        }
        
        // v0.7: Save/load selected level
        function saveSelectedLevel(levelNum) {
            localStorage.setItem('rescue-run-selected-level', levelNum.toString());
        }
        
        function loadSelectedLevel() {
            try {
                const saved = localStorage.getItem('rescue-run-selected-level');
                if (saved) {
                    const levelNum = parseInt(saved);
                    if (levelNum >= 1 && levelNum <= 7) {
                        return levelNum;
                    }
                }
            } catch (e) {
                console.error('Failed to load selected level:', e);
            }
            return 1; // Default to level 1
        }
        
        // v0.7: Personal best tracking
        let personalBests = {}; // { levelNum: turnCount }
        
        function loadPersonalBests() {
            try {
                const saved = localStorage.getItem('rescue-run-personal-bests');
                if (saved) {
                    personalBests = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load personal bests:', e);
            }
        }
        
        function savePersonalBests() {
            localStorage.setItem('rescue-run-personal-bests', JSON.stringify(personalBests));
        }
        
        function updatePersonalBest(levelNum, turnCount) {
            const currentBest = personalBests[levelNum];
            if (!currentBest || turnCount < currentBest) {
                personalBests[levelNum] = turnCount;
                savePersonalBests();
                updateLevelButtons();
                return true; // New best!
            }
            return false;
        }
        
        function getPersonalBest(levelNum) {
            return personalBests[levelNum] || null;
        }
        
        function updateLevelButtons() {
            document.querySelectorAll('.level-btn').forEach(btn => {
                const levelNum = parseInt(btn.dataset.level);
                const best = getPersonalBest(levelNum);
                
                // Build button text: L1 (12) - CSS ::after adds ‚úì for completed
                let text = `L${levelNum}`;
                if (completedLevels.has(levelNum)) {
                    btn.classList.add('completed');
                }
                if (best) {
                    text += ` (${best})`;
                }
                btn.textContent = text;
            });
        }
        
        // ===========================================
        // GAME STATE
        // ===========================================
        
        const gameState = {
            // Car state
            car: { ...currentLevel.car },
            
            // Person to rescue
            person: { ...currentLevel.person },
            
            // Safe zone location
            safeZone: { ...currentLevel.safeZone },
            
            // Is person in car?
            personInCar: false,
            
            // Game status
            status: 'playing', // 'playing', 'won'
            
            // The map grid
            map: currentLevel.map
        };

        // ===========================================
        // ASSETS
        // ===========================================
        const assets = {
            carSprite: null,
            loaded: false
        };

        function loadAssets() {
            return new Promise((resolve, reject) => {
                const carImg = new Image();
                carImg.onload = () => {
                    assets.carSprite = carImg;
                    assets.loaded = true;
                    resolve();
                };
                carImg.onerror = () => {
                    assets.loaded = true;
                    resolve(); // Continue anyway with fallback rendering
                };
                carImg.src = 'assets/Cars/Player_blue%20(16%20x%2016).png';
            });
        }

        // ===========================================
        // RENDERING
        // ===========================================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            const width = currentLevel.width * TILE_SIZE;
            const height = currentLevel.height * TILE_SIZE;
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        
        // Initialize canvas size
        resizeCanvas();

        function render() {
            // Clear
            ctx.fillStyle = '#2d4a3e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw tiles
            for (let y = 0; y < currentLevel.height; y++) {
                for (let x = 0; x < currentLevel.width; x++) {
                    const tile = gameState.map[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;
                    
                    switch (tile) {
                        case TILE.GRASS:
                            ctx.fillStyle = '#4a7c59';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Add some texture
                            ctx.fillStyle = '#3d6b4a';
                            ctx.fillRect(px + 4, py + 4, 2, 2);
                            ctx.fillRect(px + 20, py + 12, 2, 2);
                            ctx.fillRect(px + 10, py + 24, 2, 2);
                            break;
                        case TILE.ROAD:
                            ctx.fillStyle = '#555';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Road markings
                            ctx.fillStyle = '#777';
                            ctx.fillRect(px, py, TILE_SIZE, 1);
                            ctx.fillRect(px, py + TILE_SIZE - 1, TILE_SIZE, 1);
                            break;
                        case TILE.BUILDING:
                            ctx.fillStyle = '#8b7355';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Building detail
                            ctx.fillStyle = '#6b5344';
                            ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#ffeb3b';
                            ctx.fillRect(px + 8, py + 8, 6, 6);
                            break;
                    }
                }
            }
            
            // Draw safe zone
            const sz = gameState.safeZone;
            ctx.fillStyle = 'rgba(79, 195, 247, 0.5)';
            ctx.fillRect(sz.x * TILE_SIZE, sz.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.strokeRect(sz.x * TILE_SIZE + 2, sz.y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
            // Safe zone icon
            ctx.fillStyle = '#4fc3f7';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üè†', sz.x * TILE_SIZE + TILE_SIZE/2, sz.y * TILE_SIZE + TILE_SIZE/2 + 5);
            
            // Draw person (if not rescued/in car)
            if (!gameState.personInCar && !gameState.person.rescued) {
                const p = gameState.person;
                ctx.fillStyle = '#e94560';
                ctx.beginPath();
                ctx.arc(p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2, 8, 0, Math.PI * 2);
                ctx.fill();
                // Person icon
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üßç', p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2 + 4);
            }
            
            // Draw car
            const car = gameState.car;
            const carX = car.x * TILE_SIZE + TILE_SIZE/2;
            const carY = car.y * TILE_SIZE + TILE_SIZE/2;
            
            ctx.save();
            ctx.translate(carX, carY);
            
            // Rotate based on direction (sprite faces north/up by default)
            const angles = { north: 0, east: Math.PI/2, south: Math.PI, west: -Math.PI/2 };
            ctx.rotate(angles[car.direction] || 0);
            
            if (assets.carSprite) {
                // Draw sprite (first frame, 16x16, scaled to ~24px)
                const scale = 1.5;
                const spriteSize = 16;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(
                    assets.carSprite,
                    0, 0, spriteSize, spriteSize,  // Source
                    -spriteSize * scale / 2, -spriteSize * scale / 2, spriteSize * scale, spriteSize * scale  // Dest
                );
            } else {
                // Fallback: draw a simple car shape
                ctx.fillStyle = '#2196f3';
                ctx.fillRect(-10, -6, 20, 12);
                ctx.fillStyle = '#1565c0';
                ctx.fillRect(6, -4, 4, 8);
            }
            
            ctx.restore();
            
            // If person is in car, show indicator
            if (gameState.personInCar) {
                ctx.fillStyle = '#e94560';
                ctx.font = '12px Arial';
                ctx.fillText('üßç', carX + 12, carY - 12);
            }
        }

        // ===========================================
        // ===========================================
        // STANDARD LIBRARY (stdlib)
        // Low-level game primitives for tool implementations
        // ===========================================
        /*
         * STDLIB API REFERENCE (for tool implementations)
         * 
         * Position/State:
         *   stdlib.getCarPosition()      ‚Üí {x, y}
         *   stdlib.getCarDirection()     ‚Üí "north"|"south"|"east"|"west"
         *   stdlib.getPersonPosition()   ‚Üí {x, y} or null if rescued
         *   stdlib.getSafeZonePosition() ‚Üí {x, y}
         *   stdlib.isPersonInCar()       ‚Üí boolean
         *   stdlib.isPersonRescued()     ‚Üí boolean
         * 
         * Map:
         *   stdlib.getGridSize()         ‚Üí {width, height}
         *   stdlib.isValidPosition(x,y)  ‚Üí boolean
         *   stdlib.getTileAt(x,y)        ‚Üí {type, passable}
         *                                  type: "grass"|"road"|"building"|"edge"
         * 
         * Actions:
         *   stdlib.moveCarOneStep(dir)   ‚Üí {success, error?}
         *   stdlib.pickupPerson()        ‚Üí {success, error?}
         *   stdlib.dropoffPerson()       ‚Üí {success, error?}
         */
        const stdlib = {
            // === Position/State ===
            getCarPosition: () => ({ x: gameState.car.x, y: gameState.car.y }),
            getCarDirection: () => gameState.car.direction,
            getPersonPosition: () => gameState.person.rescued ? null : { x: gameState.person.x, y: gameState.person.y },
            getSafeZonePosition: () => ({ x: gameState.safeZone.x, y: gameState.safeZone.y }),
            isPersonInCar: () => gameState.personInCar,
            isPersonRescued: () => gameState.person.rescued,
            
            // === Map ===
            getGridSize: () => ({ width: currentLevel.width, height: currentLevel.height }),
            isValidPosition: (x, y) => x >= 0 && x < currentLevel.width && y >= 0 && y < currentLevel.height,
            getTileAt: (x, y) => {
                if (!stdlib.isValidPosition(x, y)) {
                    return { type: 'edge', passable: false };
                }
                const tile = gameState.map[y][x];
                const typeNames = { [TILE.GRASS]: 'grass', [TILE.ROAD]: 'road', [TILE.BUILDING]: 'building' };
                return {
                    type: typeNames[tile] || 'unknown',
                    passable: tile === TILE.ROAD
                };
            },
            
            // === Actions ===
            moveCarOneStep: (direction) => {
                const moves = {
                    north: { dx: 0, dy: -1 },
                    south: { dx: 0, dy: 1 },
                    east: { dx: 1, dy: 0 },
                    west: { dx: -1, dy: 0 }
                };
                
                if (!moves[direction]) {
                    return { success: false, error: `Invalid direction: ${direction}` };
                }
                
                const move = moves[direction];
                const newX = gameState.car.x + move.dx;
                const newY = gameState.car.y + move.dy;
                
                // Always update facing direction
                gameState.car.direction = direction;
                
                if (!stdlib.isValidPosition(newX, newY)) {
                    return { success: false, error: 'Would go off the map' };
                }
                
                const tile = stdlib.getTileAt(newX, newY);
                if (!tile.passable) {
                    return { success: false, error: `${tile.type} is not passable` };
                }
                
                // Move the car
                gameState.car.x = newX;
                gameState.car.y = newY;
                return { success: true };
            },
            
            pickupPerson: () => {
                if (gameState.personInCar) {
                    return { success: false, error: 'Person already in car' };
                }
                if (gameState.person.rescued) {
                    return { success: false, error: 'Person already rescued' };
                }
                const car = gameState.car;
                const person = gameState.person;
                if (car.x !== person.x || car.y !== person.y) {
                    return { success: false, error: 'No person at current location' };
                }
                gameState.personInCar = true;
                return { success: true };
            },
            
            dropoffPerson: () => {
                if (!gameState.personInCar) {
                    return { success: false, error: 'No person in car' };
                }
                const car = gameState.car;
                const sz = gameState.safeZone;
                if (car.x !== sz.x || car.y !== sz.y) {
                    return { success: false, error: 'Not at safe zone' };
                }
                gameState.personInCar = false;
                gameState.person.rescued = true;
                gameState.status = 'won';
                checkWinCondition();
                return { success: true };
            }
        };

        // ===========================================
        // WIN DETECTION & RESET
        // ===========================================
        
        function checkWinCondition() {
            if (gameState.person.rescued) {
                gameState.status = 'won';
                const statusEl = document.getElementById('status');
                statusEl.textContent = 'üéâ RESCUE COMPLETE!';
                statusEl.className = 'status won';
            }
        }
        
        function loadLevel(levelNum) {
            if (!LEVELS[levelNum]) {
                console.error(`Level ${levelNum} not found`);
                return false;
            }
            
            currentLevelNum = levelNum;
            currentLevel = parseLevel(LEVELS[levelNum]);
            
            // Update game state with level data
            gameState.car = { ...currentLevel.car };
            gameState.person = { ...currentLevel.person };
            gameState.safeZone = { ...currentLevel.safeZone };
            gameState.map = currentLevel.map;
            gameState.personInCar = false;
            gameState.status = 'playing';
            
            // Resize canvas for this level
            resizeCanvas();
            
            // Update level info display
            updateLevelDisplay();
            
            return true;
        }
        
        function updateLevelDisplay() {
            document.getElementById('level-name').textContent = 
                `Level ${currentLevelNum}: ${currentLevel.name}`;
            document.getElementById('level-turns').textContent = 
                `Turn limit: ${currentLevel.turns}`;
            
            // Update button selection
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (parseInt(btn.dataset.level) === currentLevelNum) {
                    btn.classList.add('selected');
                }
            });
        }
        
        function setupLevelSelector() {
            const selector = document.getElementById('level-selector');
            
            // Add click handlers to level buttons
            selector.addEventListener('click', (e) => {
                const btn = e.target.closest('.level-btn');
                if (!btn || btn.classList.contains('locked')) return;
                
                const levelNum = parseInt(btn.dataset.level);
                if (levelNum !== currentLevelNum) {
                    selectLevel(levelNum);
                }
            });
            
            // Initialize display
            updateLevelDisplay();
        }
        
        function selectLevel(levelNum) {
            if (!LEVELS[levelNum]) return;
            
            // Load the level
            loadLevel(levelNum);
            
            // v0.7: Save selected level
            saveSelectedLevel(levelNum);
            
            // Reset AI state for fresh start
            aiState.result = null;
            aiState.messages = [];
            
            // Reset game UI
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'Ready';
            statusEl.className = 'status playing';
            
            // Show turn limit in AI status
            updateAiStatus(`Ready (${currentLevel.turns} turns)`, false);
            
            // Clear AI log
            clearAiLog();
            aiLog(`Level ${levelNum}: ${currentLevel.name} loaded. Turn limit: ${currentLevel.turns}`, 'ai-result');
            
            // Hide review panel
            hideReview();
            
            render();
        }
        
        function resetGame() {
            // Reload current level
            loadLevel(currentLevelNum);
            
            // Reset AI state so it can be run again
            aiState.result = null;
            aiState.messages = [];
            aiState.toolCallHistory = []; // v0.7: Clear tool call history
            
            // Reset UI
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'Ready';
            statusEl.className = 'status playing';
            
            // Update turn counter
            document.getElementById('turn-counter').textContent = 'Turn: 0';
            
            // Show turn limit in AI status
            updateAiStatus(`Ready (${currentLevel.turns} turns)`, false);
            
            // Clear AI log
            clearAiLog();
            aiLog('Game reset. Ready to run AI.', 'ai-result');
            
            // v0.7: Set UI mode back to idle
            setUiMode('idle');
            
            render();
        }
        // ===========================================
        // AI INTEGRATION (Claude Haiku)
        // ===========================================
        
        // Tool definitions with implementations
        // Players can edit these - implementation is JS using stdlib.*
        const DEFAULT_TOOLS = [
            {
                name: "scan",
                description: "Check your current status. Returns your position, whether you have a person in the car, and whether you're at the person or safe zone.",
                parameters: [],
                implementation: `
// ========================================
// SCAN TOOL - Check current status
// ========================================
// This is a BASIC scan - it tells you:
// - Where you are (current_position)
// - Whether you have a person in the car
// - Whether person or safe zone is at your location
//
// TIP: To navigate better, you might want to 
// improve this tool to show what's AROUND you!

const pos = stdlib.getCarPosition();

const result = {
    current_position: pos,
    person_in_car: stdlib.isPersonInCar()
};

// Check if person is at current location
const personPos = stdlib.getPersonPosition();
if (personPos && personPos.x === pos.x && personPos.y === pos.y) {
    result.person_here = true;
}

// Check if safe zone is at current location
const szPos = stdlib.getSafeZonePosition();
if (szPos.x === pos.x && szPos.y === pos.y) {
    result.at_safe_zone = true;
}

return result;
`
            },
            {
                name: "move",
                description: "Move the car one tile in the specified direction. The car can only move on road tiles. Returns success status and your new position.",
                parameters: [
                    {
                        name: "direction",
                        type: "string",
                        enum: ["north", "south", "east", "west"],
                        description: "The direction to move: north (up), south (down), east (right), or west (left)",
                        required: true
                    }
                ],
                implementation: `
// ========================================
// MOVE TOOL - Move the car one tile
// ========================================
// input.direction contains the direction the AI wants to move
// (north, south, east, or west)

// Try to move - returns {success: true} or {success: false, error: "..."}
const result = stdlib.moveCarOneStep(input.direction);

// TIP: You could improve this tool to tell you
// what's at your new location after moving!

return result;
`
            },
            {
                name: "pickup",
                description: "Pick up a person if they are at your current location. You must be on the same tile as the person to pick them up.",
                parameters: [],
                implementation: `
// ========================================
// PICKUP TOOL - Pick up the person
// ========================================
// The car must be on the same tile as the person

// Try to pick up - returns {success: true} or {success: false, error: "..."}
const result = stdlib.pickupPerson();

// Add a friendly message on success
if (result.success) {
    result.message = 'Person picked up! Now take them to the safe zone.';
}

return result;
`
            },
            {
                name: "dropoff",
                description: "Drop off the person you're carrying. You must be at the safe zone and have a person in the car to drop them off. This completes the rescue!",
                parameters: [],
                implementation: `
// ========================================
// DROPOFF TOOL - Drop off at safe zone
// ========================================
// Must have person in car AND be at safe zone

// Try to drop off - returns {success: true} or {success: false, error: "..."}
const result = stdlib.dropoffPerson();

// Add a celebration message on success!
if (result.success) {
    result.message = 'Person dropped off at safe zone! RESCUE COMPLETE!';
}

return result;
`
            }
        ];
        
        // Current tools (can be modified by player)
        let currentTools = JSON.parse(JSON.stringify(DEFAULT_TOOLS));
        
        // Convert tool definitions to Claude API format (only enabled tools)
        function getClaudeTools() {
            return currentTools
                .filter(tool => tool.enabled !== false)
                .map(tool => ({
                name: tool.name,
                description: tool.description,
                input_schema: {
                    type: "object",
                    properties: tool.parameters.reduce((props, param) => {
                        props[param.name] = {
                            type: param.type,
                            description: param.description
                        };
                        if (param.enum) {
                            props[param.name].enum = param.enum;
                        }
                        return props;
                    }, {}),
                    required: tool.parameters.filter(p => p.required).map(p => p.name)
                }
            }));
        }
        
        // Execute a tool by running its implementation
        function executeTool(toolName, toolInput) {
            const tool = currentTools.find(t => t.name === toolName);
            if (!tool) {
                return { success: false, error: `Unknown tool: ${toolName}` };
            }
            
            try {
                // Create a function from the implementation string
                // It has access to 'stdlib' and 'input'
                const fn = new Function('stdlib', 'input', tool.implementation);
                const result = fn(stdlib, toolInput || {});
                
                // If result is undefined, the tool forgot to return
                if (result === undefined) {
                    return { 
                        success: false, 
                        error: `Tool "${toolName}" didn't return anything. Add a return statement.` 
                    };
                }
                
                return result;
            } catch (e) {
                // Parse error messages to be more helpful
                const errorMsg = e.message;
                let friendlyError = errorMsg;
                
                // Common JS errors
                if (errorMsg.includes('is not defined')) {
                    const match = errorMsg.match(/(\w+) is not defined/);
                    const varName = match ? match[1] : 'variable';
                    friendlyError = `"${varName}" is not defined. Did you mean stdlib.${varName}() or misspell something?`;
                } else if (errorMsg.includes('is not a function')) {
                    const match = errorMsg.match(/(\w+) is not a function/);
                    const fnName = match ? match[1] : 'something';
                    friendlyError = `"${fnName}" is not a function. Check the stdlib reference for available functions.`;
                } else if (errorMsg.includes('Unexpected token')) {
                    friendlyError = `Syntax error: ${errorMsg}. Check for missing brackets, quotes, or semicolons.`;
                } else if (errorMsg.includes('Cannot read properties of undefined')) {
                    friendlyError = `Tried to access a property on undefined. A stdlib function might have returned null/undefined.`;
                }
                
                return { success: false, error: friendlyError };
            }
        }
        
        // ===========================================
        // v0.7: UI MODE STATE
        // ===========================================
        // Modes: 'idle' | 'running' | 'reviewing'
        let uiMode = 'idle';
        
        function setUiMode(mode) {
            uiMode = mode;
            document.body.setAttribute('data-ui-mode', mode);
            
            // Update prompt column - disable editing during runs
            const promptColumn = document.querySelector('.prompt-column');
            // Update tools column - disable editing during runs
            const toolsColumn = document.querySelector('.tools-column');
            
            if (mode === 'running') {
                promptColumn.classList.add('disabled');
                toolsColumn.classList.add('disabled');
                // Disable all inputs in both columns
                promptColumn.querySelectorAll('input, textarea, button').forEach(el => {
                    el.disabled = true;
                });
                toolsColumn.querySelectorAll('input, textarea, button').forEach(el => {
                    el.disabled = true;
                });
            } else {
                promptColumn.classList.remove('disabled');
                toolsColumn.classList.remove('disabled');
                // Re-enable all inputs in both columns
                promptColumn.querySelectorAll('input, textarea, button').forEach(el => {
                    el.disabled = false;
                });
                toolsColumn.querySelectorAll('input, textarea, button').forEach(el => {
                    el.disabled = false;
                });
            }
            
            // Update AI column based on mode
            updateAiColumnForMode(mode);
        }
        
        function updateAiColumnForMode(mode) {
            const aiLog = document.getElementById('ai-log');
            const reviewPanel = document.getElementById('review-panel');
            const postRunActions = document.getElementById('post-run-actions');
            
            if (mode === 'running') {
                // Show log, hide review
                aiLog.style.display = 'block';
                reviewPanel.style.display = 'none';
                postRunActions.style.display = 'none';
            } else if (mode === 'reviewing') {
                // Keep log visible, show review, show post-run actions
                aiLog.style.display = 'block';
                reviewPanel.style.display = 'block';
                postRunActions.style.display = 'block';
            } else {
                // Idle: show log (for next run), hide review, hide post-run actions
                aiLog.style.display = 'block';
                reviewPanel.style.display = 'none';
                postRunActions.style.display = 'none';
            }
        }
        
        // AI state
        const aiState = {
            running: false,
            messages: [],
            stopRequested: false,
            // Review tracking
            toolStats: {},      // { toolName: { calls: 0, successes: 0, failures: 0 } }
            toolHistory: [],    // [{ name: 'scan', args: {}, success: true }, ...]
            // v0.6: Full tool call history for debugging
            toolCallHistory: [], // [{ turn, timestamp, name, input, output }, ...]
            currentTurn: 0,
            totalTurns: 0,
            result: null        // 'success' | 'failure' | 'stopped' | 'error'
        };
        
        function resetToolStats() {
            aiState.toolStats = {};
            aiState.toolHistory = [];
            aiState.toolCallHistory = []; // v0.6: Reset full call history
            aiState.currentTurn = 0;
            aiState.totalTurns = 0;
            aiState.result = null;
            // Initialize stats for all tools
            currentTools.forEach(tool => {
                aiState.toolStats[tool.name] = { calls: 0, successes: 0, failures: 0 };
            });
        }
        
        function trackToolCall(toolName, toolInput, result) {
            if (!aiState.toolStats[toolName]) {
                aiState.toolStats[toolName] = { calls: 0, successes: 0, failures: 0 };
            }
            aiState.toolStats[toolName].calls++;
            const success = result.success !== false;
            if (success) {
                aiState.toolStats[toolName].successes++;
            } else {
                aiState.toolStats[toolName].failures++;
            }
            // Record in history (compact version for review)
            aiState.toolHistory.push({ name: toolName, args: toolInput, success });
            
            // v0.6: Record full call details for debugging
            aiState.toolCallHistory.push({
                turn: aiState.currentTurn,
                timestamp: Date.now(),
                name: toolName,
                input: JSON.parse(JSON.stringify(toolInput || {})),
                output: JSON.parse(JSON.stringify(result))
            });
        }
        
        // AI logging
        const aiLogEl = document.getElementById('ai-log');
        
        function aiLog(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = type;
            entry.textContent = message;
            aiLogEl.appendChild(entry);
            aiLogEl.scrollTop = aiLogEl.scrollHeight;
        }
        
        function clearAiLog() {
            aiLogEl.innerHTML = '';
        }
        
        // Build system prompt - just use user's prompt directly
        function buildSystemPrompt() {
            return getSystemPrompt();
        }
        
        // Call Claude API via vanilla platform proxy
        async function callClaude(messages) {
            const response = await fetch('/api/inference/anthropic/messages', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    model: 'claude-haiku-4-5-20251001',
                    max_tokens: 1024,
                    system: buildSystemPrompt(),
                    tools: getClaudeTools(),
                    messages: messages
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                const errorMsg = error.error || 'API call failed';
                
                // Handle specific error types
                if (response.status === 401) {
                    throw new Error('AUTH_REQUIRED');
                } else if (errorMsg.toLowerCase().includes('token') || errorMsg.toLowerCase().includes('limit')) {
                    throw new Error('TOKEN_LIMIT');
                }
                throw new Error(errorMsg);
            }
            
            return await response.json();
        }
        
        // Main agentic loop
        async function runAI() {
            if (aiState.running) return;
            
            // Can't continue after failure - must reset
            if (aiState.result === 'failure' || aiState.result === 'error') {
                aiLog('‚ùå Level failed. Reset the game to try again.', 'ai-error');
                return;
            }
            
            // Check auth before starting
            if (!currentUser) {
                aiLog('‚ùå Please login first', 'ai-error');
                return;
            }
            
            // v0.7: Set UI mode to running
            setUiMode('running');
            
            aiState.running = true;
            aiState.stopRequested = false;
            aiState.messages = [];
            
            // Reset tracking for review
            resetToolStats();
            
            clearAiLog();
            
            document.getElementById('btn-run-ai').disabled = true;
            document.getElementById('btn-stop-ai').disabled = false;
            
            // Disable manual controls while AI runs
            document.querySelectorAll('.control-group button').forEach(btn => {
                btn.disabled = true;
            });
            
            const maxIterations = currentLevel.turns || 50; // Use level turn limit
            updateAiStatus(`Turn 0/${maxIterations}`, true);
            
            aiLog('ü§ñ AI starting rescue mission...', 'ai-thinking');
            
            // Start with a minimal user message to kick off the conversation
            aiState.messages.push({
                role: 'user',
                content: 'BEGIN'
            });
            
            let iterations = 0;
            
            try {
                while (aiState.running && !aiState.stopRequested && iterations < maxIterations) {
                    iterations++;
                    aiState.currentTurn = iterations; // v0.6: Track current turn for call history
                    updateAiStatus(`Turn ${iterations}/${maxIterations}`, true);
                    
                    // v0.7: Update turn counter in game column
                    document.getElementById('turn-counter').textContent = `Turn: ${iterations}`;
                    
                    if (gameState.status === 'won') {
                        aiLog('üéâ RESCUE COMPLETE! Mission successful!', 'ai-result');
                        markLevelCompleted(currentLevelNum);
                        
                        // v0.7: Track personal best
                        const isNewBest = updatePersonalBest(currentLevelNum, iterations);
                        if (isNewBest) {
                            aiLog(`üèÜ NEW PERSONAL BEST: ${iterations} turns!`, 'ai-result');
                        } else {
                            const best = getPersonalBest(currentLevelNum);
                            aiLog(`Completed in ${iterations} turns (best: ${best})`, 'ai-result');
                        }
                        break;
                    }
                    
                    // Call Claude
                    aiLog(`[Turn ${iterations}] Thinking...`, 'ai-thinking');
                    const response = await callClaude(aiState.messages);
                    
                    // Process response
                    const assistantContent = response.content;
                    aiState.messages.push({ role: 'assistant', content: assistantContent });
                    
                    // Check if Claude wants to use tools
                    const toolUses = assistantContent.filter(block => block.type === 'tool_use');
                    const textBlocks = assistantContent.filter(block => block.type === 'text');
                    
                    // Log any text Claude says
                    for (const text of textBlocks) {
                        if (text.text.trim()) {
                            aiLog(`üí≠ ${text.text}`, 'ai-thinking');
                        }
                    }
                    
                    if (toolUses.length === 0) {
                        // No tool use, check if we're done
                        if (response.stop_reason === 'end_turn') {
                            aiLog('AI finished without completing rescue', 'ai-error');
                            break;
                        }
                    }
                    
                    // Execute each tool and collect results
                    const toolResults = [];
                    for (const toolUse of toolUses) {
                        aiLog(`üîß ${toolUse.name}(${JSON.stringify(toolUse.input)})`, 'ai-tool');
                        
                        const result = executeTool(toolUse.name, toolUse.input);
                        
                        // Track for review
                        trackToolCall(toolUse.name, toolUse.input, result);
                        
                        // Log result
                        if (result.success === false) {
                            aiLog(`   ‚ùå ${result.error}`, 'ai-error');
                        } else if (result.success === true) {
                            aiLog(`   ‚úÖ ${result.message || 'OK'}`, 'ai-result');
                        } else {
                            // Scan result - summarize it
                            aiLog(`   üìç Pos: (${result.current_position.x},${result.current_position.y})`, 'ai-result');
                        }
                        
                        toolResults.push({
                            type: 'tool_result',
                            tool_use_id: toolUse.id,
                            content: JSON.stringify(result)
                        });
                        
                        // Update display
                        render();
                        
                        // Small delay for visual feedback
                        await new Promise(r => setTimeout(r, 300));
                    }
                    
                    // Add tool results to messages
                    if (toolResults.length > 0) {
                        aiState.messages.push({ role: 'user', content: toolResults });
                    }
                    
                    // Small delay between turns
                    await new Promise(r => setTimeout(r, 200));
                }
                
                if (iterations >= maxIterations) {
                    aiLog('‚ö†Ô∏è Max iterations reached', 'ai-error');
                    aiState.result = 'failure';
                }
                
                // Set result based on game state
                if (gameState.status === 'won') {
                    aiState.result = 'success';
                } else if (aiState.stopRequested) {
                    aiState.result = 'stopped';
                } else if (!aiState.result) {
                    aiState.result = 'failure';
                }
                
                aiState.totalTurns = iterations;
                
            } catch (error) {
                aiState.result = 'error';
                aiState.totalTurns = iterations;
                
                // Handle specific error types with user-friendly messages
                if (error.message === 'AUTH_REQUIRED') {
                    aiLog('‚ùå Session expired. Please login again.', 'ai-error');
                    currentUser = null;
                    showLoginPrompt();
                } else if (error.message === 'TOKEN_LIMIT') {
                    aiLog('‚ùå Token limit reached! Contact admin for more tokens.', 'ai-error');
                } else {
                    aiLog(`‚ùå Error: ${error.message}`, 'ai-error');
                }
                console.error('AI error:', error);
            }
            
            // Cleanup
            aiState.running = false;
            updateAiStatus(`Ready (${currentLevel.turns} turns)`, false);
            document.getElementById('btn-run-ai').disabled = currentUser ? false : true;
            document.getElementById('btn-stop-ai').disabled = true;
            
            // v0.7: Switch to review mode and show review panel
            setUiMode('reviewing');
            showReview();
        }
        
        function stopAI() {
            aiState.stopRequested = true;
            aiLog('‚èπÔ∏è Stop requested...', 'ai-thinking');
        }
        
        // ===========================================
        // REVIEW PANEL
        // ===========================================
        
        function generateHints(state) {
            const hints = [];
            const stats = state.toolStats;
            const history = state.toolHistory;
            
            // Check if failed
            if (state.result !== 'success') {
                // Never used pickup
                if (stats.pickup?.calls === 0) {
                    hints.push("The AI never tried to pick up the person. Does your <code>scan</code> tool tell the AI where the person is?");
                }
                
                // Never used dropoff but has person
                if (stats.dropoff?.calls === 0 && stats.pickup?.calls > 0) {
                    hints.push("The AI picked up the person but never found the safe zone. Does <code>scan</code> reveal safe zone locations?");
                }
                
                // Lots of move failures
                const moveFailures = stats.move?.failures || 0;
                if (moveFailures > 5) {
                    hints.push(`The AI hit walls ${moveFailures} times. Does <code>scan</code> tell it which directions are passable?`);
                }
                
                // Scan not used or barely used
                if ((stats.scan?.calls || 0) < 3) {
                    hints.push("The AI barely scanned its surroundings. Is the <code>scan</code> tool description clear about what it does?");
                }
                
                // Level-specific hints
                if (currentLevelNum === 2 && stats.pickup?.calls === 0) {
                    hints.push("<strong>Level 2 Tip:</strong> The person is hidden in a side alley. Your scan needs to show what's in <em>each direction</em> so the AI can spot them!");
                }
                
                if (currentLevelNum === 3 && stats.pickup?.calls === 0) {
                    hints.push("<strong>Level 3 Tip:</strong> There's a fork in the road! The stdlib has <code>getPersonPosition()</code> - use it to tell the AI exactly where to go!");
                }
            }
            
            // Even on success, check for inefficiency
            if (state.result === 'success' && state.totalTurns > 40) {
                hints.push("Success! But the AI took many turns. Could your tools provide better information to help it navigate more directly?");
            }
            
            // Check for looping patterns
            const loopPattern = detectLoopPattern(history);
            if (loopPattern) {
                hints.push(`The AI seemed to loop (${loopPattern}). It might not have enough info to make good decisions.`);
            }
            
            return hints;
        }
        
        function detectLoopPattern(history) {
            if (!history || history.length < 8) return null;
            
            // Look for repeating direction patterns (e.g., north-south-north-south)
            const moves = history.filter(h => h.name === 'move').map(h => h.args?.direction);
            if (moves.length < 6) return null;
            
            // Check last 6 moves for back-and-forth
            const last6 = moves.slice(-6);
            const backForth = last6.filter((m, i) => {
                if (i === 0) return false;
                const prev = last6[i - 1];
                return (m === 'north' && prev === 'south') ||
                       (m === 'south' && prev === 'north') ||
                       (m === 'east' && prev === 'west') ||
                       (m === 'west' && prev === 'east');
            }).length;
            
            if (backForth >= 3) {
                return 'back-and-forth movement';
            }
            
            return null;
        }
        
        function showReview() {
            const panel = document.getElementById('review-panel');
            const resultEl = document.getElementById('review-result');
            const statsEl = document.getElementById('review-stats');
            
            // Result summary
            const resultMessages = {
                success: `‚úÖ SUCCESS! Rescued in ${aiState.totalTurns} turns`,
                failure: `‚ùå FAILED after ${aiState.totalTurns} turns`,
                stopped: `‚èπÔ∏è STOPPED at turn ${aiState.totalTurns}`,
                error: `‚ö†Ô∏è ERROR at turn ${aiState.totalTurns}`
            };
            
            resultEl.textContent = resultMessages[aiState.result] || 'Unknown result';
            resultEl.className = `review-result ${aiState.result === 'success' ? 'success' : 'failure'}`;
            
            // Generate hints based on what happened
            const hints = generateHints(aiState);
            const hintsEl = document.getElementById('review-hints');
            if (hints.length > 0) {
                hintsEl.innerHTML = `<h4>üí° Suggestions</h4><ul>${hints.map(h => `<li>${h}</li>`).join('')}</ul>`;
                hintsEl.style.display = 'block';
            } else {
                hintsEl.style.display = 'none';
            }
            
            // Build the story - compress consecutive same calls
            const story = buildToolStory(aiState.toolHistory);
            
            // Tool stats
            const toolNames = currentTools.map(t => t.name);
            let statsHtml = '';
            
            // Story section
            statsHtml += `<div class="review-story">${story}</div>`;
            
            // Stats per tool
            statsHtml += '<div class="review-tool-stats">';
            for (const toolName of toolNames) {
                const stats = aiState.toolStats[toolName] || { calls: 0, successes: 0, failures: 0 };
                const neverUsed = stats.calls === 0;
                
                statsHtml += `
                    <div class="review-stat-item ${neverUsed ? 'never-used' : ''}">
                        <span class="tool-name">${toolName}()</span>
                        <span class="stat-counts">
                            ${neverUsed ? '' : `
                                ${stats.failures > 0 ? `<span class="fail-count">‚úó${stats.failures}</span>` : ''}
                                ${stats.successes > 0 ? `<span class="success-count">‚úì${stats.successes}</span>` : ''}
                            `}
                        </span>
                    </div>
                `;
            }
            statsHtml += '</div>';
            
            statsEl.innerHTML = statsHtml;
            
            // Show/hide Next Level button
            const nextLevelBtn = document.getElementById('btn-next-level');
            const nextLevelNum = currentLevelNum + 1;
            if (aiState.result === 'success' && LEVELS[nextLevelNum]) {
                nextLevelBtn.style.display = 'inline-block';
                nextLevelBtn.onclick = () => {
                    hideReview();
                    selectLevel(nextLevelNum);
                };
            } else {
                nextLevelBtn.style.display = 'none';
            }
            
            // v0.6: Reset call history state when showing review
            // v0.6: Render call history immediately (always visible)
            renderCallHistory();
            
            panel.style.display = 'block';
        }
        
        function buildToolStory(history) {
            if (!history || history.length === 0) return '<em>No tool calls</em>';
            
            const parts = [];
            let i = 0;
            
            while (i < history.length) {
                const call = history[i];
                let count = 1;
                
                // For move, group by same direction
                if (call.name === 'move') {
                    const dir = call.args?.direction;
                    while (i + count < history.length && 
                           history[i + count].name === 'move' && 
                           history[i + count].args?.direction === dir) {
                        count++;
                    }
                    const failCount = history.slice(i, i + count).filter(c => !c.success).length;
                    let text = `move(${dir})`;
                    if (count > 1) text += `√ó${count}`;
                    if (failCount > 0) text = `<span class="story-fail">${text}</span>`;
                    parts.push({ text, startIdx: i, endIdx: i + count - 1 });
                }
                // For scan, just count consecutive scans
                else if (call.name === 'scan') {
                    while (i + count < history.length && history[i + count].name === 'scan') {
                        count++;
                    }
                    let text = 'scan';
                    if (count > 1) text += `√ó${count}`;
                    parts.push({ text, startIdx: i, endIdx: i + count - 1 });
                }
                // For pickup/dropoff, show success/fail
                else {
                    let text = call.name;
                    if (!call.success) text = `<span class="story-fail">${text}!</span>`;
                    else text = `<span class="story-success">${text}‚úì</span>`;
                    parts.push({ text, startIdx: i, endIdx: i });
                }
                
                i += count;
            }
            
            // Detect stuck patterns: back-and-forth moves
            const stuckIndices = new Set();
            for (let p = 1; p < parts.length; p++) {
                const curr = parts[p].text;
                const prev = parts[p - 1].text;
                // Check for opposite directions
                if ((curr.includes('north') && prev.includes('south')) ||
                    (curr.includes('south') && prev.includes('north')) ||
                    (curr.includes('east') && prev.includes('west')) ||
                    (curr.includes('west') && prev.includes('east'))) {
                    stuckIndices.add(p - 1);
                    stuckIndices.add(p);
                }
            }
            
            // Also mark consecutive failures as stuck
            for (let p = 0; p < parts.length; p++) {
                if (parts[p].text.includes('story-fail')) {
                    // Check if next is also a failure
                    if (p + 1 < parts.length && parts[p + 1].text.includes('story-fail')) {
                        stuckIndices.add(p);
                        stuckIndices.add(p + 1);
                    }
                }
            }
            
            // Build final story with stuck highlights
            return parts.map((p, idx) => {
                if (stuckIndices.has(idx)) {
                    return `<span class="story-stuck">${p.text}</span>`;
                }
                return p.text;
            }).join(' ‚Üí ');
        }
        
        function hideReview() {
            document.getElementById('review-panel').style.display = 'none';
        }
        
        // ===========================================
        // v0.6: TOOL CALL HISTORY
        // ===========================================
        
        function renderCallHistory() {
            const listEl = document.getElementById('call-history-list');
            const history = aiState.toolCallHistory;
            
            if (!history || history.length === 0) {
                listEl.innerHTML = '<div style="color: #888; padding: 10px; font-size: 0.8rem;">No tool calls recorded</div>';
                return;
            }
            
            listEl.innerHTML = history.map((call, idx) => {
                const isSuccess = call.output.success !== false;
                // v0.7: Compact summary for collapsed view
                const argSummary = call.name === 'move' && call.input?.direction 
                    ? `(${call.input.direction.charAt(0).toUpperCase()})` 
                    : '';
                
                return `
                    <div class="call-history-item ${isSuccess ? 'success' : 'failure'}" data-index="${idx}">
                        <div class="call-history-item-header" onclick="toggleCallHistoryItem(${idx})">
                            <div class="call-history-item-left">
                                <span class="call-history-turn">T${call.turn}</span>
                                <span class="call-history-name">${call.name}${argSummary}</span>
                            </div>
                            <span class="call-history-expand">‚ñ∂</span>
                        </div>
                        <div class="call-history-detail" id="call-detail-${idx}">
                            <div class="call-history-json">
                                <div class="call-history-json-label">
                                    Input
                                    <button class="call-history-copy-btn" onclick="copyCallJson(${idx}, 'input', this); event.stopPropagation();">üìã Copy</button>
                                </div>
                                <pre>${formatJson(call.input)}</pre>
                            </div>
                            <div class="call-history-json">
                                <div class="call-history-json-label">
                                    Output
                                    <button class="call-history-copy-btn" onclick="copyCallJson(${idx}, 'output', this); event.stopPropagation();">üìã Copy</button>
                                </div>
                                <pre>${formatJson(call.output)}</pre>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // v0.7: Toggle call history item expansion
        function toggleCallHistoryItem(idx) {
            const item = document.querySelector(`.call-history-item[data-index="${idx}"]`);
            if (item) {
                item.classList.toggle('expanded');
            }
        }
        
        function summarizeJson(obj) {
            if (!obj || Object.keys(obj).length === 0) return '{}';
            const keys = Object.keys(obj);
            if (keys.length === 1) {
                const val = obj[keys[0]];
                if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {
                    return `${keys[0]}: ${val}`;
                }
            }
            // Compact summary
            const summary = JSON.stringify(obj);
            return summary.length > 30 ? summary.substring(0, 30) + '...' : summary;
        }
        
        function formatJson(obj) {
            try {
                return escapeHtml(JSON.stringify(obj, null, 2));
            } catch (e) {
                return escapeHtml(String(obj));
            }
        }
        
        function copyCallJson(idx, type, btnElement) {
            const call = aiState.toolCallHistory[idx];
            if (!call) return;
            
            const data = type === 'input' ? call.input : call.output;
            const text = JSON.stringify(data, null, 2);
            
            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback
                if (btnElement) {
                    const originalText = btnElement.textContent;
                    btnElement.textContent = '‚úì Copied';
                    setTimeout(() => btnElement.textContent = originalText, 1000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }
        
        function updateAiStatus(text, running) {
            const statusEl = document.getElementById('ai-status');
            statusEl.textContent = text;
            statusEl.className = running ? 'ai-status running' : 'ai-status';
        }

        // ===========================================
        // TOOL EDITOR (Inline)
        // ===========================================
        
        let toolEditors = {}; // Map of tool index to CodeMirror instance
        let expandedToolIndex = -1;
        
        function renderToolsList() {
            const listEl = document.getElementById('tools-list');
            listEl.innerHTML = currentTools.map((tool, i) => {
                const enabled = tool.enabled !== false; // default to true
                return `
                <div class="tool-item ${enabled ? '' : 'disabled'}" data-index="${i}" id="tool-item-${i}">
                    <div class="tool-header" onclick="toggleToolExpand(${i})">
                        <div class="tool-header-left">
                            <span class="tool-expand-icon">‚ñ∂</span>
                            <span class="tool-name">${tool.name}(${tool.parameters.map(p => p.name).join(', ')})</span>
                        </div>
                        <label class="tool-toggle" onclick="event.stopPropagation();">
                            <input type="checkbox" ${enabled ? 'checked' : ''} onchange="toggleToolEnabled(${i}, this.checked)" />
                            <span class="tool-toggle-slider"></span>
                        </label>
                    </div>
                    <div class="tool-body">
                        <div class="tool-form-group">
                            <label>Name:</label>
                            <input type="text" id="tool-name-${i}" value="${escapeHtml(tool.name)}" />
                        </div>
                        <div class="tool-form-group">
                            <label>Description (AI sees this):</label>
                            <textarea id="tool-desc-${i}" rows="2">${escapeHtml(tool.description)}</textarea>
                        </div>
                        <div class="tool-form-group">
                            <label>Params: ${tool.parameters.length === 0 ? '<em style="color: #666;">None</em>' : tool.parameters.map(p => `<code style="background: #0a0a15; padding: 2px 6px; border-radius: 2px;">${p.name}: ${p.type}</code>`).join(' ')}</label>
                        </div>
                        <div class="tool-form-group">
                            <label>Implementation (JS using stdlib.*):</label>
                            <div class="tool-editor-wrapper" id="tool-editor-${i}"></div>
                        </div>
                        <div class="tool-error" id="tool-error-${i}"></div>
                        <div class="tool-stdlib-ref">
                            <details>
                                <summary>üìö Stdlib Reference</summary>
                                <pre>Position/State:
  stdlib.getCarPosition()      ‚Üí {x, y}
  stdlib.getCarDirection()     ‚Üí "north"|"south"|"east"|"west"
  stdlib.getPersonPosition()   ‚Üí {x, y} or null
  stdlib.getSafeZonePosition() ‚Üí {x, y}
  stdlib.isPersonInCar()       ‚Üí boolean

Map:
  stdlib.getGridSize()         ‚Üí {width, height}
  stdlib.isValidPosition(x,y)  ‚Üí boolean
  stdlib.getTileAt(x,y)        ‚Üí {type, passable}

Actions:
  stdlib.moveCarOneStep(dir)   ‚Üí {success, error?}
  stdlib.pickupPerson()        ‚Üí {success, error?}
  stdlib.dropoffPerson()       ‚Üí {success, error?}</pre>
                            </details>
                        </div>
                        <div class="tool-actions">
                            <button class="tool-save-btn" onclick="saveToolInline(${i}); event.stopPropagation();">üíæ Save</button>
                        </div>
                    </div>
                </div>
            `}).join('');
            
            // Clear old CodeMirror instances
            toolEditors = {};
        }
        
        function toggleToolEnabled(index, enabled) {
            currentTools[index].enabled = enabled;
            const item = document.getElementById(`tool-item-${index}`);
            if (enabled) {
                item.classList.remove('disabled');
            } else {
                item.classList.add('disabled');
            }
            saveTools();
        }
        
        function addNewTool() {
            const newTool = {
                name: 'newTool',
                description: 'Describe what this tool does for the AI',
                parameters: [],
                enabled: true,
                implementation: `// Your tool implementation here
// Use stdlib.* functions to interact with the game
return { message: "Tool executed" };`
            };
            currentTools.push(newTool);
            saveTools();
            renderToolsList();
            
            // Expand the new tool immediately
            const newIndex = currentTools.length - 1;
            setTimeout(() => toggleToolExpand(newIndex), 50);
        }
        
        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }
        
        function toggleToolExpand(index) {
            const item = document.getElementById(`tool-item-${index}`);
            const wasExpanded = item.classList.contains('expanded');
            
            // Toggle this tool (allow multiple to be open)
            if (wasExpanded) {
                item.classList.remove('expanded');
            } else {
                item.classList.add('expanded');
                expandedToolIndex = index;
                
                // Initialize CodeMirror for this tool if not already
                if (!toolEditors[index]) {
                    const wrapper = document.getElementById(`tool-editor-${index}`);
                    const tool = currentTools[index];
                    toolEditors[index] = CodeMirror(wrapper, {
                        value: tool.implementation.trim(),
                        mode: 'javascript',
                        theme: 'dracula',
                        lineNumbers: true,
                        lineWrapping: true,
                        tabSize: 2,
                        indentWithTabs: false
                    });
                }
                // Refresh CodeMirror after expansion animation
                setTimeout(() => toolEditors[index].refresh(), 10);
            }
        }
        
        function saveToolInline(index) {
            const name = document.getElementById(`tool-name-${index}`).value;
            const description = document.getElementById(`tool-desc-${index}`).value;
            const implementation = toolEditors[index] ? toolEditors[index].getValue() : currentTools[index].implementation;
            
            // Validate the implementation
            const validationError = validateToolImplementation(implementation);
            if (validationError) {
                showToolErrorInline(index, validationError);
                return;
            }
            
            // Save changes
            const tool = currentTools[index];
            tool.name = name;
            tool.description = description;
            tool.implementation = implementation;
            
            saveTools();
            hideToolErrorInline(index);
            
            // Update header text
            const item = document.getElementById(`tool-item-${index}`);
            const nameEl = item.querySelector('.tool-name');
            nameEl.textContent = `${name}(${tool.parameters.map(p => p.name).join(', ')})`;
            
            // Brief visual feedback
            const btn = item.querySelector('.tool-save-btn');
            btn.textContent = '‚úì Saved';
            setTimeout(() => btn.textContent = 'üíæ Save', 1000);
        }
        
        function showToolErrorInline(index, message) {
            const errorEl = document.getElementById(`tool-error-${index}`);
            errorEl.innerHTML = `<strong>‚ö†Ô∏è Error:</strong> ${message}`;
            errorEl.style.display = 'block';
        }
        
        function hideToolErrorInline(index) {
            const errorEl = document.getElementById(`tool-error-${index}`);
            errorEl.style.display = 'none';
        }
        
        function validateToolImplementation(code) {
            try {
                // Try to create the function - catches syntax errors
                new Function('stdlib', 'input', code);
                return null; // No error
            } catch (e) {
                let errorMsg = e.message;
                
                // Make syntax errors more friendly
                if (errorMsg.includes('Unexpected token')) {
                    errorMsg = `Syntax error: ${errorMsg}. Check for missing brackets, quotes, or semicolons.`;
                } else if (errorMsg.includes('Unexpected end of input')) {
                    errorMsg = 'Unexpected end of code. You might be missing a closing bracket } or )';
                } else if (errorMsg.includes('Unexpected identifier')) {
                    errorMsg = `Syntax error: ${errorMsg}. Check for missing operators or semicolons.`;
                }
                
                return errorMsg;
            }
        }
        
        function saveTools() {
            localStorage.setItem('rescue-run-tools', JSON.stringify(currentTools));
        }
        
        function loadTools() {
            const saved = localStorage.getItem('rescue-run-tools');
            if (saved) {
                try {
                    currentTools = JSON.parse(saved);
                } catch (e) {
                    console.error('Failed to load saved tools:', e);
                    currentTools = JSON.parse(JSON.stringify(DEFAULT_TOOLS));
                }
            }
        }
        
        function resetTools() {
            if (confirm('Reset all tools to defaults? Your changes will be lost.')) {
                currentTools = JSON.parse(JSON.stringify(DEFAULT_TOOLS));
                localStorage.removeItem('rescue-run-tools');
                renderToolsList();
            }
        }
        
        // ===========================================
        // SYSTEM PROMPT
        // ===========================================
        
        const DEFAULT_SYSTEM_PROMPT = `You are controlling a rescue vehicle. Your goal is to rescue the person and bring them to the safe zone.

Use your available tools to:
1. Explore and understand your environment
2. Find and pick up the person
3. Navigate to the safe zone
4. Drop off the person to complete the rescue

Good luck!`;
        
        function saveSystemPrompt() {
            const prompt = document.getElementById('system-prompt').value;
            localStorage.setItem('rescue-run-system-prompt', prompt);
        }
        
        function loadSystemPrompt() {
            const saved = localStorage.getItem('rescue-run-system-prompt');
            if (saved) {
                document.getElementById('system-prompt').value = saved;
            } else {
                // Set default if nothing saved
                document.getElementById('system-prompt').value = DEFAULT_SYSTEM_PROMPT;
            }
        }
        
        function getSystemPrompt() {
            return document.getElementById('system-prompt').value.trim();
        }

        // ===========================================
        // UI SETUP
        // ===========================================
        
        function setupUI() {
            // Level selector
            setupLevelSelector();
            
            // Reset button
            document.getElementById('btn-reset').addEventListener('click', () => {
                resetGame();
            });
            
            // AI buttons
            document.getElementById('btn-run-ai').addEventListener('click', () => {
                runAI();
            });
            
            document.getElementById('btn-stop-ai').addEventListener('click', () => {
                stopAI();
            });
            
            // Tool editor buttons
            document.getElementById('btn-add-tool').addEventListener('click', () => {
                addNewTool();
            });
            document.getElementById('btn-reset-tools').addEventListener('click', () => {
                resetTools();
            });
            
            // System prompt auto-save on blur
            document.getElementById('system-prompt').addEventListener('blur', () => {
                saveSystemPrompt();
            });
            
            // Review panel buttons
            document.getElementById('btn-edit-after-review').addEventListener('click', () => {
                setUiMode('idle');
                if (currentTools.length > 0) {
                    toggleToolExpand(0);
                }
            });
            document.getElementById('btn-run-again').addEventListener('click', () => {
                resetGame();
                runAI();
            });
        }

        // ===========================================
        // INITIALIZATION & AUTH
        // ===========================================
        
        let currentUser = null;
        
        async function checkAuth() {
            try {
                const res = await fetch('/auth/me', { credentials: 'include' });
                if (!res.ok) {
                    return null;
                }
                const data = await res.json();
                return data.user;
            } catch (e) {
                console.error('Auth check failed:', e);
                return null;
            }
        }
        
        function showLoginPrompt() {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = `
                <div style="color: #ff9800;">‚ö†Ô∏è Login Required</div>
                <div style="font-size: 0.8rem; margin-top: 5px;">
                    <a href="/" style="color: #4fc3f7;">Go to login page</a>
                </div>
            `;
            statusEl.className = 'status';
            
            // Disable AI button
            document.getElementById('btn-run-ai').disabled = true;
            
            aiLog('Please login to use AI features', 'ai-error');
        }
        
        async function init() {
            // Load saved tools
            loadTools();
            renderToolsList();
            
            // Load saved system prompt
            loadSystemPrompt();
            
            // Load completed levels
            loadCompletedLevels();
            
            // v0.7: Load personal bests
            loadPersonalBests();
            
            // v0.7: Load last selected level
            const savedLevel = loadSelectedLevel();
            if (savedLevel !== 1) {
                selectLevel(savedLevel);
            }
            
            await loadAssets();
            render();
            setupUI();
            
            // Update level buttons with completion status
            updateLevelButtons();
            
            // Check authentication
            currentUser = await checkAuth();
            
            if (currentUser) {
                aiLog(`Logged in as ${currentUser.username}`, 'ai-result');
            } else {
                showLoginPrompt();
            }
        }

        init();
    </script>
</body>
</html>