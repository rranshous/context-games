<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rescue Run</title>
    <!-- CodeMirror for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .game-panel {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #e94560;
        }
        
        h2 {
            font-size: 1rem;
            margin-bottom: 10px;
            color: #0f3460;
            background: #e94560;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        #game-canvas {
            border: 3px solid #0f3460;
            border-radius: 8px;
            background: #2d4a3e;
            image-rendering: pixelated;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
        }
        
        .control-group {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 8px;
        }
        
        .control-group h3 {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button {
            background: #0f3460;
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
            width: 100%;
            margin-bottom: 5px;
        }
        
        button:hover {
            background: #e94560;
        }
        
        button:disabled {
            background: #333;
            cursor: not-allowed;
        }
        
        .direction-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }
        
        .direction-buttons button {
            padding: 10px;
            font-size: 1.2rem;
        }
        
        .direction-buttons .empty {
            visibility: hidden;
        }
        
        #log {
            background: #0a0a15;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
            color: #8f8;
        }
        
        #log .entry {
            margin-bottom: 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid #222;
        }
        
        #log .error {
            color: #f88;
        }
        
        #log .success {
            color: #8f8;
        }
        
        #log .info {
            color: #88f;
        }
        
        .status {
            font-size: 0.9rem;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }
        
        .status.playing {
            background: #0f3460;
        }
        
        .status.won {
            background: #2e7d32;
        }
        
        .legend {
            font-size: 0.8rem;
            color: #888;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .ai-panel {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 8px;
        }
        
        .ai-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .ai-controls button {
            flex: 1;
        }
        
        #btn-run-ai {
            background: #e94560;
        }
        
        #btn-run-ai:hover {
            background: #ff6b8a;
        }
        
        #btn-run-ai:disabled {
            background: #333;
        }
        
        #btn-stop-ai {
            background: #ff9800;
        }
        
        #btn-stop-ai:hover {
            background: #ffb74d;
        }
        
        #ai-log {
            background: #0a0a15;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.75rem;
            max-height: 300px;
            overflow-y: auto;
            color: #ccc;
        }
        
        #ai-log .ai-thinking {
            color: #ff9800;
            font-style: italic;
        }
        
        #ai-log .ai-tool {
            color: #4fc3f7;
        }
        
        #ai-log .ai-result {
            color: #8f8;
            margin-left: 10px;
        }
        
        #ai-log .ai-error {
            color: #f88;
        }
        
        .ai-status {
            font-size: 0.85rem;
            padding: 6px;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 8px;
            background: #333;
        }
        
        .ai-status.running {
            background: #e94560;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Tools List */
        #tools-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .tool-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        .tool-item .tool-name {
            font-family: monospace;
            color: #4fc3f7;
        }
        
        .tool-item button {
            padding: 4px 8px;
            font-size: 0.75rem;
        }
        
        #btn-edit-tools, #btn-reset-tools {
            padding: 8px 12px;
            font-size: 0.85rem;
        }
        
        #btn-reset-tools {
            background: #666;
        }
        
        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: #16213e;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #333;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.1rem;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
        }
        
        .close-btn:hover {
            color: #fff;
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85rem;
            color: #aaa;
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            background: #0a0a15;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            font-size: 0.9rem;
            box-sizing: border-box;
        }
        
        .form-group textarea {
            resize: vertical;
            font-family: monospace;
        }
        
        .stdlib-reference {
            margin-top: 10px;
        }
        
        .stdlib-reference summary {
            cursor: pointer;
            color: #4fc3f7;
            font-size: 0.85rem;
        }
        
        .stdlib-reference pre {
            background: #0a0a15;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            overflow-x: auto;
            margin: 10px 0 0 0;
        }
        
        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .modal-footer button {
            padding: 8px 16px;
        }
        
        #btn-save-tool {
            background: #4caf50;
        }
        
        #btn-save-tool:hover {
            background: #66bb6a;
        }
        
        #btn-cancel-edit {
            background: #666;
        }
        
        /* CodeMirror editor styling */
        #edit-implementation-wrapper {
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        #edit-implementation-wrapper .CodeMirror {
            height: 200px;
            font-size: 0.85rem;
        }
        
        /* Review Panel */
        .review-panel {
            margin-top: 15px;
            padding: 15px;
            background: #1a1a2e;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .review-panel h3 {
            margin: 0 0 12px 0;
            font-size: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .review-result {
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            margin-bottom: 12px;
        }
        
        .review-result.success {
            background: rgba(76, 175, 80, 0.2);
            color: #8f8;
        }
        
        .review-result.failure {
            background: rgba(233, 69, 96, 0.2);
            color: #f88;
        }
        
        .review-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .review-stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: #0a0a15;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        .review-stat-item .tool-name {
            font-family: monospace;
            color: #4fc3f7;
        }
        
        .review-stat-item .stat-counts {
            display: flex;
            gap: 10px;
            font-size: 0.8rem;
        }
        
        .review-stat-item .stat-counts .calls {
            color: #aaa;
        }
        
        .review-stat-item .stat-counts .success-count {
            color: #8f8;
        }
        
        .review-stat-item .stat-counts .fail-count {
            color: #f88;
        }
        
        .review-stat-item.never-used {
            opacity: 0.5;
        }
        
        .review-stat-item.never-used .tool-name::after {
            content: " (never used)";
            color: #888;
            font-style: italic;
        }
        
        .review-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
        }
        
        .review-actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.85rem;
        }
        
        .review-story {
            font-family: monospace;
            font-size: 0.8rem;
            color: #aaa;
            padding: 10px;
            background: #0a0a15;
            border-radius: 4px;
            margin-bottom: 10px;
            line-height: 1.6;
            word-wrap: break-word;
        }
        
        .review-story .story-fail {
            color: #f88;
        }
        
        .review-story .story-success {
            color: #8f8;
        }
        
        .review-tool-stats {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-panel">
            <h1>üöó Rescue Run</h1>
            <canvas id="game-canvas" width="256" height="256"></canvas>
            <div class="legend" style="margin-top: 10px;">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4a7c59;"></div>
                    <span>Grass</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #555;"></div>
                    <span>Road</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e94560;"></div>
                    <span>Person (rescue target)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4fc3f7;"></div>
                    <span>Safe Zone</span>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="game-panel">
                <h2>Status</h2>
                <div id="status" class="status playing">Ready</div>
                <button id="btn-reset" style="margin-top: 10px; display: none;">üîÑ Reset Game</button>
            </div>
            
            <div class="game-panel">
                <h2>ü§ñ AI Control</h2>
                <div class="ai-panel">
                    <div id="ai-status" class="ai-status">AI Ready</div>
                    <div class="ai-controls">
                        <button id="btn-run-ai">‚ñ∂Ô∏è Run AI</button>
                        <button id="btn-stop-ai" disabled>‚èπÔ∏è Stop</button>
                    </div>
                    <div id="ai-log"></div>
                    
                    <!-- Review Panel (hidden until run completes) -->
                    <div id="review-panel" class="review-panel" style="display: none;">
                        <h3>üìä Review <button id="btn-close-review" style="padding: 2px 8px; font-size: 0.75rem;">√ó</button></h3>
                        <div id="review-result" class="review-result"></div>
                        <div id="review-stats" class="review-stats"></div>
                        <div class="review-actions">
                            <button id="btn-edit-after-review">‚úèÔ∏è Edit Tools</button>
                            <button id="btn-run-again">‚ñ∂Ô∏è Run Again</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="game-panel">
                <h2>üîß Tools</h2>
                <div id="tools-list"></div>
                <div style="margin-top: 10px;">
                    <button id="btn-edit-tools">‚úèÔ∏è Edit Tools</button>
                    <button id="btn-reset-tools">‚Ü©Ô∏è Reset</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Tool Editor Modal -->
    <div id="tool-editor-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Edit Tool: <span id="edit-tool-name"></span></h2>
                <button id="btn-close-modal" class="close-btn">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Name:</label>
                    <input type="text" id="edit-name" />
                </div>
                <div class="form-group">
                    <label>Description (AI sees this):</label>
                    <textarea id="edit-description" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label>Parameters:</label>
                    <div id="edit-parameters"></div>
                </div>
                <div class="form-group">
                    <label>Implementation (JS using stdlib.*):</label>
                    <div id="edit-implementation-wrapper"></div>
                </div>
                <div class="stdlib-reference">
                    <details>
                        <summary>üìö Stdlib Reference</summary>
                        <pre>
Position/State:
  stdlib.getCarPosition()      ‚Üí {x, y}
  stdlib.getCarDirection()     ‚Üí "north"|"south"|"east"|"west"
  stdlib.getPersonPosition()   ‚Üí {x, y} or null
  stdlib.getSafeZonePosition() ‚Üí {x, y}
  stdlib.isPersonInCar()       ‚Üí boolean

Map:
  stdlib.getGridSize()         ‚Üí {width, height}
  stdlib.isValidPosition(x,y)  ‚Üí boolean
  stdlib.getTileAt(x,y)        ‚Üí {type, passable}

Actions:
  stdlib.moveCarOneStep(dir)   ‚Üí {success, error?}
  stdlib.pickupPerson()        ‚Üí {success, error?}
  stdlib.dropoffPerson()       ‚Üí {success, error?}
                        </pre>
                    </details>
                </div>
            </div>
            <div class="modal-footer">
                <button id="btn-cancel-edit">Cancel</button>
                <button id="btn-save-tool">üíæ Save Tool</button>
            </div>
        </div>
    </div>

    <script>
        // ===========================================
        // GAME CONSTANTS
        // ===========================================
        const TILE_SIZE = 32;
        const GRID_SIZE = 8;
        const CANVAS_SIZE = TILE_SIZE * GRID_SIZE;

        // Tile types
        const TILE = {
            GRASS: 0,
            ROAD: 1,
            BUILDING: 2
        };

        // ===========================================
        // GAME STATE
        // ===========================================
        const gameState = {
            // Car state
            car: { x: 1, y: 1, direction: 'east' },
            
            // Person to rescue
            person: { x: 6, y: 5, rescued: false },
            
            // Safe zone location
            safeZone: { x: 1, y: 6 },
            
            // Is person in car?
            personInCar: false,
            
            // Game status
            status: 'playing', // 'playing', 'won'
            
            // The map grid
            map: [
                // y=0 (top row)
                [0, 0, 0, 0, 0, 0, 0, 0],
                // y=1
                [0, 1, 1, 1, 1, 1, 1, 0],
                // y=2
                [0, 1, 0, 0, 0, 0, 1, 0],
                // y=3
                [0, 1, 0, 2, 2, 0, 1, 0],
                // y=4
                [0, 1, 0, 2, 2, 0, 1, 0],
                // y=5
                [0, 1, 1, 1, 1, 1, 1, 0],
                // y=6
                [0, 1, 0, 0, 0, 0, 1, 0],
                // y=7 (bottom row)
                [0, 0, 0, 0, 0, 0, 0, 0],
            ]
        };

        // ===========================================
        // ASSETS
        // ===========================================
        const assets = {
            carSprite: null,
            loaded: false
        };

        function loadAssets() {
            return new Promise((resolve, reject) => {
                const carImg = new Image();
                carImg.onload = () => {
                    assets.carSprite = carImg;
                    assets.loaded = true;
                    resolve();
                };
                carImg.onerror = () => {
                    assets.loaded = true;
                    resolve(); // Continue anyway with fallback rendering
                };
                carImg.src = 'assets/Cars/Player_blue%20(16%20x%2016).png';
            });
        }

        // ===========================================
        // RENDERING
        // ===========================================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        function render() {
            // Clear
            ctx.fillStyle = '#2d4a3e';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Draw tiles
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const tile = gameState.map[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;
                    
                    switch (tile) {
                        case TILE.GRASS:
                            ctx.fillStyle = '#4a7c59';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Add some texture
                            ctx.fillStyle = '#3d6b4a';
                            ctx.fillRect(px + 4, py + 4, 2, 2);
                            ctx.fillRect(px + 20, py + 12, 2, 2);
                            ctx.fillRect(px + 10, py + 24, 2, 2);
                            break;
                        case TILE.ROAD:
                            ctx.fillStyle = '#555';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Road markings
                            ctx.fillStyle = '#777';
                            ctx.fillRect(px, py, TILE_SIZE, 1);
                            ctx.fillRect(px, py + TILE_SIZE - 1, TILE_SIZE, 1);
                            break;
                        case TILE.BUILDING:
                            ctx.fillStyle = '#8b7355';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Building detail
                            ctx.fillStyle = '#6b5344';
                            ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#ffeb3b';
                            ctx.fillRect(px + 8, py + 8, 6, 6);
                            break;
                    }
                }
            }
            
            // Draw safe zone
            const sz = gameState.safeZone;
            ctx.fillStyle = 'rgba(79, 195, 247, 0.5)';
            ctx.fillRect(sz.x * TILE_SIZE, sz.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.strokeRect(sz.x * TILE_SIZE + 2, sz.y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
            // Safe zone icon
            ctx.fillStyle = '#4fc3f7';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üè†', sz.x * TILE_SIZE + TILE_SIZE/2, sz.y * TILE_SIZE + TILE_SIZE/2 + 5);
            
            // Draw person (if not rescued/in car)
            if (!gameState.personInCar && !gameState.person.rescued) {
                const p = gameState.person;
                ctx.fillStyle = '#e94560';
                ctx.beginPath();
                ctx.arc(p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2, 8, 0, Math.PI * 2);
                ctx.fill();
                // Person icon
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üßç', p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2 + 4);
            }
            
            // Draw car
            const car = gameState.car;
            const carX = car.x * TILE_SIZE + TILE_SIZE/2;
            const carY = car.y * TILE_SIZE + TILE_SIZE/2;
            
            ctx.save();
            ctx.translate(carX, carY);
            
            // Rotate based on direction (sprite faces north/up by default)
            const angles = { north: 0, east: Math.PI/2, south: Math.PI, west: -Math.PI/2 };
            ctx.rotate(angles[car.direction] || 0);
            
            if (assets.carSprite) {
                // Draw sprite (first frame, 16x16, scaled to ~24px)
                const scale = 1.5;
                const spriteSize = 16;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(
                    assets.carSprite,
                    0, 0, spriteSize, spriteSize,  // Source
                    -spriteSize * scale / 2, -spriteSize * scale / 2, spriteSize * scale, spriteSize * scale  // Dest
                );
            } else {
                // Fallback: draw a simple car shape
                ctx.fillStyle = '#2196f3';
                ctx.fillRect(-10, -6, 20, 12);
                ctx.fillStyle = '#1565c0';
                ctx.fillRect(6, -4, 4, 8);
            }
            
            ctx.restore();
            
            // If person is in car, show indicator
            if (gameState.personInCar) {
                ctx.fillStyle = '#e94560';
                ctx.font = '12px Arial';
                ctx.fillText('üßç', carX + 12, carY - 12);
            }
        }

        // ===========================================
        // ===========================================
        // STANDARD LIBRARY (stdlib)
        // Low-level game primitives for tool implementations
        // ===========================================
        /*
         * STDLIB API REFERENCE (for tool implementations)
         * 
         * Position/State:
         *   stdlib.getCarPosition()      ‚Üí {x, y}
         *   stdlib.getCarDirection()     ‚Üí "north"|"south"|"east"|"west"
         *   stdlib.getPersonPosition()   ‚Üí {x, y} or null if rescued
         *   stdlib.getSafeZonePosition() ‚Üí {x, y}
         *   stdlib.isPersonInCar()       ‚Üí boolean
         *   stdlib.isPersonRescued()     ‚Üí boolean
         * 
         * Map:
         *   stdlib.getGridSize()         ‚Üí {width, height}
         *   stdlib.isValidPosition(x,y)  ‚Üí boolean
         *   stdlib.getTileAt(x,y)        ‚Üí {type, passable}
         *                                  type: "grass"|"road"|"building"|"edge"
         * 
         * Actions:
         *   stdlib.moveCarOneStep(dir)   ‚Üí {success, error?}
         *   stdlib.pickupPerson()        ‚Üí {success, error?}
         *   stdlib.dropoffPerson()       ‚Üí {success, error?}
         */
        const stdlib = {
            // === Position/State ===
            getCarPosition: () => ({ x: gameState.car.x, y: gameState.car.y }),
            getCarDirection: () => gameState.car.direction,
            getPersonPosition: () => gameState.person.rescued ? null : { x: gameState.person.x, y: gameState.person.y },
            getSafeZonePosition: () => ({ x: gameState.safeZone.x, y: gameState.safeZone.y }),
            isPersonInCar: () => gameState.personInCar,
            isPersonRescued: () => gameState.person.rescued,
            
            // === Map ===
            getGridSize: () => ({ width: GRID_SIZE, height: GRID_SIZE }),
            isValidPosition: (x, y) => x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE,
            getTileAt: (x, y) => {
                if (!stdlib.isValidPosition(x, y)) {
                    return { type: 'edge', passable: false };
                }
                const tile = gameState.map[y][x];
                const typeNames = { [TILE.GRASS]: 'grass', [TILE.ROAD]: 'road', [TILE.BUILDING]: 'building' };
                return {
                    type: typeNames[tile] || 'unknown',
                    passable: tile === TILE.ROAD
                };
            },
            
            // === Actions ===
            moveCarOneStep: (direction) => {
                const moves = {
                    north: { dx: 0, dy: -1 },
                    south: { dx: 0, dy: 1 },
                    east: { dx: 1, dy: 0 },
                    west: { dx: -1, dy: 0 }
                };
                
                if (!moves[direction]) {
                    return { success: false, error: `Invalid direction: ${direction}` };
                }
                
                const move = moves[direction];
                const newX = gameState.car.x + move.dx;
                const newY = gameState.car.y + move.dy;
                
                // Always update facing direction
                gameState.car.direction = direction;
                
                if (!stdlib.isValidPosition(newX, newY)) {
                    return { success: false, error: 'Would go off the map' };
                }
                
                const tile = stdlib.getTileAt(newX, newY);
                if (!tile.passable) {
                    return { success: false, error: `${tile.type} is not passable` };
                }
                
                // Move the car
                gameState.car.x = newX;
                gameState.car.y = newY;
                return { success: true };
            },
            
            pickupPerson: () => {
                if (gameState.personInCar) {
                    return { success: false, error: 'Person already in car' };
                }
                if (gameState.person.rescued) {
                    return { success: false, error: 'Person already rescued' };
                }
                const car = gameState.car;
                const person = gameState.person;
                if (car.x !== person.x || car.y !== person.y) {
                    return { success: false, error: 'No person at current location' };
                }
                gameState.personInCar = true;
                return { success: true };
            },
            
            dropoffPerson: () => {
                if (!gameState.personInCar) {
                    return { success: false, error: 'No person in car' };
                }
                const car = gameState.car;
                const sz = gameState.safeZone;
                if (car.x !== sz.x || car.y !== sz.y) {
                    return { success: false, error: 'Not at safe zone' };
                }
                gameState.personInCar = false;
                gameState.person.rescued = true;
                gameState.status = 'won';
                checkWinCondition();
                return { success: true };
            }
        };

        // ===========================================
        // WIN DETECTION & RESET
        // ===========================================
        
        function checkWinCondition() {
            if (gameState.person.rescued) {
                gameState.status = 'won';
                const statusEl = document.getElementById('status');
                statusEl.textContent = 'üéâ RESCUE COMPLETE!';
                statusEl.className = 'status won';
                
                // Show reset button
                document.getElementById('btn-reset').style.display = 'block';
            }
        }
        
        function resetGame() {
            // Reset game state
            gameState.car = { x: 1, y: 1, direction: 'east' };
            gameState.person = { x: 6, y: 5, rescued: false };
            gameState.personInCar = false;
            gameState.status = 'playing';
            
            // Reset UI
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'Ready';
            statusEl.className = 'status playing';
            document.getElementById('btn-reset').style.display = 'none';
            
            // Clear AI log
            clearAiLog();
            aiLog('Game reset. Ready to run AI.', 'ai-result');
            
            render();
        }

        // ===========================================
        // AI INTEGRATION (Claude Haiku)
        // ===========================================
        
        // Tool definitions with implementations
        // Players can edit these - implementation is JS using stdlib.*
        const DEFAULT_TOOLS = [
            {
                name: "scan",
                description: "Look around and scan the surroundings. Returns your current position, the tile you're on, what direction you're facing, whether you have a person in the car, and what's in each cardinal direction (north, south, east, west) including tile type, whether it's passable, and if there's a person or safe zone there.",
                parameters: [],
                implementation: `
const pos = stdlib.getCarPosition();
const directions = ['north', 'south', 'east', 'west'];
const offsets = { north: [0, -1], south: [0, 1], east: [1, 0], west: [-1, 0] };

const surroundings = {};
for (const dir of directions) {
    const [dx, dy] = offsets[dir];
    const nx = pos.x + dx;
    const ny = pos.y + dy;
    const tile = stdlib.getTileAt(nx, ny);
    const info = { ...tile };
    
    const personPos = stdlib.getPersonPosition();
    if (personPos && personPos.x === nx && personPos.y === ny) {
        info.person_here = true;
    }
    
    const szPos = stdlib.getSafeZonePosition();
    if (szPos.x === nx && szPos.y === ny) {
        info.safe_zone_here = true;
    }
    
    surroundings[dir] = info;
}

const result = {
    current_position: pos,
    current_tile: stdlib.getTileAt(pos.x, pos.y).type,
    facing: stdlib.getCarDirection(),
    person_in_car: stdlib.isPersonInCar(),
    surroundings
};

const personPos = stdlib.getPersonPosition();
if (personPos && personPos.x === pos.x && personPos.y === pos.y) {
    result.person_at_current_location = true;
}
const szPos = stdlib.getSafeZonePosition();
if (szPos.x === pos.x && szPos.y === pos.y) {
    result.at_safe_zone = true;
}

return result;
`
            },
            {
                name: "move",
                description: "Move the car one tile in the specified direction. The car can only move on road tiles. Returns success status and your new position.",
                parameters: [
                    {
                        name: "direction",
                        type: "string",
                        enum: ["north", "south", "east", "west"],
                        description: "The direction to move: north (up), south (down), east (right), or west (left)",
                        required: true
                    }
                ],
                implementation: `
const result = stdlib.moveCarOneStep(input.direction);
if (result.success) {
    const pos = stdlib.getCarPosition();
    result.new_position = pos;
    result.facing = stdlib.getCarDirection();
    
    const personPos = stdlib.getPersonPosition();
    if (personPos && personPos.x === pos.x && personPos.y === pos.y) {
        result.person_at_current_location = true;
    }
    const szPos = stdlib.getSafeZonePosition();
    if (szPos.x === pos.x && szPos.y === pos.y) {
        result.at_safe_zone = true;
    }
}
return result;
`
            },
            {
                name: "pickup",
                description: "Pick up a person if they are at your current location. You must be on the same tile as the person to pick them up.",
                parameters: [],
                implementation: `
const result = stdlib.pickupPerson();
if (result.success) {
    result.message = 'Person picked up! Now take them to the safe zone.';
}
return result;
`
            },
            {
                name: "dropoff",
                description: "Drop off the person you're carrying. You must be at the safe zone and have a person in the car to drop them off. This completes the rescue!",
                parameters: [],
                implementation: `
const result = stdlib.dropoffPerson();
if (result.success) {
    result.message = 'Person dropped off at safe zone! RESCUE COMPLETE!';
}
return result;
`
            }
        ];
        
        // Current tools (can be modified by player)
        let currentTools = JSON.parse(JSON.stringify(DEFAULT_TOOLS));
        
        // Convert tool definitions to Claude API format
        function getClaudeTools() {
            return currentTools.map(tool => ({
                name: tool.name,
                description: tool.description,
                input_schema: {
                    type: "object",
                    properties: tool.parameters.reduce((props, param) => {
                        props[param.name] = {
                            type: param.type,
                            description: param.description
                        };
                        if (param.enum) {
                            props[param.name].enum = param.enum;
                        }
                        return props;
                    }, {}),
                    required: tool.parameters.filter(p => p.required).map(p => p.name)
                }
            }));
        }
        
        // Execute a tool by running its implementation
        function executeTool(toolName, toolInput) {
            const tool = currentTools.find(t => t.name === toolName);
            if (!tool) {
                return { error: `Unknown tool: ${toolName}` };
            }
            
            try {
                // Create a function from the implementation string
                // It has access to 'stdlib' and 'input'
                const fn = new Function('stdlib', 'input', tool.implementation);
                return fn(stdlib, toolInput || {});
            } catch (e) {
                return { error: `Tool execution error: ${e.message}` };
            }
        }
        
        // AI state
        const aiState = {
            running: false,
            messages: [],
            stopRequested: false,
            // Review tracking
            toolStats: {},      // { toolName: { calls: 0, successes: 0, failures: 0 } }
            toolHistory: [],    // [{ name: 'scan', args: {}, success: true }, ...]
            totalTurns: 0,
            result: null        // 'success' | 'failure' | 'stopped' | 'error'
        };
        
        function resetToolStats() {
            aiState.toolStats = {};
            aiState.toolHistory = [];
            aiState.totalTurns = 0;
            aiState.result = null;
            // Initialize stats for all tools
            currentTools.forEach(tool => {
                aiState.toolStats[tool.name] = { calls: 0, successes: 0, failures: 0 };
            });
        }
        
        function trackToolCall(toolName, toolInput, result) {
            if (!aiState.toolStats[toolName]) {
                aiState.toolStats[toolName] = { calls: 0, successes: 0, failures: 0 };
            }
            aiState.toolStats[toolName].calls++;
            const success = result.success !== false;
            if (success) {
                aiState.toolStats[toolName].successes++;
            } else {
                aiState.toolStats[toolName].failures++;
            }
            // Record in history
            aiState.toolHistory.push({ name: toolName, args: toolInput, success });
        }
        
        // AI logging
        const aiLogEl = document.getElementById('ai-log');
        
        function aiLog(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = type;
            entry.textContent = message;
            aiLogEl.appendChild(entry);
            aiLogEl.scrollTop = aiLogEl.scrollHeight;
        }
        
        function clearAiLog() {
            aiLogEl.innerHTML = '';
        }
        
        // Build minimal system prompt - AI must discover through tools
        function buildSystemPrompt() {
            return `You are controlling a rescue vehicle. Your goal is to rescue the person and bring them to the safe zone.

Use your available tools to:
1. Explore and understand your environment
2. Find and pick up the person
3. Navigate to the safe zone
4. Drop off the person to complete the rescue

Good luck!`;
        }
        
        // Call Claude API via vanilla platform proxy
        async function callClaude(messages) {
            const response = await fetch('/api/inference/anthropic/messages', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    model: 'claude-haiku-4-5-20251001',
                    max_tokens: 1024,
                    system: buildSystemPrompt(),
                    tools: getClaudeTools(),
                    messages: messages
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                const errorMsg = error.error || 'API call failed';
                
                // Handle specific error types
                if (response.status === 401) {
                    throw new Error('AUTH_REQUIRED');
                } else if (errorMsg.toLowerCase().includes('token') || errorMsg.toLowerCase().includes('limit')) {
                    throw new Error('TOKEN_LIMIT');
                }
                throw new Error(errorMsg);
            }
            
            return await response.json();
        }
        
        // Main agentic loop
        async function runAI() {
            if (aiState.running) return;
            
            // Check auth before starting
            if (!currentUser) {
                aiLog('‚ùå Please login first', 'ai-error');
                return;
            }
            
            aiState.running = true;
            aiState.stopRequested = false;
            aiState.messages = [];
            
            // Reset tracking for review
            resetToolStats();
            hideReview();
            
            clearAiLog();
            updateAiStatus('Running...', true);
            
            document.getElementById('btn-run-ai').disabled = true;
            document.getElementById('btn-stop-ai').disabled = false;
            
            // Disable manual controls while AI runs
            document.querySelectorAll('.control-group button').forEach(btn => {
                btn.disabled = true;
            });
            
            aiLog('ü§ñ AI starting rescue mission...', 'ai-thinking');
            
            // Start with a user message asking to complete the rescue
            aiState.messages.push({
                role: 'user',
                content: 'Please rescue the person and bring them to the safe zone. Use the tools available to you. Start by scanning your surroundings to understand the situation.'
            });
            
            let iterations = 0;
            const maxIterations = 50; // Safety limit
            
            try {
                while (aiState.running && !aiState.stopRequested && iterations < maxIterations) {
                    iterations++;
                    
                    if (gameState.status === 'won') {
                        aiLog('üéâ RESCUE COMPLETE! Mission successful!', 'ai-result');
                        break;
                    }
                    
                    // Call Claude
                    aiLog(`[Turn ${iterations}] Thinking...`, 'ai-thinking');
                    const response = await callClaude(aiState.messages);
                    
                    // Process response
                    const assistantContent = response.content;
                    aiState.messages.push({ role: 'assistant', content: assistantContent });
                    
                    // Check if Claude wants to use tools
                    const toolUses = assistantContent.filter(block => block.type === 'tool_use');
                    const textBlocks = assistantContent.filter(block => block.type === 'text');
                    
                    // Log any text Claude says
                    for (const text of textBlocks) {
                        if (text.text.trim()) {
                            aiLog(`üí≠ ${text.text}`, 'ai-thinking');
                        }
                    }
                    
                    if (toolUses.length === 0) {
                        // No tool use, check if we're done
                        if (response.stop_reason === 'end_turn') {
                            aiLog('AI finished without completing rescue', 'ai-error');
                            break;
                        }
                    }
                    
                    // Execute each tool and collect results
                    const toolResults = [];
                    for (const toolUse of toolUses) {
                        aiLog(`üîß ${toolUse.name}(${JSON.stringify(toolUse.input)})`, 'ai-tool');
                        
                        const result = executeTool(toolUse.name, toolUse.input);
                        
                        // Track for review
                        trackToolCall(toolUse.name, toolUse.input, result);
                        
                        // Log result
                        if (result.success === false) {
                            aiLog(`   ‚ùå ${result.error}`, 'ai-error');
                        } else if (result.success === true) {
                            aiLog(`   ‚úÖ ${result.message || 'OK'}`, 'ai-result');
                        } else {
                            // Scan result - summarize it
                            aiLog(`   üìç Pos: (${result.current_position.x},${result.current_position.y})`, 'ai-result');
                        }
                        
                        toolResults.push({
                            type: 'tool_result',
                            tool_use_id: toolUse.id,
                            content: JSON.stringify(result)
                        });
                        
                        // Update display
                        render();
                        
                        // Small delay for visual feedback
                        await new Promise(r => setTimeout(r, 300));
                    }
                    
                    // Add tool results to messages
                    if (toolResults.length > 0) {
                        aiState.messages.push({ role: 'user', content: toolResults });
                    }
                    
                    // Small delay between turns
                    await new Promise(r => setTimeout(r, 200));
                }
                
                if (iterations >= maxIterations) {
                    aiLog('‚ö†Ô∏è Max iterations reached', 'ai-error');
                    aiState.result = 'failure';
                }
                
                // Set result based on game state
                if (gameState.status === 'won') {
                    aiState.result = 'success';
                } else if (aiState.stopRequested) {
                    aiState.result = 'stopped';
                } else if (!aiState.result) {
                    aiState.result = 'failure';
                }
                
                aiState.totalTurns = iterations;
                
            } catch (error) {
                aiState.result = 'error';
                aiState.totalTurns = iterations;
                
                // Handle specific error types with user-friendly messages
                if (error.message === 'AUTH_REQUIRED') {
                    aiLog('‚ùå Session expired. Please login again.', 'ai-error');
                    currentUser = null;
                    showLoginPrompt();
                } else if (error.message === 'TOKEN_LIMIT') {
                    aiLog('‚ùå Token limit reached! Contact admin for more tokens.', 'ai-error');
                } else {
                    aiLog(`‚ùå Error: ${error.message}`, 'ai-error');
                }
                console.error('AI error:', error);
            }
            
            // Cleanup
            aiState.running = false;
            updateAiStatus('AI Ready', false);
            document.getElementById('btn-run-ai').disabled = currentUser ? false : true;
            document.getElementById('btn-stop-ai').disabled = true;
            
            // Show review panel
            showReview();
        }
        
        function stopAI() {
            aiState.stopRequested = true;
            aiLog('‚èπÔ∏è Stop requested...', 'ai-thinking');
        }
        
        // ===========================================
        // REVIEW PANEL
        // ===========================================
        
        function showReview() {
            const panel = document.getElementById('review-panel');
            const resultEl = document.getElementById('review-result');
            const statsEl = document.getElementById('review-stats');
            
            // Result summary
            const resultMessages = {
                success: `‚úÖ SUCCESS! Rescued in ${aiState.totalTurns} turns`,
                failure: `‚ùå FAILED after ${aiState.totalTurns} turns`,
                stopped: `‚èπÔ∏è STOPPED at turn ${aiState.totalTurns}`,
                error: `‚ö†Ô∏è ERROR at turn ${aiState.totalTurns}`
            };
            
            resultEl.textContent = resultMessages[aiState.result] || 'Unknown result';
            resultEl.className = `review-result ${aiState.result === 'success' ? 'success' : 'failure'}`;
            
            // Build the story - compress consecutive same calls
            const story = buildToolStory(aiState.toolHistory);
            
            // Tool stats
            const toolNames = currentTools.map(t => t.name);
            let statsHtml = '';
            
            // Story section
            statsHtml += `<div class="review-story">${story}</div>`;
            
            // Stats per tool
            statsHtml += '<div class="review-tool-stats">';
            for (const toolName of toolNames) {
                const stats = aiState.toolStats[toolName] || { calls: 0, successes: 0, failures: 0 };
                const neverUsed = stats.calls === 0;
                
                statsHtml += `
                    <div class="review-stat-item ${neverUsed ? 'never-used' : ''}">
                        <span class="tool-name">${toolName}()</span>
                        <span class="stat-counts">
                            ${neverUsed ? '' : `
                                ${stats.failures > 0 ? `<span class="fail-count">‚úó${stats.failures}</span>` : ''}
                                ${stats.successes > 0 ? `<span class="success-count">‚úì${stats.successes}</span>` : ''}
                            `}
                        </span>
                    </div>
                `;
            }
            statsHtml += '</div>';
            
            statsEl.innerHTML = statsHtml;
            panel.style.display = 'block';
        }
        
        function buildToolStory(history) {
            if (!history || history.length === 0) return '<em>No tool calls</em>';
            
            const parts = [];
            let i = 0;
            
            while (i < history.length) {
                const call = history[i];
                let count = 1;
                
                // For move, group by same direction
                if (call.name === 'move') {
                    const dir = call.args?.direction;
                    while (i + count < history.length && 
                           history[i + count].name === 'move' && 
                           history[i + count].args?.direction === dir) {
                        count++;
                    }
                    const failCount = history.slice(i, i + count).filter(c => !c.success).length;
                    let text = `move(${dir})`;
                    if (count > 1) text += `√ó${count}`;
                    if (failCount > 0) text = `<span class="story-fail">${text}</span>`;
                    parts.push(text);
                }
                // For scan, just count consecutive scans
                else if (call.name === 'scan') {
                    while (i + count < history.length && history[i + count].name === 'scan') {
                        count++;
                    }
                    let text = 'scan';
                    if (count > 1) text += `√ó${count}`;
                    parts.push(text);
                }
                // For pickup/dropoff, show success/fail
                else {
                    let text = call.name;
                    if (!call.success) text = `<span class="story-fail">${text}!</span>`;
                    else text = `<span class="story-success">${text}‚úì</span>`;
                    parts.push(text);
                }
                
                i += count;
            }
            
            return parts.join(' ‚Üí ');
        }
        
        function hideReview() {
            document.getElementById('review-panel').style.display = 'none';
        }
        
        function updateAiStatus(text, running) {
            const statusEl = document.getElementById('ai-status');
            statusEl.textContent = text;
            statusEl.className = running ? 'ai-status running' : 'ai-status';
        }

        // ===========================================
        // TOOL EDITOR
        // ===========================================
        
        let editingToolIndex = -1;
        let codeEditor = null; // CodeMirror instance
        
        function renderToolsList() {
            const listEl = document.getElementById('tools-list');
            listEl.innerHTML = currentTools.map((tool, i) => `
                <div class="tool-item">
                    <span class="tool-name">${tool.name}(${tool.parameters.map(p => p.name).join(', ')})</span>
                    <button onclick="openToolEditor(${i})">Edit</button>
                </div>
            `).join('');
        }
        
        function initCodeEditor() {
            const wrapper = document.getElementById('edit-implementation-wrapper');
            wrapper.innerHTML = '';
            codeEditor = CodeMirror(wrapper, {
                mode: 'javascript',
                theme: 'dracula',
                lineNumbers: true,
                lineWrapping: true,
                tabSize: 2,
                indentWithTabs: false
            });
        }
        
        function openToolEditor(index) {
            editingToolIndex = index;
            const tool = currentTools[index];
            
            document.getElementById('edit-tool-name').textContent = tool.name;
            document.getElementById('edit-name').value = tool.name;
            document.getElementById('edit-description').value = tool.description;
            
            // Initialize CodeMirror if not already done
            if (!codeEditor) {
                initCodeEditor();
            }
            codeEditor.setValue(tool.implementation.trim());
            
            // Render parameters (simplified - just show as text for now)
            const paramsEl = document.getElementById('edit-parameters');
            if (tool.parameters.length === 0) {
                paramsEl.innerHTML = '<em style="color: #666;">None</em>';
            } else {
                paramsEl.innerHTML = tool.parameters.map(p => 
                    `<code style="background: #0a0a15; padding: 2px 6px; border-radius: 2px; margin-right: 5px;">${p.name}: ${p.type}</code>`
                ).join('');
            }
            
            document.getElementById('tool-editor-modal').style.display = 'flex';
            
            // Refresh CodeMirror after modal is visible
            setTimeout(() => codeEditor.refresh(), 10);
        }
        
        function closeToolEditor() {
            document.getElementById('tool-editor-modal').style.display = 'none';
            editingToolIndex = -1;
        }
        
        function saveTool() {
            if (editingToolIndex < 0) return;
            
            const tool = currentTools[editingToolIndex];
            tool.name = document.getElementById('edit-name').value;
            tool.description = document.getElementById('edit-description').value;
            tool.implementation = codeEditor.getValue();
            
            // Save to localStorage
            saveTools();
            renderToolsList();
            closeToolEditor();
        }
        
        function saveTools() {
            localStorage.setItem('rescue-run-tools', JSON.stringify(currentTools));
        }
        
        function loadTools() {
            const saved = localStorage.getItem('rescue-run-tools');
            if (saved) {
                try {
                    currentTools = JSON.parse(saved);
                } catch (e) {
                    console.error('Failed to load saved tools:', e);
                    currentTools = JSON.parse(JSON.stringify(DEFAULT_TOOLS));
                }
            }
        }
        
        function resetTools() {
            if (confirm('Reset all tools to defaults? Your changes will be lost.')) {
                currentTools = JSON.parse(JSON.stringify(DEFAULT_TOOLS));
                localStorage.removeItem('rescue-run-tools');
                renderToolsList();
            }
        }

        // ===========================================
        // UI SETUP
        // ===========================================
        
        function setupUI() {
            // Reset button
            document.getElementById('btn-reset').addEventListener('click', () => {
                resetGame();
            });
            
            // AI buttons
            document.getElementById('btn-run-ai').addEventListener('click', () => {
                runAI();
            });
            
            document.getElementById('btn-stop-ai').addEventListener('click', () => {
                stopAI();
            });
            
            // Tool editor buttons
            document.getElementById('btn-edit-tools').addEventListener('click', () => {
                if (currentTools.length > 0) {
                    openToolEditor(0);
                }
            });
            
            document.getElementById('btn-reset-tools').addEventListener('click', () => {
                resetTools();
            });
            
            // Modal buttons
            document.getElementById('btn-close-modal').addEventListener('click', closeToolEditor);
            document.getElementById('btn-cancel-edit').addEventListener('click', closeToolEditor);
            document.getElementById('btn-save-tool').addEventListener('click', saveTool);
            
            // Close modal on background click
            document.getElementById('tool-editor-modal').addEventListener('click', (e) => {
                if (e.target.id === 'tool-editor-modal') {
                    closeToolEditor();
                }
            });
            
            // Review panel buttons
            document.getElementById('btn-close-review').addEventListener('click', hideReview);
            document.getElementById('btn-edit-after-review').addEventListener('click', () => {
                if (currentTools.length > 0) {
                    openToolEditor(0);
                }
            });
            document.getElementById('btn-run-again').addEventListener('click', () => {
                resetGame();
                hideReview();
                runAI();
            });
        }

        // ===========================================
        // INITIALIZATION & AUTH
        // ===========================================
        
        let currentUser = null;
        
        async function checkAuth() {
            try {
                const res = await fetch('/auth/me', { credentials: 'include' });
                if (!res.ok) {
                    return null;
                }
                const data = await res.json();
                return data.user;
            } catch (e) {
                console.error('Auth check failed:', e);
                return null;
            }
        }
        
        function showLoginPrompt() {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = `
                <div style="color: #ff9800;">‚ö†Ô∏è Login Required</div>
                <div style="font-size: 0.8rem; margin-top: 5px;">
                    <a href="/" style="color: #4fc3f7;">Go to login page</a>
                </div>
            `;
            statusEl.className = 'status';
            
            // Disable AI button
            document.getElementById('btn-run-ai').disabled = true;
            
            aiLog('Please login to use AI features', 'ai-error');
        }
        
        async function init() {
            // Load saved tools
            loadTools();
            renderToolsList();
            
            await loadAssets();
            render();
            setupUI();
            
            // Check authentication
            currentUser = await checkAuth();
            
            if (currentUser) {
                aiLog(`Logged in as ${currentUser.username}`, 'ai-result');
            } else {
                showLoginPrompt();
            }
        }

        init();
    </script>
</body>
</html>