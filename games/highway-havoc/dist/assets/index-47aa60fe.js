(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const a of s)if(a.type==="childList")for(const r of a.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&i(r)}).observe(document,{childList:!0,subtree:!0});function e(s){const a={};return s.integrity&&(a.integrity=s.integrity),s.referrerPolicy&&(a.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?a.credentials="include":s.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function i(s){if(s.ep)return;s.ep=!0;const a=e(s);fetch(s.href,a)}})();class h{constructor(t=0,e=0){this.x=t,this.y=e}add(t){return new h(this.x+t.x,this.y+t.y)}multiply(t){return new h(this.x*t,this.y*t)}clone(){return new h(this.x,this.y)}distance(t){const e=this.x-t.x,i=this.y-t.y;return Math.sqrt(e*e+i*i)}}class f{constructor(t){this.angle=0,this.basePosition=t}update(t,e){(Math.abs(t)>.1||Math.abs(e)>.1)&&(this.angle=Math.atan2(e,t))}getPosition(){return this.basePosition.clone()}getBarrelEnd(){return new h(this.basePosition.x+Math.cos(this.angle)*25,this.basePosition.y+Math.sin(this.angle)*25)}render(t){t.save(),t.translate(this.basePosition.x,this.basePosition.y),t.rotate(this.angle),t.fillStyle="#34495e",t.fillRect(-8,-8,16,16),t.fillStyle="#e74c3c",t.fillRect(0,-3,25,6),t.fillStyle="#f39c12",t.fillRect(22,-4,6,8),t.restore()}}class u{constructor(t,e){this.angle=0,this.speed=0,this.maxSpeed=200,this.acceleration=300,this.friction=.9,this.position=new h(t,e),this.velocity=new h(0,0),this.turret=new f(this.position)}update(t,e,i,s,a){const n=e*2*Math.PI*t;this.angle+=n;const l=-i*this.acceleration*t,p=new h(Math.sin(this.angle)*l,-Math.cos(this.angle)*l);this.velocity=this.velocity.add(p),this.velocity=this.velocity.multiply(this.friction);const c=this.velocity.distance(new h(0,0));c>this.maxSpeed&&(this.velocity=this.velocity.multiply(this.maxSpeed/c)),this.position=this.position.add(this.velocity.multiply(t)),this.turret=new f(this.position),this.turret.update(s,a)}render(t){t.save(),t.translate(this.position.x,this.position.y),t.rotate(this.angle),t.fillStyle="#e74c3c",t.fillRect(-15,-8,30,16),t.fillStyle="#f39c12",t.fillRect(12,-2,8,4),t.restore(),this.turret.render(t)}}class m{constructor(t){this.segments=[],this.segmentHeight=100,this.roadWidth=400,this.scrollSpeed=150,this.canvasHeight=t,this.generateInitialSegments()}generateInitialSegments(){const t=Math.ceil(this.canvasHeight/this.segmentHeight)+2;for(let e=0;e<t;e++)this.segments.push({y:e*this.segmentHeight,width:this.roadWidth,color:this.getRoadColor(e)})}getRoadColor(t){const e=["#2c3e50","#34495e","#2c3e50"];return e[t%e.length]}update(t){for(const e of this.segments)e.y+=this.scrollSpeed*t;for(this.segments=this.segments.filter(e=>e.y<this.canvasHeight+this.segmentHeight);this.segments.length<Math.ceil(this.canvasHeight/this.segmentHeight)+2;){const i=this.segments[this.segments.length-1].y-this.segmentHeight;this.segments.unshift({y:i,width:this.roadWidth,color:this.getRoadColor(Math.floor(-i/this.segmentHeight))})}}render(t,e){const i=(e-this.roadWidth)/2;for(const s of this.segments)t.fillStyle=s.color,t.fillRect(i,s.y,this.roadWidth,this.segmentHeight);t.fillStyle="#f39c12",t.fillRect(i+this.roadWidth/2-2,0,4,this.canvasHeight),t.fillStyle="#95a5a6",t.fillRect(i-4,0,4,this.canvasHeight),t.fillRect(i+this.roadWidth,0,4,this.canvasHeight)}getRoadBounds(t){const e=(t-this.roadWidth)/2;return{left:e,right:e+this.roadWidth}}isOnRoad(t,e){const i=this.getRoadBounds(e);return t>=i.left&&t<=i.right}}class b{constructor(t,e){this.active=!0,this.speed=400,this.position=t.clone(),this.velocity=new h(Math.cos(e)*this.speed,Math.sin(e)*this.speed)}update(t){this.position=this.position.add(this.velocity.multiply(t)),(this.position.x<-50||this.position.x>850||this.position.y<-50||this.position.y>650)&&(this.active=!1)}render(t){t.fillStyle="#f1c40f",t.fillRect(this.position.x-2,this.position.y-2,4,4)}}class y{constructor(){this.projectiles=[],this.lastShotTime=0,this.fireRate=.2}shoot(t,e,i){return i-this.lastShotTime>=this.fireRate?(this.projectiles.push(new b(t,e)),this.lastShotTime=i,!0):!1}update(t){for(const e of this.projectiles)e.update(t);this.projectiles=this.projectiles.filter(e=>e.active)}render(t){for(const e of this.projectiles)e.render(t)}getProjectiles(){return this.projectiles}getProjectileCount(){return this.projectiles.length}}class k{constructor(t,e){this.active=!0,this.health=1,this.speed=80,this.position=new h(t,e),this.velocity=new h(0,0)}update(t,e){if(!this.active)return;const i=e.clone().add(this.position.multiply(-1)),s=i.distance(new h(0,0));s>0&&(i.x/=s,i.y/=s,this.velocity=i.multiply(this.speed)),this.position=this.position.add(this.velocity.multiply(t))}takeDamage(){this.health--,this.health<=0&&(this.active=!1)}render(t){this.active&&(t.fillStyle="#e67e22",t.fillRect(this.position.x-12,this.position.y-6,24,12),t.fillStyle="#f39c12",t.fillRect(this.position.x-15,this.position.y-2,4,4))}}class v{constructor(t,e){this.enemies=[],this.spawnTimer=0,this.spawnInterval=2,this.canvasWidth=t,this.canvasHeight=e}update(t,e){this.spawnTimer+=t,this.spawnTimer>=this.spawnInterval&&(this.spawnEnemy(),this.spawnTimer=0);for(const i of this.enemies)i.update(t,e);this.enemies=this.enemies.filter(i=>i.active)}spawnEnemy(){const t=Math.floor(Math.random()*4);let e,i;switch(t){case 0:e=Math.random()*this.canvasWidth,i=-20;break;case 1:e=this.canvasWidth+20,i=Math.random()*this.canvasHeight;break;case 2:e=Math.random()*this.canvasWidth,i=this.canvasHeight+20;break;case 3:e=-20,i=Math.random()*this.canvasHeight;break;default:e=0,i=0}this.enemies.push(new k(e,i))}render(t){for(const e of this.enemies)e.render(t)}getEnemies(){return this.enemies}checkCollisions(t){for(const e of t)for(const i of this.enemies)i.active&&this.checkProjectileEnemyCollision(e,i)&&(i.takeDamage(),e.active=!1)}checkProjectileEnemyCollision(t,e){const i=t.position.x-e.position.x,s=t.position.y-e.position.y;return Math.sqrt(i*i+s*s)<15}getEnemyCount(){return this.enemies.length}}class H{constructor(t,e,i="mine"){this.active=!0,this.position=new h(t,e),this.type=i,this.size=i==="mine"?8:i==="barrier"?20:15}update(t){this.position.y+=150*t}render(t){if(this.active)switch(this.type){case"mine":t.fillStyle="#e74c3c",t.fillRect(this.position.x-4,this.position.y-4,8,8);break;case"barrier":t.fillStyle="#f39c12",t.fillRect(this.position.x-10,this.position.y-2,20,4);break;case"pothole":t.fillStyle="#34495e",t.fillRect(this.position.x-7,this.position.y-7,14,14);break}}getBounds(){return{left:this.position.x-this.size/2,right:this.position.x+this.size/2,top:this.position.y-this.size/2,bottom:this.position.y+this.size/2}}}class w{constructor(t,e,i){this.obstacles=[],this.spawnTimer=0,this.spawnInterval=1.5,this.roadLeft=t,this.roadRight=e,this.canvasHeight=i}update(t){this.spawnTimer+=t,this.spawnTimer>=this.spawnInterval&&(this.spawnObstacle(),this.spawnTimer=0);for(const e of this.obstacles)e.update(t);this.obstacles=this.obstacles.filter(e=>e.active&&e.position.y<this.canvasHeight+50)}spawnObstacle(){const t=["mine","barrier","pothole"],e=t[Math.floor(Math.random()*t.length)],i=this.roadRight-this.roadLeft,s=this.roadLeft+Math.random()*i,a=-20;this.obstacles.push(new H(s,a,e))}render(t){for(const e of this.obstacles)e.render(t)}checkVehicleCollisions(t){for(const e of this.obstacles)if(e.active&&this.checkCollision(t,e.getBounds()))return e.active=!1,!0;return!1}checkProjectileCollisions(t){let e=0;for(const i of t)if(i.active){for(const s of this.obstacles)if(s.active&&s.type==="barrier"&&this.checkCollision(i.position,s.getBounds())){s.active=!1,i.active=!1,e++;break}}return e}checkCollision(t,e){if(t.x!==void 0){const i=t.x,s=t.y;return i>=e.left&&i<=e.right&&s>=e.top&&s<=e.bottom}else return!(t.right<e.left||t.left>e.right||t.bottom<e.top||t.top>e.bottom)}getObstacleCount(){return this.obstacles.length}}class R{constructor(t,e,i){this.active=!0,this.size=12,this.position=new h(t,e),this.type=i}update(t){this.position.y+=150*t,this.position.y+=Math.sin(performance.now()/500)*.5}render(t){if(this.active)switch(this.type){case"health":t.fillStyle="#e74c3c",t.fillRect(this.position.x-6,this.position.y-6,12,12),t.fillStyle="#fff",t.fillRect(this.position.x-2,this.position.y-2,4,4);break;case"ammo":t.fillStyle="#f39c12",t.fillRect(this.position.x-6,this.position.y-6,12,12);break;case"speed":t.fillStyle="#27ae60",t.fillRect(this.position.x-6,this.position.y-6,12,12),t.fillStyle="#fff",t.fillRect(this.position.x-1,this.position.y-3,2,6);break;case"damage":t.fillStyle="#e67e22",t.fillRect(this.position.x-6,this.position.y-6,12,12),t.fillStyle="#fff",t.fillRect(this.position.x-3,this.position.y-1,6,2);break;case"armor":t.fillStyle="#34495e",t.fillRect(this.position.x-6,this.position.y-6,12,12),t.fillStyle="#95a5a6",t.fillRect(this.position.x-4,this.position.y-4,8,8);break}}getBounds(){return{left:this.position.x-this.size/2,right:this.position.x+this.size/2,top:this.position.y-this.size/2,bottom:this.position.y+this.size/2}}}class x{constructor(t,e,i){this.pickups=[],this.spawnTimer=0,this.spawnInterval=3,this.roadLeft=t,this.roadRight=e,this.canvasHeight=i}update(t){this.spawnTimer+=t,this.spawnTimer>=this.spawnInterval&&(this.spawnPickup(),this.spawnTimer=0);for(const e of this.pickups)e.update(t);this.pickups=this.pickups.filter(e=>e.active&&e.position.y<this.canvasHeight+50)}spawnPickup(){const t=["health","ammo","speed","damage","armor"],e=t[Math.floor(Math.random()*t.length)],i=this.roadRight-this.roadLeft,s=this.roadLeft+Math.random()*i,a=-20;this.pickups.push(new R(s,a,e))}render(t){for(const e of this.pickups)e.render(t)}checkVehicleCollisions(t){for(const e of this.pickups)if(e.active&&this.checkCollision(t,e.getBounds())){const i=e.type;return e.active=!1,i}return null}checkCollision(t,e){return!(t.right<e.left||t.left>e.right||t.bottom<e.top||t.top>e.bottom)}getPickupCount(){return this.pickups.length}}class S{constructor(){this.upgrades={maxHealth:100,currentHealth:100,speedBoost:1,damageMultiplier:1,fireRate:.2,armor:0},this.powerUps=new Map}upgradeHealth(t=25){this.upgrades.maxHealth+=t,this.upgrades.currentHealth=Math.min(this.upgrades.currentHealth+t,this.upgrades.maxHealth)}upgradeSpeed(t=1.2){this.upgrades.speedBoost*=t}upgradeDamage(t=1.5){this.upgrades.damageMultiplier*=t}upgradeFireRate(t=1.5){this.upgrades.fireRate/=t}upgradeArmor(t=1){this.upgrades.armor+=t}addPowerUp(t,e,i){this.powerUps.set(t,{duration:e,effect:i})}takeDamage(t){const e=Math.max(0,t-this.upgrades.armor);return this.upgrades.currentHealth-=e,this.upgrades.currentHealth<0&&(this.upgrades.currentHealth=0),e}heal(t){this.upgrades.currentHealth=Math.min(this.upgrades.currentHealth+t,this.upgrades.maxHealth)}update(t){for(const[e,i]of this.powerUps)i.duration-=t,i.duration<=0&&this.powerUps.delete(e)}getUpgrades(){return{...this.upgrades}}getEffectiveSpeed(t){let e=t*this.upgrades.speedBoost;return this.powerUps.has("speed")&&(e*=1.5),e}getEffectiveDamage(t){let e=t*this.upgrades.damageMultiplier;return this.powerUps.has("damage")&&(e*=2),e}getEffectiveFireRate(){let t=this.upgrades.fireRate;return this.powerUps.has("rapidFire")&&(t*=.5),t}hasPowerUp(t){return this.powerUps.has(t)}getPowerUpTime(t){const e=this.powerUps.get(t);return e?e.duration:0}}class P{constructor(t){this.running=!1,this.score=0,this.gameState="menu",this.highScore=0,this.lastTime=0,this.gamepads=[],this.lastGamepadStates=[],this.gameLoop=()=>{if(!this.running)return;const i=performance.now(),s=this.lastTime?(i-this.lastTime)/1e3:0;switch(this.lastTime=i,this.updateGamepads(),this.gameState){case"menu":this.updateMenu();break;case"playing":this.update(s);break;case"gameOver":this.updateGameOver();break}this.render(),requestAnimationFrame(this.gameLoop)},this.canvas=t;const e=t.getContext("2d");if(!e)throw new Error("Could not get 2D context");this.ctx=e,this.canvas.width=800,this.canvas.height=600,this.vehicle=new u(this.canvas.width/2,this.canvas.height-100),this.road=new m(this.canvas.height),this.projectileManager=new y,this.enemyManager=new v(this.canvas.width,this.canvas.height),this.obstacleManager=new w((this.canvas.width-400)/2,(this.canvas.width+400)/2,this.canvas.height),this.pickupManager=new x((this.canvas.width-400)/2,(this.canvas.width+400)/2,this.canvas.height),this.upgradeSystem=new S,this.highScore=parseInt(localStorage.getItem("highwayHavoc_highScore")||"0"),this.setupEventListeners()}setupEventListeners(){window.addEventListener("gamepadconnected",t=>{console.log(`Gamepad ${t.gamepad.index} connected: ${t.gamepad.id}`),this.gamepads[t.gamepad.index]=t.gamepad}),window.addEventListener("gamepaddisconnected",t=>{console.log(`Gamepad ${t.gamepad.index} disconnected`),this.gamepads[t.gamepad.index]=null})}start(){this.running=!0,this.gameLoop()}stop(){this.running=!1}updateGamepads(){const t=navigator.getGamepads();for(let e=0;e<t.length;e++)this.lastGamepadStates[e]=this.gamepads[e],this.gamepads[e]=t[e]}update(t){var g;this.road.update(t);const e=this.gamepads[0];let i=0,s=0;e&&(i=e.axes[0]||0,s=e.axes[1]||0,Math.abs(i)<.1&&(i=0),Math.abs(s)<.1&&(s=0));const a=this.gamepads[1];let r=0,n=0,d=!1;if(a&&(r=a.axes[2]||0,n=a.axes[3]||0,d=(((g=a.buttons[7])==null?void 0:g.value)||0)>.5,Math.abs(r)<.1&&(r=0),Math.abs(n)<.1&&(n=0)),this.vehicle.update(t,i,s,r,n),d){const M=this.vehicle.turret.getBarrelEnd();this.projectileManager.shoot(M,this.vehicle.turret.angle,performance.now()/1e3)}this.projectileManager.update(t),this.enemyManager.update(t,this.vehicle.position),this.obstacleManager.update(t),this.pickupManager.update(t),this.upgradeSystem.update(t),this.enemyManager.checkCollisions(this.projectileManager.getProjectiles());const l=this.obstacleManager.checkProjectileCollisions(this.projectileManager.getProjectiles());this.score+=l*50;const p={left:this.vehicle.position.x-15,right:this.vehicle.position.x+15,top:this.vehicle.position.y-8,bottom:this.vehicle.position.y+8};this.obstacleManager.checkVehicleCollisions(p)&&this.upgradeSystem.takeDamage(20);const c=this.pickupManager.checkVehicleCollisions(p);c&&this.applyPickupEffect(c),this.vehicle.position.x=Math.max(50,Math.min(this.canvas.width-50,this.vehicle.position.x)),this.road.isOnRoad(this.vehicle.position.x,this.canvas.width)||(this.vehicle.velocity=this.vehicle.velocity.multiply(.95)),this.checkGameOver()}applyPickupEffect(t){switch(t){case"health":this.upgradeSystem.heal(25),this.score+=100;break;case"ammo":this.score+=50;break;case"speed":this.upgradeSystem.addPowerUp("speed",10,{multiplier:1.5}),this.score+=200;break;case"damage":this.upgradeSystem.addPowerUp("damage",15,{multiplier:2}),this.score+=200;break;case"armor":this.upgradeSystem.upgradeArmor(1),this.score+=300;break}}updateMenu(){var t;for(let e=0;e<this.gamepads.length;e++){const i=this.gamepads[e];if(i){for(let s=0;s<i.buttons.length;s++)if((t=i.buttons[s])!=null&&t.pressed){this.startGame();return}}}}updateGameOver(){var t;for(let e=0;e<this.gamepads.length;e++){const i=this.gamepads[e];if(i){for(let s=0;s<i.buttons.length;s++)if((t=i.buttons[s])!=null&&t.pressed){this.restartGame();return}}}}startGame(){this.gameState="playing",this.resetGame()}restartGame(){this.gameState="menu",this.resetGame()}resetGame(){this.vehicle=new u(this.canvas.width/2,this.canvas.height-100),this.road=new m(this.canvas.height),this.projectileManager=new y,this.enemyManager=new v(this.canvas.width,this.canvas.height),this.obstacleManager=new w((this.canvas.width-400)/2,(this.canvas.width+400)/2,this.canvas.height),this.pickupManager=new x((this.canvas.width-400)/2,(this.canvas.width+400)/2,this.canvas.height),this.upgradeSystem=new S,this.score=0}checkGameOver(){this.upgradeSystem.getUpgrades().currentHealth<=0&&(this.gameState="gameOver",this.score>this.highScore&&(this.highScore=this.score,localStorage.setItem("highwayHavoc_highScore",this.highScore.toString())))}render(){switch(this.ctx.fillStyle="#2c3e50",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.gameState){case"menu":this.renderMenu();break;case"playing":this.renderGame();break;case"gameOver":this.renderGameOver();break}}renderMenu(){this.ctx.fillStyle="#fff",this.ctx.font="48px monospace",this.ctx.textAlign="center",this.ctx.fillText("HIGHWAY HAVOC",this.canvas.width/2,200),this.ctx.font="24px monospace",this.ctx.fillText("Cooperative 2-Player Action",this.canvas.width/2,250),this.ctx.font="18px monospace",this.ctx.fillText("Player 1: Left stick to drive",this.canvas.width/2,300),this.ctx.fillText("Player 2: Right stick to aim, trigger to shoot",this.canvas.width/2,325),this.ctx.fillText(`High Score: ${this.highScore}`,this.canvas.width/2,375),this.ctx.font="20px monospace",this.ctx.fillText("Press any button to start",this.canvas.width/2,425),this.ctx.textAlign="left"}renderGame(){this.road.render(this.ctx,this.canvas.width),this.obstacleManager.render(this.ctx),this.pickupManager.render(this.ctx),this.enemyManager.render(this.ctx),this.projectileManager.render(this.ctx),this.vehicle.render(this.ctx),this.drawGamepadStatus(),this.ctx.fillStyle="#fff",this.ctx.font="16px monospace",this.ctx.fillText("Highway Havoc",20,30);const t=this.upgradeSystem.getUpgrades(),e=Math.round(this.vehicle.velocity.distance(new h(0,0)));this.ctx.fillText(`Speed: ${e}`,20,50),this.ctx.fillText(`Health: ${t.currentHealth}/${t.maxHealth}`,20,70),this.ctx.fillText(`Score: ${this.score}`,20,90);let i=110;this.upgradeSystem.hasPowerUp("speed")&&(this.ctx.fillStyle="#27ae60",this.ctx.fillText(`SPEED: ${Math.ceil(this.upgradeSystem.getPowerUpTime("speed"))}s`,20,i),i+=20,this.ctx.fillStyle="#fff"),this.upgradeSystem.hasPowerUp("damage")&&(this.ctx.fillStyle="#e67e22",this.ctx.fillText(`DAMAGE: ${Math.ceil(this.upgradeSystem.getPowerUpTime("damage"))}s`,20,i),i+=20,this.ctx.fillStyle="#fff")}renderGameOver(){this.renderGame(),this.ctx.fillStyle="rgba(0, 0, 0, 0.7)",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.ctx.fillStyle="#fff",this.ctx.font="48px monospace",this.ctx.textAlign="center",this.ctx.fillText("GAME OVER",this.canvas.width/2,250),this.ctx.font="24px monospace",this.ctx.fillText(`Final Score: ${this.score}`,this.canvas.width/2,300),this.ctx.fillText(`High Score: ${this.highScore}`,this.canvas.width/2,330),this.ctx.font="20px monospace",this.ctx.fillText("Press any button to return to menu",this.canvas.width/2,380),this.ctx.textAlign="left"}drawGamepadStatus(){this.ctx.fillStyle="#fff",this.ctx.font="14px monospace";let t=100;for(let e=0;e<2;e++){const i=this.gamepads[e],s=i?`Connected: ${i.id.slice(0,20)}`:"Not Connected";this.ctx.fillText(`Player ${e+1}: ${s}`,50,t),t+=20}}}const j=document.getElementById("game-canvas"),G=new P(j);G.start();
