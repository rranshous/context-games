<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oneshot Climb</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Controller prompt overlay */
        #controller-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff8e7;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #controller-prompt.hidden {
            opacity: 0;
        }

        /* Explorer Panel */
        #explorer-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: #1a1a2e;
            border-left: 2px solid #5d4e37;
            font-family: monospace;
            font-size: 12px;
            color: #fff8e7;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        #explorer-panel.collapsed {
            transform: translateX(280px);
        }

        #explorer-toggle {
            position: absolute;
            left: -32px;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 80px;
            background: #1a1a2e;
            border: 2px solid #5d4e37;
            border-right: none;
            border-radius: 8px 0 0 8px;
            color: #f4d03f;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        #explorer-header {
            padding: 12px;
            background: #2a2a4e;
            border-bottom: 1px solid #5d4e37;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #explorer-header h3 {
            margin: 0;
            color: #f4d03f;
            font-size: 14px;
        }

        #explorer-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            background: #4a3728;
        }

        #explorer-status.running { background: #7d9f5a; color: #1a1a2e; }
        #explorer-status.error { background: #c45c4a; }

        #explorer-state {
            padding: 12px;
            border-bottom: 1px solid #5d4e37;
            flex-shrink: 0;
        }

        #explorer-state h4 {
            margin: 0 0 8px 0;
            color: #a8c0b0;
            font-size: 11px;
            text-transform: uppercase;
        }

        .state-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 12px;
        }

        .state-label { color: #6b8fa3; }
        .state-value { color: #fff8e7; text-align: right; }

        #explorer-observations {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            border-bottom: 1px solid #5d4e37;
        }

        #explorer-observations h4 {
            margin: 0 0 8px 0;
            color: #a8c0b0;
            font-size: 11px;
            text-transform: uppercase;
        }

        .observation {
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            background: #2a2a4e;
        }

        .observation.success { border-left: 3px solid #7d9f5a; }
        .observation.failure { border-left: 3px solid #c45c4a; }
        .observation.info { border-left: 3px solid #6b8fa3; }

        #explorer-log {
            height: 120px;
            overflow-y: auto;
            padding: 8px 12px;
            background: #0a0a1e;
            font-size: 10px;
            color: #a8c0b0;
        }

        #explorer-controls {
            padding: 12px;
            display: flex;
            gap: 8px;
        }

        #explorer-controls button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #btn-run {
            background: #7d9f5a;
            color: #1a1a2e;
        }

        #btn-run:hover { background: #8daf6a; }
        #btn-run:disabled { background: #4a4a4a; color: #888; cursor: not-allowed; }

        #btn-stop {
            background: #c45c4a;
            color: #fff8e7;
        }

        #btn-stop:hover { background: #d46c5a; }
        #btn-stop:disabled { background: #4a4a4a; color: #888; cursor: not-allowed; }

        /* Item Panel (left side) - always visible */
        #item-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 280px;
            height: 100vh;
            background: #1a1a2e;
            border-right: 2px solid #5d4e37;
            font-family: monospace;
            font-size: 12px;
            color: #fff8e7;
            display: flex;
            flex-direction: column;
            z-index: 1000;
        }

        #item-header {
            padding: 12px;
            background: #2a2a4e;
            border-bottom: 1px solid #5d4e37;
        }

        #item-header h3 {
            margin: 0;
            color: #f4d03f;
            font-size: 14px;
        }

        #item-empty {
            padding: 20px;
            text-align: center;
            color: #6b8fa3;
            font-style: italic;
        }

        #item-content {
            display: none;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        #item-content.active {
            display: flex;
        }

        #item-sprite-container {
            padding: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0a0a1e;
            border-bottom: 1px solid #5d4e37;
        }

        #item-sprite-canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #item-name {
            padding: 12px;
            font-size: 16px;
            font-weight: bold;
            color: #f4d03f;
            text-align: center;
            border-bottom: 1px solid #5d4e37;
        }

        #item-description {
            padding: 12px;
            border-bottom: 1px solid #5d4e37;
            flex-shrink: 0;
        }

        #item-description h4 {
            margin: 0 0 8px 0;
            color: #a8c0b0;
            font-size: 11px;
            text-transform: uppercase;
        }

        #item-description p {
            margin: 0;
            line-height: 1.4;
            color: #fff8e7;
        }

        #item-technical {
            padding: 12px;
            flex-shrink: 0;
        }

        #item-technical h4 {
            margin: 0 0 8px 0;
            color: #a8c0b0;
            font-size: 11px;
            text-transform: uppercase;
        }

        #item-effects {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #item-effects li {
            padding: 4px 0;
            color: #fff8e7;
            display: flex;
            align-items: flex-start;
            gap: 6px;
        }

        #item-effects li::before {
            content: '•';
            color: #6b8fa3;
        }

        .effect-good { color: #7d9f5a; }
        .effect-bad { color: #c45c4a; }
        .effect-neutral { color: #6b8fa3; }

        /* Journal section */
        #item-journal {
            flex: 1;
            overflow-y: auto;
            border-top: 1px solid #5d4e37;
        }

        #item-journal h4 {
            margin: 0;
            padding: 12px;
            color: #a8c0b0;
            font-size: 11px;
            text-transform: uppercase;
            background: #2a2a4e;
            position: sticky;
            top: 0;
        }

        #journal-entries {
            padding: 0;
        }

        .journal-entry {
            padding: 10px 12px;
            border-bottom: 1px solid #3a3a5e;
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        .journal-entry:hover {
            background: #2a2a4e;
        }

        .journal-sprite {
            flex-shrink: 0;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .journal-info {
            flex: 1;
            min-width: 0;
        }

        .journal-name {
            color: #f4d03f;
            font-weight: bold;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .journal-desc {
            color: #a8c0b0;
            font-size: 10px;
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        #journal-empty {
            padding: 20px;
            text-align: center;
            color: #6b8fa3;
            font-style: italic;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="controller-prompt">Press any button on controller to connect...</div>

    <!-- Item Panel (left side) - always visible -->
    <div id="item-panel">
        <div id="item-header">
            <h3>Items</h3>
        </div>
        <div id="item-empty">No items collected yet</div>
        <div id="item-content">
            <div id="item-sprite-container">
                <canvas id="item-sprite-canvas" width="64" height="64"></canvas>
            </div>
            <div id="item-name">-</div>
            <div id="item-description">
                <h4>Description</h4>
                <p id="item-desc-text">-</p>
            </div>
            <div id="item-technical">
                <h4>Effects</h4>
                <ul id="item-effects"></ul>
            </div>
        </div>
        <div id="item-journal">
            <h4>Journal</h4>
            <div id="journal-entries">
                <div id="journal-empty">Previous items will appear here</div>
            </div>
        </div>
    </div>

    <!-- Explorer Panel -->
    <div id="explorer-panel" class="collapsed">
        <button id="explorer-toggle">◀</button>
        <div id="explorer-header">
            <h3>Explorer Claude</h3>
            <span id="explorer-status">idle</span>
        </div>
        <div id="explorer-state">
            <h4>Game State</h4>
            <div class="state-grid">
                <span class="state-label">Player:</span>
                <span class="state-value" id="state-player">-</span>
                <span class="state-label">Forge:</span>
                <span class="state-value" id="state-forge">-</span>
                <span class="state-label">Items:</span>
                <span class="state-value" id="state-items">0</span>
                <span class="state-label">Entities:</span>
                <span class="state-value" id="state-entities">0</span>
                <span class="state-label">Forges done:</span>
                <span class="state-value" id="state-forges">0</span>
                <span class="state-label">API misses:</span>
                <span class="state-value" id="state-misses">0</span>
                <span class="state-label">Patterns:</span>
                <span class="state-value" id="state-patterns">0</span>
            </div>
        </div>
        <div id="explorer-observations">
            <h4>API Observations</h4>
            <div id="observations-list">
                <div class="observation info">Waiting to start...</div>
            </div>
        </div>
        <div id="explorer-log"></div>
        <div id="explorer-controls">
            <button id="btn-run">Run (10 forges)</button>
            <button id="btn-stop" disabled>Stop</button>
        </div>
    </div>

    <script>
    // ============================================================
    // ONESHOT CLIMB - M1: Static Frame
    // A roguelike where AI generates game mechanics at runtime
    // ============================================================

    // ============================================================
    // PAPER PIXELS PALETTE
    // Fixed palette - all sprites use these characters/colors
    // ============================================================
    const PALETTE = {
        '.': 'transparent',           // Transparent
        'k': '#5d4e37',              // Outline/dark brown
        'w': '#fff8e7',              // Warm white/highlight
        'g': '#7d9f5a',              // Muted green
        'b': '#6b8fa3',              // Soft blue
        'r': '#c45c4a',              // Soft red
        'o': '#e67e22',              // Orange
        'y': '#f4d03f',              // Yellow
        'p': '#d4a5a5',              // Pink
        't': '#a8c0b0',              // Teal
        'n': '#8b7355',              // Brown (for platforms)
        'd': '#4a3728',              // Dark brown
    };

    const BACKGROUND_COLOR = '#f5f0e1'; // Cream/paper background

    // ============================================================
    // GAME CONSTANTS
    // ============================================================
    const PIXEL_SCALE = 4;           // Each sprite pixel = 4 screen pixels
    const CANVAS_WIDTH = 960;
    const CANVAS_HEIGHT = 540;

    // Player constants
    const PLAYER_SPEED = 200;        // pixels per second
    const JUMP_VELOCITY = -550;      // initial jump velocity (strong enough to reach platforms)
    const GRAVITY = 1200;            // gravity acceleration (snappier feel)
    const GROUND_Y = CANVAS_HEIGHT - 60; // ground level

    // ============================================================
    // SPRITES (Paper Pixels style - ASCII art)
    // ============================================================

    // Player sprite - blue character with yellow eyes (8x12)
    const PLAYER_SPRITE = [
        '........',
        '..bbbb..',
        '..byyb..',
        '...bb...',
        '.bbbbbb.',
        '...bb...',
        '...bb...',
        '...bb...',
        '...bb...',
        '...bb...',
        '..b..b..',
        '..b..b..',
    ];

    // Forge sprite - magical anvil/altar (16x16)
    const FORGE_SPRITE = [
        '......yyyy......',
        '.....yooooy.....',
        '....yorrrroy....',
        '...yorrrrroy....',
        '....yorrrroy....',
        '.....yooooy.....',
        '......yyyy......',
        '....kkkkkkkk....',
        '...kttttttttk...',
        '..ktttttttttk...',
        '..ktttttttttk...',
        '.kttttttttttk...',
        '.kttttttttttk...',
        'kkkkkkkkkkkkkk..',
        'knnnnnnnnnnnnk..',
        '.kkkkkkkkkkkk...',
    ];

    // Platform tile (16x8) - simple wooden platform
    const PLATFORM_SPRITE = [
        'knnnnnnnnnnnnnnk',
        'knnnnnnnnnnnnnk.',
        'kddnnddnnddnndk.',
        'kddddddddddddk..',
        'kdddddddddddk...',
        '.kdddddddddk....',
        '..kkkkkkkkk.....',
        '................',
    ];

    // ============================================================
    // GAME STATE
    // ============================================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const controllerPrompt = document.getElementById('controller-prompt');

    // Set canvas size
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Player state
    const player = {
        x: 100,
        y: GROUND_Y - 48,  // Start on ground
        vx: 0,
        vy: 0,
        width: 8 * PIXEL_SCALE,
        height: 12 * PIXEL_SCALE,
        onGround: true,
        facingRight: true,
        health: 100,
        maxHealth: 100,
        invincibleTimer: 0,  // Brief invincibility after taking damage
    };

    // Platforms - static for M1
    const platforms = [
        // Ground platform (long)
        { x: 0, y: GROUND_Y, width: CANVAS_WIDTH, height: 60, isGround: true },
        // Floating platforms
        { x: 200, y: 380, width: 128, height: 32 },
        { x: 450, y: 300, width: 128, height: 32 },
        { x: 700, y: 350, width: 128, height: 32 },
        { x: 350, y: 200, width: 128, height: 32 },  // Forge platform
    ];

    // Forge - right at player start for easy testing
    const forge = {
        x: 100,
        y: GROUND_Y - 64,  // On the ground, at player start
        width: 16 * PIXEL_SCALE,
        height: 16 * PIXEL_SCALE,
        state: 'idle',        // 'idle' | 'forging' | 'ready' | 'failed'
        forgeTimer: 0,        // Time spent forging
        forgeDuration: 2.0,   // Minimum visual duration (inference may take longer)
        pendingItem: null,    // Item waiting to be collected
        inferencePromise: null, // Active inference call
    };

    // Journal - tracks collected items for prompt context
    const journal = [];

    // Spawned item waiting to be picked up
    let spawnedItem = null;

    // Last collected item (for detail panel)
    let lastCollectedItem = null;

    // Controller state
    let gamepadIndex = null;
    let controllerConnected = false;

    // Keyboard state (fallback)
    const keys = {};

    // ============================================================
    // INFERENCE & ITEM GENERATION
    // ============================================================

    const ITEM_GENERATION_PROMPT = `You are generating a unique item for a roguelite game. Return ONLY JavaScript code - no markdown, no explanation.

## Item Variety (IMPORTANT!)

Items should NOT always be beneficial. Create variety:

- **Pure good** (~30%): Buffs, heals, friendly helpers
- **Pure bad** (~30%): Spawns enemies, debuffs, hazards
- **Mixed** (~40%): Tradeoffs! Speed boost + chasing enemy, heal + boss spawn, powerful ability + penalty

ENEMIES make the game interesting! Don't be afraid to spawn dangerous things.
Set \`friendly: false\` to create hostile entities that damage the player.

Enemy spawn patterns to consider:
- Single tough enemy (boss-like)
- Horde of weak enemies
- Continuous drip spawning (enemies appear over time)
- Triggered spawns (when player uses ability, takes damage, etc)

When the player picks up your item it should cause a change to the world. Giving the player new powers? Spawning entities? Changing stats or physics? Be creative!

## Item Registration API

Call registerItem() exactly once to define your item:

  registerItem({
    name: "Item Name",           // short, evocative name
    description: "What it does", // prose description for the journal
    sprite: \`
      ..kkkk..
      .kwwwwk.
      kwwwwwwk
      kwwwwwwk
      .kwwwwk.
      ..kkkk..
      ........
      ........
    \`,  // 8x8 grid using palette below

    onPickup() {
      // Effects go here - runs when player collects the item
    }
  });

## Sprite Palette (8x8 grid)
Use ONLY these characters:
  . = transparent
  k = outline/dark brown
  w = warm white/highlight
  g = muted green
  b = soft blue
  r = soft red
  o = orange
  y = yellow
  p = pink
  t = teal
  n = brown
  d = dark brown

## Player API (available in onPickup)

  player.x, player.y           // position (read-only)
  player.heal(amount)
  player.damage(amount)
  player.addSpeed(multiplier)  // e.g. 0.2 for 20% faster
  player.addJumpPower(amount)  // e.g. 50 for higher jumps

  // ACTIVE ABILITIES - give player button-activated powers!
  player.onButtonPress('Y', callback, { cooldown: 2, name: 'Fireball' })
    // 'Y' = gamepad Y / keyboard 1
    // 'A' = gamepad A / keyboard 2
    // 'B' = gamepad B / keyboard 3
    // callback runs when button pressed (respects cooldown)
    // Ability appears in UI with cooldown indicator

## World API (available in onPickup)

  // Define new entity types (must define before spawning!)
  world.defineEntity("typename", {
    sprite: \`...8x8...\`,
    damage: 5,           // optional: damage on contact
    lifetime: 3,         // optional: seconds before despawn
    friendly: true,      // optional: doesn't hurt player
    health: 10,          // optional: health points (dies at 0)
    vx: 0, vy: 0,        // optional: initial velocity
    flying: true,        // optional: ignores gravity
  });

  // Spawning returns the entity object
  const e = world.spawn("typename", x, y);

  // Entity properties (read/write after spawning):
  e.x, e.y               // position - can be modified!
  e.vx, e.vy             // velocity - entities move automatically
  e.health               // reduce to 0 to kill
  e.type                 // the type name string

  // MOVEMENT BEHAVIORS - set automatic movement patterns!
  // Use e.setMovement(type, options) after spawning:

  e.setMovement('chase', { speed: 100 })
    // Chases the player at given speed

  e.setMovement('orbit', { radius: 60, period: 2 })
    // Orbits the player at radius, completing circle in period seconds

  e.setMovement('patrol', { x1: 100, y1: 300, x2: 400, y2: 300, speed: 80 })
    // Patrols between two points

  e.setMovement('wander', { speed: 50, interval: 1.5 })
    // Wanders randomly, changing direction every interval seconds

  e.setMovement('flee', { speed: 120, fleeRadius: 150 })
    // Flees from player when within fleeRadius

  // World helper methods
  world.randomPoint()               // get random {x, y} in play area
  world.getPlayerPos()              // get player center {x, y}
  world.getForgePos()               // get forge center {x, y}

  // World methods
  world.onUpdate(callback)          // register per-frame logic: fn(dt)
  world.onPlayerHit(callback)       // when player takes damage
  world.damageNearby(x, y, radius, amount)
  world.removeEntity(entity)        // explicitly remove an entity
  world.getEntitiesInRadius(x, y, r) // find entities near a point
  world.getEntitiesOfType("type")   // find entities by type
  world.entities                    // all entities array
  world.win()                       // trigger win condition

## Constraints
- No infinite loops
- No window/document/eval/fetch access
- Keep it under 40 lines
- Call registerItem exactly once

## Example 1: Orbiting Helpers (using setMovement)

registerItem({
  name: "Guardian Orbs",
  description: "Spawns protective orbs that orbit around you",
  sprite: \`
    ..kbbk..
    .kbttbk.
    kbttttbk
    kbttttbk
    .kbttbk.
    ..kbbk..
    ........
    ........
  \`,

  onPickup() {
    world.defineEntity("orb", {
      sprite: \`
        ..tt....
        .tttt...
        .tttt...
        ..tt....
        ........
        ........
        ........
        ........
      \`,
      friendly: true,
      flying: true
    });

    // Spawn 3 orbiting orbs - setMovement handles the rest!
    for (let i = 0; i < 3; i++) {
      const orb = world.spawn("orb", player.x, player.y);
      orb.setMovement('orbit', {
        radius: 60,
        period: 2,
        startAngle: i * (Math.PI * 2 / 3)
      });
    }
  }
});

## Example 2: Chasing Enemies (using setMovement)

registerItem({
  name: "Cursed Totem",
  description: "Spawns hunting spirits that pursue relentlessly",
  sprite: \`
    ..rrrr..
    .rkkkrk.
    rkwwwwkr
    rkwkkwkr
    rkwwwwkr
    .rkkkrk.
    ..rrrr..
    ........
  \`,

  onPickup() {
    world.defineEntity("hunter", {
      sprite: \`
        ..pp....
        .pppp...
        ppkkpp..
        pppppp..
        .pppp...
        ..pp....
        ........
        ........
      \`,
      damage: 8,
      health: 15,
      friendly: false,
      flying: true
    });

    // Spawn 3 hunters that automatically chase the player!
    for (let i = 0; i < 3; i++) {
      const pos = world.randomPoint();
      const hunter = world.spawn("hunter", pos.x, pos.y);
      hunter.setMovement('chase', { speed: 80 + i * 20 });
    }
  }
});

## Example 3: Patrolling Enemies

registerItem({
  name: "Sentry Stones",
  description: "Summons patrolling guardians that damage on contact",
  sprite: \`
    ..nnnn..
    .nddddn.
    ndwwwwdn
    ndwwwwdn
    .nddddn.
    ..nnnn..
    ........
    ........
  \`,

  onPickup() {
    world.defineEntity("sentry", {
      sprite: \`
        ..nn....
        .nnnn...
        nnkknn..
        nnnnnn..
        .nnnn...
        ..nn....
        ........
        ........
      \`,
      damage: 5,
      health: 20,
      friendly: false,
      flying: true
    });

    // Spawn sentries that patrol horizontally
    for (let i = 0; i < 2; i++) {
      const y = 200 + i * 150;
      const sentry = world.spawn("sentry", 100, y);
      sentry.setMovement('patrol', {
        x1: 100, y1: y,
        x2: 800, y2: y,
        speed: 100
      });
    }
  }
});

## Example 4: Active Ability (button-activated power!)

registerItem({
  name: "Flame Gauntlet",
  description: "Press Y to launch a fireball that damages enemies",
  sprite: \`
    ..rrrr..
    .roooor.
    rooyyoor
    royyyyor
    rooyyoor
    .roooor.
    ..rrrr..
    ........
  \`,

  onPickup() {
    world.defineEntity("fireball", {
      sprite: \`
        ..oo....
        .oyyoo..
        oyyyyyo.
        .oyyoo..
        ..oo....
        ........
        ........
        ........
      \`,
      damage: 15,
      lifetime: 2,
      friendly: true,
      flying: true
    });

    // Register active ability on Y button
    player.onButtonPress('Y', () => {
      const fb = world.spawn("fireball", player.x, player.y);
      fb.vx = 400;  // Shoots right
      world.damageNearby(player.x, player.y, 60, 10);
    }, { cooldown: 1.5, name: 'Fireball' });
  }
});`;

    /**
     * Build the full prompt with current game state
     */
    function buildItemPrompt() {
        let prompt = ITEM_GENERATION_PROMPT;

        // Add current state
        prompt += `\n\n## Current State\n`;
        prompt += `- Items collected so far: ${journal.length}\n`;

        // Count enemies and friendlies
        const enemies = world.entities.filter(e => !e.friendly).length;
        const friendlies = world.entities.filter(e => e.friendly).length;
        prompt += `- Enemies on screen: ${enemies}\n`;
        prompt += `- Friendly entities: ${friendlies}\n`;

        // Encourage variety based on current state
        if (enemies === 0 && journal.length > 0) {
            prompt += `\n⚠️ NO ENEMIES! Consider creating something dangerous to spice things up!\n`;
        } else if (enemies > 5) {
            prompt += `\n⚠️ Many enemies active! Maybe create something helpful... or add even MORE chaos!\n`;
        }

        // Add journal context
        if (journal.length > 0) {
            prompt += `\n## Previous Items (for narrative continuity)\n`;
            for (const item of journal.slice(-5)) {  // Last 5 items
                prompt += `- "${item.name}": ${item.description}\n`;
            }
            prompt += `\nBuild on what exists. Create something that complements or contrasts with previous items.\n`;
        } else {
            prompt += `\nThis is the first item! Set the tone for the run.\n`;
        }

        return prompt;
    }

    /**
     * Call inference API to generate item
     */
    async function generateItem() {
        const prompt = buildItemPrompt();

        try {
            const response = await fetch('/api/inference/anthropic/messages', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    messages: [{ role: 'user', content: prompt }],
                    model: 'claude-haiku-4-5-20251001',  // Fast model for gameplay
                    max_tokens: 1500
                })
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error || 'Inference failed');
            }

            const data = await response.json();
            const code = data.content[0].text;

            console.log('Generated item code:', code);
            return parseItemCode(code);

        } catch (e) {
            console.error('Inference error:', e);
            return null;
        }
    }

    /**
     * Forbidden patterns for safety
     */
    const FORBIDDEN_PATTERNS = [
        'window', 'document', 'eval', 'Function(',
        'fetch', 'XMLHttpRequest', 'import',
        'while(true)', 'for(;;)', 'localStorage', 'sessionStorage'
    ];

    /**
     * Patterns to detect in generated code for API discovery
     */
    const API_PATTERNS = [
        // Entity property access
        { regex: /entity\.x\b(?!\s*[+\-*\/]?=)/g, name: 'entity.x (read)' },
        { regex: /entity\.x\s*[+\-*\/]?=/g, name: 'entity.x (write)' },
        { regex: /entity\.y\b(?!\s*[+\-*\/]?=)/g, name: 'entity.y (read)' },
        { regex: /entity\.y\s*[+\-*\/]?=/g, name: 'entity.y (write)' },
        { regex: /entity\.vx/g, name: 'entity.vx' },
        { regex: /entity\.vy/g, name: 'entity.vy' },
        { regex: /entity\.velocity/g, name: 'entity.velocity' },
        { regex: /entity\.health/g, name: 'entity.health' },
        { regex: /entity\.type\b/g, name: 'entity.type' },
        { regex: /entity\.id\b/g, name: 'entity.id' },
        { regex: /entity\.frozen/g, name: 'entity.frozen' },
        { regex: /entity\.remove|entity\.destroy/g, name: 'entity.remove()' },

        // World queries
        { regex: /world\.entities\b/g, name: 'world.entities (direct)' },
        { regex: /world\.getEntities\w*/g, name: 'world.getEntities*()' },
        { regex: /world\.findEntit/g, name: 'world.findEntit*()' },
        { regex: /world\.getNearby/g, name: 'world.getNearby()' },

        // Entity iteration
        { regex: /for\s*\([^)]*entit/gi, name: 'for-loop entities' },
        { regex: /\.forEach\s*\([^)]*entit/gi, name: 'forEach entities' },
        { regex: /\.filter\s*\([^)]*entit/gi, name: 'filter entities' },

        // Player props
        { regex: /player\.health/g, name: 'player.health' },
        { regex: /player\.vx/g, name: 'player.vx' },
        { regex: /player\.vy/g, name: 'player.vy' },
        { regex: /player\.speed\b/g, name: 'player.speed' },

        // World modification
        { regex: /world\.removeEntity/g, name: 'world.removeEntity()' },
        { regex: /world\.destroyEntity/g, name: 'world.destroyEntity()' },

        // Timing
        { regex: /setTimeout/g, name: 'setTimeout' },
        { regex: /setInterval/g, name: 'setInterval' },
    ];

    /**
     * Analyze generated code for API usage patterns
     */
    function analyzeGeneratedCode(code) {
        const results = {};
        for (const pattern of API_PATTERNS) {
            const matches = code.match(pattern.regex);
            if (matches) {
                results[pattern.name] = matches.length;
            }
        }
        return results;
    }

    /**
     * Parse and validate generated item code
     * Returns item metadata + raw code for later execution
     */
    function parseItemCode(code) {
        // Strip markdown code fences if present
        code = code.replace(/^```(?:javascript|js)?\n?/i, '').replace(/\n?```$/i, '').trim();

        // Check for forbidden patterns
        for (const pattern of FORBIDDEN_PATTERNS) {
            if (code.includes(pattern)) {
                console.warn('Forbidden pattern found:', pattern);
                return null;
            }
        }

        // Create item registry to capture metadata only
        let registeredItem = null;

        const registerItem = (def) => {
            if (registeredItem) {
                throw new Error('registerItem called twice');
            }

            // Validate required fields
            if (!def.name || !def.description || !def.sprite) {
                throw new Error('Missing required item fields');
            }

            // Parse sprite (trim and split into lines)
            const spriteLines = def.sprite.trim().split('\n').map(line => line.trim());

            // Only capture metadata - we'll re-execute for effects
            registeredItem = {
                name: def.name,
                description: def.description,
                sprite: spriteLines,
            };
        };

        // First pass: validate syntax and capture metadata
        try {
            const execute = new Function('registerItem', 'player', 'world', code);
            // Use stub APIs - just capturing metadata
            execute(registerItem, {}, {});
        } catch (e) {
            console.error('Item code execution error:', e);
            return null;
        }

        if (!registeredItem) {
            console.warn('No item was registered');
            return null;
        }

        // Store raw code for execution at pickup time
        registeredItem.code = code;
        return registeredItem;
    }

    // ============================================================
    // SPRITE RENDERING
    // ============================================================

    /**
     * Render an ASCII sprite to canvas
     * @param {string[]} sprite - Array of strings representing pixel rows
     * @param {number} x - X position (top-left)
     * @param {number} y - Y position (top-left)
     * @param {number} scale - Pixel scale (default PIXEL_SCALE)
     * @param {boolean} flipX - Flip horizontally
     */
    function drawSprite(sprite, x, y, scale = PIXEL_SCALE, flipX = false) {
        const width = sprite[0].length;
        const height = sprite.length;

        for (let row = 0; row < height; row++) {
            for (let col = 0; col < width; col++) {
                const char = sprite[row][flipX ? width - 1 - col : col];
                const color = PALETTE[char];

                if (color && color !== 'transparent') {
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        Math.floor(x + col * scale),
                        Math.floor(y + row * scale),
                        scale,
                        scale
                    );
                }
            }
        }
    }

    /**
     * Draw a platform using tiled sprites
     */
    function drawPlatform(platform) {
        if (platform.isGround) {
            // Ground is just a solid color
            ctx.fillStyle = PALETTE['n'];
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            // Top edge
            ctx.fillStyle = PALETTE['g'];
            ctx.fillRect(platform.x, platform.y, platform.width, 8);
            return;
        }

        // Tile the platform sprite
        const tileWidth = 16 * PIXEL_SCALE;
        const tilesNeeded = Math.ceil(platform.width / tileWidth);

        for (let i = 0; i < tilesNeeded; i++) {
            const tileX = platform.x + i * tileWidth;
            // Clip to platform width
            if (tileX < platform.x + platform.width) {
                drawSprite(PLATFORM_SPRITE, tileX, platform.y);
            }
        }
    }

    // ============================================================
    // INPUT HANDLING
    // ============================================================

    // Keyboard events (fallback)
    window.addEventListener('keydown', (e) => {
        keys[e.code] = true;
    });

    window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    // Gamepad connection
    window.addEventListener('gamepadconnected', (e) => {
        console.log('Gamepad connected:', e.gamepad.id);
        gamepadIndex = e.gamepad.index;
        controllerConnected = true;
        controllerPrompt.classList.add('hidden');
    });

    window.addEventListener('gamepaddisconnected', (e) => {
        console.log('Gamepad disconnected');
        if (e.gamepad.index === gamepadIndex) {
            gamepadIndex = null;
            controllerConnected = false;
            controllerPrompt.classList.remove('hidden');
        }
    });

    /**
     * Get current input state from controller or keyboard
     * Gamepad: Left stick = move, Stick up = jump, X = forge, Y/A/B = abilities
     * Keyboard: WASD = move, W/Space = jump, E = forge, 1/2/3 = abilities
     */
    function getInput() {
        const input = {
            moveX: 0,
            jump: false,
            interact: false,
            abilityY: false,  // Y button / 1 key
            abilityA: false,  // A button / 2 key
            abilityB: false,  // B button / 3 key
        };

        // Explorer input takes priority when running
        if (explorer.running) {
            input.moveX = explorerInput.moveX;
            input.jump = explorerInput.jump;
            input.interact = explorerInput.interact;
            return input;
        }

        // Try gamepad first
        if (gamepadIndex !== null) {
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];

            if (gamepad) {
                // Left stick X axis (with deadzone)
                const deadzone = 0.15;
                const stickX = gamepad.axes[0];
                if (Math.abs(stickX) > deadzone) {
                    input.moveX = stickX;
                }

                // Left stick up = Jump (with deadzone)
                const stickY = gamepad.axes[1];
                if (stickY < -0.5) {
                    input.jump = true;
                }

                // X button = Interact/Forge (button 2)
                input.interact = gamepad.buttons[2].pressed;

                // Y button = Ability (button 3)
                input.abilityY = gamepad.buttons[3].pressed;

                // A button = Ability (button 0)
                input.abilityA = gamepad.buttons[0].pressed;

                // B button = Ability (button 1)
                input.abilityB = gamepad.buttons[1].pressed;
            }
        }

        // Keyboard fallback (or combine)
        if (keys['ArrowLeft'] || keys['KeyA']) {
            input.moveX = -1;
        }
        if (keys['ArrowRight'] || keys['KeyD']) {
            input.moveX = 1;
        }
        if (keys['ArrowUp'] || keys['KeyW'] || keys['Space']) {
            input.jump = true;
        }
        if (keys['KeyE'] || keys['KeyX']) {
            input.interact = true;
        }
        // Number keys for abilities: 1=Y, 2=A, 3=B
        if (keys['Digit1']) {
            input.abilityY = true;
        }
        if (keys['Digit2']) {
            input.abilityA = true;
        }
        if (keys['Digit3']) {
            input.abilityB = true;
        }

        return input;
    }

    // Track previous input state for edge detection
    let prevInput = { jump: false, interact: false, abilityY: false, abilityA: false, abilityB: false };

    // ============================================================
    // PHYSICS & COLLISION
    // ============================================================

    /**
     * Check if player is colliding with a platform from above
     */
    function checkPlatformCollision(px, py, pw, ph) {
        for (const platform of platforms) {
            // Simple AABB collision
            const onPlatform =
                px + pw > platform.x &&
                px < platform.x + platform.width &&
                py + ph >= platform.y &&
                py + ph <= platform.y + 20 && // Only collide from above
                player.vy >= 0;  // Only when falling

            if (onPlatform) {
                return platform;
            }
        }
        return null;
    }

    /**
     * Update player physics
     */
    function updatePlayer(dt, input) {
        // Tick invincibility timer
        if (player.invincibleTimer > 0) {
            player.invincibleTimer -= dt;
        }

        // Horizontal movement (with speed modifier from items)
        player.vx = input.moveX * PLAYER_SPEED * playerAPI.speedMultiplier;

        // Update facing direction
        if (input.moveX > 0) player.facingRight = true;
        if (input.moveX < 0) player.facingRight = false;

        // Jump (only on button press, not hold) - with jump bonus from items
        if (input.jump && !prevInput.jump && player.onGround) {
            player.vy = JUMP_VELOCITY - playerAPI.jumpBonus;
            player.onGround = false;
        }

        // Apply gravity
        if (!player.onGround) {
            player.vy += GRAVITY * dt;
        }

        // Update position
        player.x += player.vx * dt;
        player.y += player.vy * dt;

        // Check platform collision
        const platform = checkPlatformCollision(
            player.x, player.y, player.width, player.height
        );

        if (platform) {
            player.y = platform.y - player.height;
            player.vy = 0;
            player.onGround = true;
        } else {
            // No platform below - player is in the air
            player.onGround = false;
        }

        // Screen bounds
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > CANVAS_WIDTH) {
            player.x = CANVAS_WIDTH - player.width;
        }

        // Prevent falling through bottom (safety)
        if (player.y > CANVAS_HEIGHT) {
            player.y = GROUND_Y - player.height;
            player.vy = 0;
            player.onGround = true;
        }
    }

    // ============================================================
    // FORGE LOGIC
    // ============================================================

    /**
     * Check if player is near the forge
     */
    function isPlayerNearForge() {
        const distToForge = Math.hypot(
            (player.x + player.width/2) - (forge.x + forge.width/2),
            (player.y + player.height/2) - (forge.y + forge.height/2)
        );
        return distToForge < 80;
    }

    /**
     * Check if player is touching the spawned item
     */
    function isPlayerTouchingItem() {
        if (!spawnedItem) return false;
        return (
            player.x < spawnedItem.x + spawnedItem.width &&
            player.x + player.width > spawnedItem.x &&
            player.y < spawnedItem.y + spawnedItem.height &&
            player.y + player.height > spawnedItem.y
        );
    }

    /**
     * Update forge state
     */
    function updateForge(dt, input) {
        if (forge.state === 'idle') {
            // Check for interaction (button press, not hold)
            if (input.interact && !prevInput.interact && isPlayerNearForge()) {
                forge.state = 'forging';
                forge.forgeTimer = 0;
                forge.pendingItem = null;
                console.log('Forge activated! Calling inference...');

                // Start inference (async)
                forge.inferencePromise = generateItem().then(item => {
                    forge.pendingItem = item;
                    forge.inferencePromise = null;
                    console.log('Inference complete:', item ? item.name : 'failed');
                });
            }
        } else if (forge.state === 'forging') {
            forge.forgeTimer += dt;

            // Wait for both: minimum visual duration AND inference complete
            const visualReady = forge.forgeTimer >= forge.forgeDuration;
            const inferenceReady = forge.inferencePromise === null;

            if (visualReady && inferenceReady) {
                if (forge.pendingItem) {
                    // Success! Spawn the item
                    forge.state = 'ready';
                    spawnedItem = {
                        ...forge.pendingItem,
                        x: forge.x + forge.width/2 - 16,  // Center above forge
                        y: forge.y - 40,
                        width: 8 * PIXEL_SCALE,
                        height: 8 * PIXEL_SCALE,
                    };
                    console.log('Item spawned:', spawnedItem.name);
                } else {
                    // Failure - creation unstable
                    forge.state = 'failed';
                    forge.forgeTimer = 0;  // Reuse for failure animation
                    console.log('Creation unstable - forge failed');
                }
            }
        } else if (forge.state === 'ready') {
            // Item can be collected by touching it
            if (isPlayerTouchingItem()) {
                collectItem(spawnedItem);
                spawnedItem = null;
                forge.state = 'idle';
            }
        } else if (forge.state === 'failed') {
            // Brief failure animation then reset
            forge.forgeTimer += dt;
            if (forge.forgeTimer >= 1.5) {
                forge.state = 'idle';
            }
        }
    }

    // ============================================================
    // WORLD & PLAYER APIs (for item effects)
    // ============================================================

    // Persistent world state for item effects
    const world = {
        entityTypes: {},
        entities: [],
        updateCallbacks: [],
        playerHitCallbacks: [],
        hasWon: false,

        defineEntity(name, def) {
            console.log('Entity type defined:', name, def);
            // Parse sprite
            if (def.sprite) {
                def.sprite = def.sprite.trim().split('\n').map(line => line.trim());
            }
            this.entityTypes[name] = def;
        },

        spawn(type, x, y) {
            const typeDef = this.entityTypes[type];
            if (!typeDef) {
                console.warn('Unknown entity type:', type);
                return null;
            }
            const entity = {
                type,
                x,
                y,
                vx: typeDef.vx || 0,    // Velocity (can be set by item code)
                vy: typeDef.vy || 0,
                width: 8 * PIXEL_SCALE,
                height: 8 * PIXEL_SCALE,
                lifetime: typeDef.lifetime || Infinity,
                health: typeDef.health || 10,  // Default health
                age: 0,
                movement: null,  // Movement behavior
                ...typeDef,

                // Set movement behavior on this entity
                setMovement(behaviorType, options = {}) {
                    this.movement = { type: behaviorType, ...options };
                    // Initialize orbit angle if orbiting
                    if (behaviorType === 'orbit') {
                        this.movement.angle = options.startAngle || Math.random() * Math.PI * 2;
                    }
                    return this;
                }
            };
            this.entities.push(entity);
            return entity;
        },

        // Helper: get a random point in the play area
        randomPoint() {
            return {
                x: Math.random() * (CANVAS_WIDTH - 100) + 50,
                y: Math.random() * (GROUND_Y - 150) + 100
            };
        },

        // Helper: get player position (for chase/orbit targets)
        getPlayerPos() {
            return { x: player.x + player.width/2, y: player.y + player.height/2 };
        },

        // Helper: get forge position
        getForgePos() {
            return { x: forge.x + forge.width/2, y: forge.y + forge.height/2 };
        },

        onUpdate(callback) {
            console.log('Update callback registered');
            this.updateCallbacks.push(callback);
        },

        onPlayerHit(callback) {
            console.log('Player hit callback registered');
            this.playerHitCallbacks.push(callback);
        },

        damageNearby(x, y, radius, amount) {
            // Damage entities in radius (throttled logging)
            let damaged = 0;
            for (const entity of this.entities) {
                if (entity.friendly) continue;
                const dist = Math.hypot(entity.x - x, entity.y - y);
                if (dist < radius) {
                    entity.health = (entity.health || 10) - amount;
                    damaged++;
                }
            }
            if (damaged > 0) {
                console.log('Area damage:', amount, 'hit', damaged, 'entities');
            }
        },

        removeEntity(entity) {
            const idx = this.entities.indexOf(entity);
            if (idx !== -1) {
                this.entities.splice(idx, 1);
                return true;
            }
            return false;
        },

        getEntitiesInRadius(x, y, radius) {
            return this.entities.filter(e => {
                const dist = Math.hypot(e.x - x, e.y - y);
                return dist < radius;
            });
        },

        getEntitiesOfType(type) {
            return this.entities.filter(e => e.type === type);
        },

        win() {
            if (this.hasWon) return;
            this.hasWon = true;
            console.log('=== YOU WIN! ===');
            // Could trigger a win screen here
        }
    };

    // Player API proxy (exposes safe interface)
    const playerAPI = {
        get x() { return player.x; },
        get y() { return player.y; },
        speedMultiplier: 1,
        jumpBonus: 0,
        abilities: [],           // Registered abilities
        abilityCooldowns: {},    // Track cooldowns per ability

        heal(amount) {
            player.health = Math.min(player.maxHealth, player.health + amount);
            console.log('Player healed:', amount, '→', player.health);
        },

        damage(amount) {
            if (player.invincibleTimer > 0) return; // I-frames
            player.health = Math.max(0, player.health - amount);
            player.invincibleTimer = 0.5; // Half second of invincibility
            console.log('Player damaged:', amount, '→', player.health);
            if (player.health <= 0) {
                console.log('PLAYER DIED! Respawning...');
                player.health = player.maxHealth;
            }
        },

        addSpeed(multiplier) {
            this.speedMultiplier += multiplier;
            console.log('Player speed now:', this.speedMultiplier);
        },

        // Register an active ability on a button
        // button: 'Y' (gamepad Y / keyboard Q), 'B' (gamepad B / keyboard R)
        // options: { cooldown: seconds, name: string }
        onButtonPress(button, callback, options = {}) {
            const ability = {
                button: button.toUpperCase(),
                callback,
                cooldown: options.cooldown || 0,
                name: options.name || 'Ability',
                lastUsed: -Infinity
            };
            this.abilities.push(ability);
            console.log(`Ability registered: ${ability.name} on ${ability.button}`);
            return ability;
        },

        // Called by input system when ability button is pressed
        triggerAbility(button) {
            const now = Date.now() / 1000;
            for (const ability of this.abilities) {
                if (ability.button === button) {
                    const timeSince = now - ability.lastUsed;
                    if (timeSince >= ability.cooldown) {
                        try {
                            ability.callback();
                            ability.lastUsed = now;
                            console.log(`Ability used: ${ability.name}`);
                        } catch (e) {
                            console.warn('Ability error:', e);
                        }
                    } else {
                        console.log(`${ability.name} on cooldown: ${(ability.cooldown - timeSince).toFixed(1)}s`);
                    }
                }
            }
        },

        // Get active abilities for UI display
        getAbilities() {
            const now = Date.now() / 1000;
            return this.abilities.map(a => ({
                name: a.name,
                button: a.button,
                ready: (now - a.lastUsed) >= a.cooldown,
                cooldownRemaining: Math.max(0, a.cooldown - (now - a.lastUsed))
            }));
        },

        addJumpPower(amount) {
            this.jumpBonus += amount;
            console.log('Player jump bonus now:', this.jumpBonus);
        }
    };

    /**
     * Create instrumented proxy for observation
     */
    function createInstrumentedProxy(target, name) {
        return new Proxy(target, {
            get(obj, prop) {
                // Check if property exists
                if (prop in obj) {
                    const value = obj[prop];
                    // Log method calls
                    if (typeof value === 'function') {
                        return function(...args) {
                            if (explorer.running) {
                                explorer.recordApiSuccess(prop, name);
                            }
                            return value.apply(obj, args);
                        };
                    }
                    return value;
                } else {
                    // Property doesn't exist - record the miss!
                    if (explorer.running) {
                        explorer.recordApiMiss(prop, name);
                    }
                    console.warn(`[API Miss] ${name}.${prop} is undefined`);
                    return undefined;
                }
            },
            set(obj, prop, value) {
                // Record attempts to set properties
                if (!(prop in obj)) {
                    if (explorer.running) {
                        explorer.recordApiMiss(prop + ' (write)', name);
                    }
                    console.warn(`[API Miss] Attempted to set ${name}.${prop}`);
                }
                obj[prop] = value;
                return true;
            }
        });
    }

    /**
     * Collect an item - re-execute code with real APIs
     */
    function collectItem(item) {
        console.log('=== Collecting item:', item.name, '===');

        // Add to journal
        journal.push({
            name: item.name,
            description: item.description
        });

        // Update item detail panel
        lastCollectedItem = item;
        itemPanel.update(item);

        // Analyze code patterns if explorer is running
        if (explorer.running) {
            explorer.analyzeItemCode(item);
        }

        // Create instrumented versions of APIs for observation
        const instrumentedPlayer = createInstrumentedProxy(playerAPI, 'player');
        const instrumentedWorld = createInstrumentedProxy(world, 'world');

        // Re-execute the full code with instrumented APIs
        // This time onPickup will run with working player/world refs
        try {
            let pickupFn = null;

            const registerItem = (def) => {
                // Capture the onPickup function
                pickupFn = def.onPickup;
            };

            // Execute with instrumented APIs in scope
            const execute = new Function('registerItem', 'player', 'world', item.code);
            execute(registerItem, instrumentedPlayer, instrumentedWorld);

            // Now call onPickup if it exists
            if (pickupFn) {
                pickupFn();
                console.log('Item effects activated!');
                if (explorer.running) {
                    explorer.addObservation('success', `Item collected: ${item.name}`);
                }
            }
        } catch (e) {
            console.warn('onPickup error:', e);
            if (explorer.running) {
                explorer.addObservation('failure', `Item error: ${e.message}`);
            }
            // Item still collected, effects just don't work
        }
    }

    /**
     * Update world entities and callbacks
     */
    function updateWorld(dt) {
        // Run item update callbacks
        for (const callback of world.updateCallbacks) {
            try {
                callback(dt);
            } catch (e) {
                console.warn('Update callback error:', e);
            }
        }

        // Update entities
        for (let i = world.entities.length - 1; i >= 0; i--) {
            const entity = world.entities[i];
            entity.age += dt;

            // Process movement behaviors
            if (entity.movement) {
                const m = entity.movement;
                const playerPos = world.getPlayerPos();

                switch (m.type) {
                    case 'chase': {
                        // Chase a target (default: player)
                        const targetX = m.targetX ?? playerPos.x;
                        const targetY = m.targetY ?? playerPos.y;
                        const speed = m.speed || 100;
                        const dx = targetX - entity.x;
                        const dy = targetY - entity.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 5) {  // Don't jitter when close
                            entity.vx = (dx / dist) * speed;
                            entity.vy = (dy / dist) * speed;
                        }
                        break;
                    }
                    case 'orbit': {
                        // Orbit around a point (default: player)
                        const centerX = m.centerX ?? playerPos.x;
                        const centerY = m.centerY ?? playerPos.y;
                        const radius = m.radius || 60;
                        const period = m.period || 2;  // seconds for full orbit
                        const angularSpeed = (Math.PI * 2) / period;

                        m.angle = (m.angle || 0) + angularSpeed * dt;
                        entity.x = centerX + Math.cos(m.angle) * radius - entity.width/2;
                        entity.y = centerY + Math.sin(m.angle) * radius - entity.height/2;
                        entity.vx = 0;  // Position is set directly
                        entity.vy = 0;
                        break;
                    }
                    case 'patrol': {
                        // Patrol between two points
                        const x1 = m.x1 ?? entity.x;
                        const y1 = m.y1 ?? entity.y;
                        const x2 = m.x2 ?? (entity.x + 200);
                        const y2 = m.y2 ?? entity.y;
                        const speed = m.speed || 80;

                        // Initialize patrol state
                        if (m.targetIdx === undefined) m.targetIdx = 1;

                        const targetX = m.targetIdx === 0 ? x1 : x2;
                        const targetY = m.targetIdx === 0 ? y1 : y2;
                        const dx = targetX - entity.x;
                        const dy = targetY - entity.y;
                        const dist = Math.hypot(dx, dy);

                        if (dist < 10) {
                            // Reached target, switch
                            m.targetIdx = m.targetIdx === 0 ? 1 : 0;
                        } else {
                            entity.vx = (dx / dist) * speed;
                            entity.vy = (dy / dist) * speed;
                        }
                        break;
                    }
                    case 'wander': {
                        // Wander randomly
                        const speed = m.speed || 50;
                        const changeInterval = m.interval || 1.5;

                        m.timer = (m.timer || 0) + dt;
                        if (m.timer >= changeInterval || m.dirX === undefined) {
                            m.timer = 0;
                            const angle = Math.random() * Math.PI * 2;
                            m.dirX = Math.cos(angle);
                            m.dirY = Math.sin(angle);
                        }
                        entity.vx = m.dirX * speed;
                        entity.vy = m.dirY * speed;
                        break;
                    }
                    case 'flee': {
                        // Flee from target (default: player)
                        const targetX = m.targetX ?? playerPos.x;
                        const targetY = m.targetY ?? playerPos.y;
                        const speed = m.speed || 120;
                        const dx = entity.x - targetX;
                        const dy = entity.y - targetY;
                        const dist = Math.hypot(dx, dy);
                        if (dist < (m.fleeRadius || 150)) {
                            entity.vx = (dx / dist) * speed;
                            entity.vy = (dy / dist) * speed;
                        } else {
                            entity.vx *= 0.95;  // Slow down when far enough
                            entity.vy *= 0.95;
                        }
                        break;
                    }
                }
            }

            // Apply velocity (entities can now move!)
            entity.x += entity.vx * dt;
            entity.y += entity.vy * dt;

            // Apply gravity to non-flying entities (if not explicitly marked as flying)
            // Skip gravity for entities with certain movement behaviors
            const skipGravity = entity.flying || entity.friendly ||
                (entity.movement && ['orbit', 'chase', 'flee'].includes(entity.movement.type));
            if (!skipGravity) {
                entity.vy += GRAVITY * 0.5 * dt;  // Half gravity for floatier feel
            }

            // Keep entities on screen (simple bounds)
            if (entity.x < 0) entity.x = 0;
            if (entity.x > CANVAS_WIDTH - entity.width) entity.x = CANVAS_WIDTH - entity.width;
            if (entity.y > GROUND_Y - entity.height) {
                entity.y = GROUND_Y - entity.height;
                entity.vy = 0;  // Stop falling when hitting ground
            }

            // Remove expired entities
            if (entity.age >= entity.lifetime) {
                world.entities.splice(i, 1);
                continue;
            }

            // Remove dead entities (health <= 0)
            if (entity.health <= 0) {
                console.log('Entity died:', entity.type);
                world.entities.splice(i, 1);
                continue;
            }

            // Check collision with player (for damaging entities)
            if (entity.damage && !entity.friendly) {
                const touching =
                    player.x < entity.x + entity.width &&
                    player.x + player.width > entity.x &&
                    player.y < entity.y + entity.height &&
                    player.y + player.height > entity.y;

                if (touching && player.invincibleTimer <= 0) {
                    // Actually damage the player!
                    playerAPI.damage(entity.damage);

                    // Notify callbacks
                    for (const cb of world.playerHitCallbacks) {
                        try { cb(entity.damage, entity); } catch (e) {}
                    }
                }
            }
        }
    }

    /**
     * Render world entities
     */
    function renderEntities() {
        for (const entity of world.entities) {
            if (entity.sprite) {
                drawSprite(entity.sprite, entity.x, entity.y, PIXEL_SCALE);
            }
        }
    }

    // ============================================================
    // RENDERING
    // ============================================================

    function render() {
        // Clear with background color
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw platforms
        for (const platform of platforms) {
            drawPlatform(platform);
        }

        // Draw forge
        drawSprite(FORGE_SPRITE, forge.x, forge.y, PIXEL_SCALE);

        // Draw world entities (from item effects)
        renderEntities();

        // Draw player (flicker when invincible)
        const showPlayer = player.invincibleTimer <= 0 || Math.floor(player.invincibleTimer * 10) % 2 === 0;
        if (showPlayer) {
            drawSprite(
                PLAYER_SPRITE,
                player.x,
                player.y,
                PIXEL_SCALE,
                !player.facingRight  // Flip if facing left
            );
        }

        // Draw health bar (top-left corner)
        const healthBarWidth = 150;
        const healthBarHeight = 16;
        const healthBarX = 20;
        const healthBarY = 20;
        const healthPct = player.health / player.maxHealth;

        // Background (dark)
        ctx.fillStyle = '#2c1810';
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

        // Health fill (green → yellow → red based on health)
        let healthColor;
        if (healthPct > 0.6) healthColor = '#7daa73'; // green
        else if (healthPct > 0.3) healthColor = '#f4d03f'; // yellow
        else healthColor = '#cf6a4c'; // red

        ctx.fillStyle = healthColor;
        ctx.fillRect(healthBarX + 2, healthBarY + 2, (healthBarWidth - 4) * healthPct, healthBarHeight - 4);

        // Border
        ctx.strokeStyle = '#d9c4a5';
        ctx.lineWidth = 2;
        ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

        // Health text
        ctx.fillStyle = '#d9c4a5';
        ctx.font = '10px monospace';
        ctx.fillText(`HP: ${Math.ceil(player.health)}/${player.maxHealth}`, healthBarX + 4, healthBarY + 12);

        // Draw ability icons (below health bar)
        const abilities = playerAPI.getAbilities();
        if (abilities.length > 0) {
            const abilityY = healthBarY + healthBarHeight + 8;
            abilities.forEach((ability, i) => {
                const abilityX = healthBarX + i * 80;

                // Background
                ctx.fillStyle = ability.ready ? '#2a4a3a' : '#3a2a2a';
                ctx.fillRect(abilityX, abilityY, 72, 24);

                // Border
                ctx.strokeStyle = ability.ready ? '#7d9f5a' : '#c45c4a';
                ctx.lineWidth = 2;
                ctx.strokeRect(abilityX, abilityY, 72, 24);

                // Button label
                ctx.fillStyle = '#f4d03f';
                ctx.font = 'bold 10px monospace';
                ctx.fillText(`[${ability.button}]`, abilityX + 4, abilityY + 10);

                // Ability name or cooldown
                ctx.fillStyle = ability.ready ? '#fff8e7' : '#888';
                ctx.font = '9px monospace';
                if (ability.ready) {
                    ctx.fillText(ability.name.slice(0, 8), abilityX + 4, abilityY + 20);
                } else {
                    ctx.fillText(`${ability.cooldownRemaining.toFixed(1)}s`, abilityX + 4, abilityY + 20);
                }
            });
        }

        // Draw spawned item if exists
        if (spawnedItem) {
            // Floating animation
            const floatY = Math.sin(Date.now() / 300) * 4;
            drawSprite(spawnedItem.sprite, spawnedItem.x, spawnedItem.y + floatY, PIXEL_SCALE);

            // Glow effect
            const glow = Math.sin(Date.now() / 200) * 0.2 + 0.5;
            ctx.fillStyle = `rgba(244, 208, 63, ${glow * 0.3})`;
            ctx.beginPath();
            ctx.arc(
                spawnedItem.x + spawnedItem.width/2,
                spawnedItem.y + spawnedItem.height/2 + floatY,
                30,
                0, Math.PI * 2
            );
            ctx.fill();

            // Item name label
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            const nameWidth = ctx.measureText(spawnedItem.name).width + 16;
            ctx.fillRect(
                spawnedItem.x + spawnedItem.width/2 - nameWidth/2,
                spawnedItem.y - 25,
                nameWidth, 20
            );
            ctx.fillStyle = '#f4d03f';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(spawnedItem.name, spawnedItem.x + spawnedItem.width/2, spawnedItem.y - 10);
            ctx.textAlign = 'left';
        }

        // Draw forge state feedback
        const nearForge = isPlayerNearForge();

        if (forge.state === 'forging') {
            // Forging animation - pulsing glow
            const pulse = Math.sin(forge.forgeTimer * 8) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(244, 208, 63, ${pulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(
                forge.x + forge.width/2,
                forge.y + forge.height/2,
                60 + Math.sin(forge.forgeTimer * 6) * 10,
                0, Math.PI * 2
            );
            ctx.fill();

            // Progress indicator (pulsing since we don't know exact duration)
            const barWidth = 80;
            const barX = forge.x + forge.width/2 - barWidth/2;
            const barY = forge.y - 35;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(barX - 2, barY - 2, barWidth + 4, 14);
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(barX, barY, barWidth, 10);

            // Animated progress (bounces while waiting for inference)
            const progress = forge.pendingItem !== null ? 1.0 :
                (Math.sin(forge.forgeTimer * 3) * 0.3 + 0.5);
            ctx.fillStyle = '#f4d03f';
            ctx.fillRect(barX, barY, barWidth * progress, 10);

            ctx.fillStyle = '#fff8e7';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Forging...', forge.x + forge.width/2, barY - 6);
            ctx.textAlign = 'left';

        } else if (forge.state === 'ready') {
            // Item ready - gentle glow on forge
            const sparkle = Math.sin(Date.now() / 100) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(244, 208, 63, ${sparkle * 0.3})`;
            ctx.beginPath();
            ctx.arc(forge.x + forge.width/2, forge.y + forge.height/2, 40, 0, Math.PI * 2);
            ctx.fill();

        } else if (forge.state === 'failed') {
            // Failed - red fizzle effect
            const fade = 1 - (forge.forgeTimer / 1.5);
            ctx.fillStyle = `rgba(196, 92, 74, ${fade * 0.5})`;
            ctx.beginPath();
            ctx.arc(forge.x + forge.width/2, forge.y + forge.height/2, 50 * fade, 0, Math.PI * 2);
            ctx.fill();

            // Failure message
            ctx.fillStyle = `rgba(0, 0, 0, ${fade * 0.7})`;
            ctx.fillRect(forge.x - 30, forge.y - 35, 140, 24);
            ctx.fillStyle = `rgba(196, 92, 74, ${fade})`;
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Creation unstable...', forge.x + forge.width/2, forge.y - 18);
            ctx.textAlign = 'left';

        } else if (nearForge) {
            // Idle - show interact prompt
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(forge.x - 10, forge.y - 30, 100, 24);
            ctx.fillStyle = '#fff8e7';
            ctx.font = '14px monospace';
            ctx.fillText(controllerConnected ? '[X] Forge' : '[E] Forge', forge.x, forge.y - 12);
        }

        // Debug: show status
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(10, 10, 200, 80);
        ctx.fillStyle = '#fff8e7';
        ctx.font = '12px monospace';
        ctx.fillText(`Controller: ${controllerConnected ? 'Connected' : 'None'}`, 20, 28);
        ctx.fillText(`Player: (${Math.floor(player.x)}, ${Math.floor(player.y)})`, 20, 44);
        ctx.fillText(`Forge: ${forge.state}`, 20, 60);
        ctx.fillText(`Items: ${journal.length}`, 20, 76);
    }

    // ============================================================
    // GAME LOOP
    // ============================================================

    let lastTime = 0;

    function gameLoop(timestamp) {
        // Calculate delta time (capped at 100ms to prevent spiral of death)
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;

        // Get input
        const input = getInput();

        // Update
        updatePlayer(dt, input);
        updateForge(dt, input);
        updateWorld(dt);

        // Handle ability button presses (edge-triggered)
        if (input.abilityY && !prevInput.abilityY) {
            playerAPI.triggerAbility('Y');
        }
        if (input.abilityA && !prevInput.abilityA) {
            playerAPI.triggerAbility('A');
        }
        if (input.abilityB && !prevInput.abilityB) {
            playerAPI.triggerAbility('B');
        }

        // Store previous input for edge detection
        prevInput = { ...input };

        // Render
        render();

        // Next frame
        requestAnimationFrame(gameLoop);
    }

    // ============================================================
    // ITEM DETAIL PANEL
    // ============================================================

    const itemPanel = {
        panel: null,
        canvas: null,
        ctx: null,
        previousItems: [],  // Track previous items for journal

        init() {
            this.panel = document.getElementById('item-panel');
            this.canvas = document.getElementById('item-sprite-canvas');
            this.ctx = this.canvas.getContext('2d');
        },

        // Create a small canvas for journal sprite thumbnails
        createSpriteCanvas(sprite, size = 24) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            canvas.className = 'journal-sprite';
            const ctx = canvas.getContext('2d');

            const scale = size / 8;  // 8x8 sprites
            for (let row = 0; row < sprite.length; row++) {
                for (let col = 0; col < sprite[row].length; col++) {
                    const char = sprite[row][col];
                    const color = PALETTE[char];
                    if (color && color !== 'transparent') {
                        ctx.fillStyle = color;
                        ctx.fillRect(col * scale, row * scale, scale, scale);
                    }
                }
            }
            return canvas;
        },

        // Add item to journal (previous items section)
        addToJournal(item) {
            // Add to beginning of previous items
            this.previousItems.unshift(item);

            // Update journal display
            const entriesContainer = document.getElementById('journal-entries');
            const emptyMsg = document.getElementById('journal-empty');
            if (emptyMsg) emptyMsg.remove();

            // Create journal entry
            const entry = document.createElement('div');
            entry.className = 'journal-entry';

            // Sprite thumbnail
            const spriteCanvas = this.createSpriteCanvas(item.sprite);
            entry.appendChild(spriteCanvas);

            // Info section
            const info = document.createElement('div');
            info.className = 'journal-info';

            const name = document.createElement('div');
            name.className = 'journal-name';
            name.textContent = item.name;
            info.appendChild(name);

            const desc = document.createElement('div');
            desc.className = 'journal-desc';
            desc.textContent = item.description;
            info.appendChild(desc);

            entry.appendChild(info);

            // Insert at beginning
            entriesContainer.insertBefore(entry, entriesContainer.firstChild);
        },

        // Parse item code to extract technical effects
        parseEffects(code) {
            const effects = [];

            // Player stat changes
            if (code.includes('player.addSpeed')) {
                const match = code.match(/player\.addSpeed\(([\d.-]+)\)/);
                if (match) {
                    const val = parseFloat(match[1]);
                    effects.push({
                        text: val > 0 ? `+${Math.round(val * 100)}% speed` : `${Math.round(val * 100)}% speed`,
                        type: val > 0 ? 'good' : 'bad'
                    });
                }
            }

            if (code.includes('player.addJumpPower')) {
                const match = code.match(/player\.addJumpPower\(([\d.-]+)\)/);
                if (match) {
                    const val = parseFloat(match[1]);
                    effects.push({
                        text: val > 0 ? `+${val} jump power` : `${val} jump power`,
                        type: val > 0 ? 'good' : 'bad'
                    });
                }
            }

            if (code.includes('player.heal')) {
                const match = code.match(/player\.heal\(([\d.]+)\)/);
                if (match) {
                    effects.push({ text: `Heals ${match[1]} HP`, type: 'good' });
                }
            }

            if (code.includes('player.damage')) {
                const match = code.match(/player\.damage\(([\d.]+)\)/);
                if (match) {
                    effects.push({ text: `Deals ${match[1]} damage to you`, type: 'bad' });
                }
            }

            // Entity spawning
            const defineMatches = code.matchAll(/world\.defineEntity\s*\(\s*["']([^"']+)["']\s*,\s*\{([^}]+)\}/g);
            for (const match of defineMatches) {
                const entityName = match[1];
                const props = match[2];
                const isFriendly = !props.includes('friendly: false') && !props.includes('friendly:false');

                // Check if this entity is actually spawned
                if (code.includes(`world.spawn("${entityName}"`) || code.includes(`world.spawn('${entityName}'`)) {
                    effects.push({
                        text: isFriendly ? `Spawns friendly ${entityName}` : `Spawns hostile ${entityName}`,
                        type: isFriendly ? 'good' : 'bad'
                    });
                }
            }

            // Area damage
            if (code.includes('world.damageNearby')) {
                effects.push({ text: 'Damages nearby enemies', type: 'good' });
            }

            // Periodic effects (onUpdate)
            if (code.includes('world.onUpdate')) {
                effects.push({ text: 'Has ongoing effects', type: 'neutral' });
            }

            // Player hit callbacks
            if (code.includes('world.onPlayerHit')) {
                effects.push({ text: 'Triggers on taking damage', type: 'neutral' });
            }

            // Win condition
            if (code.includes('world.win()')) {
                effects.push({ text: 'Can win the game!', type: 'good' });
            }

            // Active abilities
            if (code.includes('player.onButtonPress')) {
                const match = code.match(/player\.onButtonPress\s*\(\s*['"]([YAB])['"]/);
                const nameMatch = code.match(/name:\s*['"]([^'"]+)['"]/);
                const button = match ? match[1] : '?';
                const abilityName = nameMatch ? nameMatch[1] : 'Ability';
                effects.push({
                    text: `[${button}] ${abilityName}`,
                    type: 'good'
                });
            }

            // Movement behaviors
            if (code.includes('.setMovement')) {
                const moveMatch = code.match(/setMovement\s*\(\s*['"](\w+)['"]/g);
                if (moveMatch) {
                    const behaviors = [...new Set(moveMatch.map(m => m.match(/['"](\w+)['"]/)[1]))];
                    effects.push({
                        text: `Movement: ${behaviors.join(', ')}`,
                        type: 'neutral'
                    });
                }
            }

            // If no effects detected, add a generic one
            if (effects.length === 0) {
                effects.push({ text: 'Unknown effects', type: 'neutral' });
            }

            return effects;
        },

        // Render sprite to the panel canvas
        renderSprite(sprite) {
            const scale = 8; // Larger scale for visibility
            const width = sprite[0].length;
            const height = sprite.length;

            // Resize canvas to fit sprite
            this.canvas.width = width * scale;
            this.canvas.height = height * scale;

            // Clear canvas
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // Draw sprite
            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const char = sprite[row][col];
                    const color = PALETTE[char];

                    if (color && color !== 'transparent') {
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(col * scale, row * scale, scale, scale);
                    }
                }
            }
        },

        // Update panel with new item
        update(item) {
            if (!item) return;

            // If we already have a current item displayed, move it to journal
            if (lastCollectedItem && lastCollectedItem !== item) {
                this.addToJournal(lastCollectedItem);
            }

            // Show content, hide empty state
            document.getElementById('item-empty').style.display = 'none';
            document.getElementById('item-content').classList.add('active');

            // Update name
            document.getElementById('item-name').textContent = item.name;

            // Update description
            document.getElementById('item-desc-text').textContent = item.description;

            // Render sprite
            this.renderSprite(item.sprite);

            // Parse and display effects
            const effects = this.parseEffects(item.code);
            const effectsList = document.getElementById('item-effects');
            effectsList.innerHTML = '';

            for (const effect of effects) {
                const li = document.createElement('li');
                li.textContent = effect.text;
                li.className = `effect-${effect.type}`;
                effectsList.appendChild(li);
            }
        }
    };

    // ============================================================
    // EXPLORER CLAUDE - Autonomous playtesting agent
    // ============================================================

    const explorer = {
        running: false,
        targetForges: 10,
        completedForges: 0,
        observations: [],      // API observations
        apiMisses: {},         // Tracks undefined property access counts
        codePatterns: {},      // Tracks patterns found in generated code
        generatedItems: [],    // Stores raw code from each item for analysis
        lastAction: null,
        actionQueue: [],       // Commands to execute

        // UI elements (set in init)
        panel: null,
        toggle: null,
        status: null,
        log: null,

        // Initialize explorer
        init() {
            this.panel = document.getElementById('explorer-panel');
            this.toggle = document.getElementById('explorer-toggle');
            this.status = document.getElementById('explorer-status');
            this.log = document.getElementById('explorer-log');

            // Toggle panel
            this.toggle.addEventListener('click', () => {
                this.panel.classList.toggle('collapsed');
                this.toggle.textContent = this.panel.classList.contains('collapsed') ? '◀' : '▶';
            });

            // Run/Stop buttons
            document.getElementById('btn-run').addEventListener('click', () => this.start());
            document.getElementById('btn-stop').addEventListener('click', () => this.stop());

            // Start state update loop
            setInterval(() => this.updateStateDisplay(), 100);

            this.logMessage('Explorer initialized. Click Run to start autonomous exploration.');
        },

        // Update state display in panel
        updateStateDisplay() {
            document.getElementById('state-player').textContent =
                `(${Math.floor(player.x)}, ${Math.floor(player.y)})`;
            document.getElementById('state-forge').textContent = forge.state;
            document.getElementById('state-items').textContent = journal.length;
            document.getElementById('state-entities').textContent = world.entities.length;
            document.getElementById('state-forges').textContent = this.completedForges;
            document.getElementById('state-misses').textContent = Object.keys(this.apiMisses).length;
            document.getElementById('state-patterns').textContent = Object.keys(this.codePatterns).length;
        },

        // Log message to explorer console
        logMessage(msg) {
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            this.log.innerHTML += `<div>[${time}] ${msg}</div>`;
            this.log.scrollTop = this.log.scrollHeight;
            console.log('[Explorer]', msg);
        },

        // Add observation
        addObservation(type, message) {
            const obs = { type, message, time: Date.now() };
            this.observations.push(obs);

            const list = document.getElementById('observations-list');
            const div = document.createElement('div');
            div.className = `observation ${type}`;
            div.textContent = message;
            list.appendChild(div);
            list.scrollTop = list.scrollHeight;

            // Keep only last 50
            while (list.children.length > 50) {
                list.removeChild(list.firstChild);
            }
        },

        // Record API miss (undefined property access)
        recordApiMiss(property, context) {
            const key = `${context}.${property}`;
            this.apiMisses[key] = (this.apiMisses[key] || 0) + 1;
            if (this.apiMisses[key] === 1) {
                // First time seeing this miss
                this.addObservation('failure', `Missing: ${key}`);
            }
        },

        // Record API success
        recordApiSuccess(method, context) {
            this.addObservation('success', `Used: ${context}.${method}()`);
        },

        // Analyze item code and track patterns
        analyzeItemCode(item) {
            if (!item || !item.code) return;

            // Store the item for later inspection
            this.generatedItems.push({
                name: item.name,
                description: item.description,
                code: item.code
            });

            // Run pattern analysis
            const patterns = analyzeGeneratedCode(item.code);
            for (const [pattern, count] of Object.entries(patterns)) {
                this.codePatterns[pattern] = (this.codePatterns[pattern] || 0) + count;
                this.addObservation('pattern', `${pattern}: ${count}x`);
            }
        },

        // Start exploration
        async start() {
            if (this.running) return;

            this.running = true;
            this.completedForges = 0;
            this.observations = [];
            this.apiMisses = {};
            this.codePatterns = {};
            this.generatedItems = [];
            document.getElementById('observations-list').innerHTML = '';

            this.setStatus('running');
            document.getElementById('btn-run').disabled = true;
            document.getElementById('btn-stop').disabled = false;

            this.logMessage(`Starting exploration: ${this.targetForges} forge cycles`);
            this.addObservation('info', 'Exploration started');

            // Run the exploration loop
            await this.explorationLoop();
        },

        // Stop exploration
        stop() {
            this.running = false;
            this.setStatus('idle');
            document.getElementById('btn-run').disabled = false;
            document.getElementById('btn-stop').disabled = true;
            this.logMessage('Exploration stopped by user');
            this.generateReport();
        },

        setStatus(status) {
            this.status.textContent = status;
            this.status.className = status;
        },

        // Main exploration loop
        async explorationLoop() {
            while (this.running && this.completedForges < this.targetForges) {
                try {
                    // Get current state
                    const state = this.getGameState();

                    // Decide action via inference
                    const action = await this.decideAction(state);

                    if (!this.running) break;

                    // Execute action
                    await this.executeAction(action);

                    // Track forge completion via items collected
                    const currentItems = journal.length;
                    if (currentItems > this.completedForges) {
                        this.completedForges = currentItems;
                        this.logMessage(`Forge ${this.completedForges}/${this.targetForges} complete`);
                    }

                    // Small delay between actions
                    await this.sleep(100);

                } catch (e) {
                    this.logMessage(`Error: ${e.message}`);
                    this.setStatus('error');
                    await this.sleep(1000);
                    this.setStatus('running');
                }
            }

            if (this.completedForges >= this.targetForges) {
                this.logMessage('Exploration complete!');
                this.stop();
            }
        },

        // Get current game state for inference
        getGameState() {
            return {
                player: { x: player.x, y: player.y, onGround: player.onGround },
                forge: { x: forge.x, y: forge.y, state: forge.state },
                nearForge: isPlayerNearForge(),
                itemsCollected: journal.length,
                entities: world.entities.length,
                spawnedItem: spawnedItem ? { name: spawnedItem.name, x: spawnedItem.x, y: spawnedItem.y } : null,
                completedForges: this.completedForges,
                targetForges: this.targetForges
            };
        },

        // Decide next action - using simple heuristics first, can upgrade to inference later
        async decideAction(state) {
            // Simple state machine for now:
            // 1. If item spawned, go collect it (move + jump if needed)
            // 2. If forge idle and near it, activate
            // 3. If forge idle and not near, move toward it
            // 4. If forge forging/ready, wait

            if (state.spawnedItem) {
                // Move toward and collect item
                const dx = state.spawnedItem.x - state.player.x;
                const dy = state.spawnedItem.y - state.player.y;

                // If we're not horizontally aligned, move toward item
                if (Math.abs(dx) > 30) {
                    return { type: 'move', direction: dx > 0 ? 'right' : 'left', duration: 100 };
                }

                // If item is above us, jump to reach it
                if (dy < -20 && state.player.onGround) {
                    return { type: 'jump', duration: 400 };
                }

                // Otherwise keep trying to touch it
                if (Math.abs(dx) > 5) {
                    return { type: 'move', direction: dx > 0 ? 'right' : 'left', duration: 50 };
                }

                return { type: 'wait_for_item', duration: 100 };
            }

            if (state.forge.state === 'idle') {
                if (state.nearForge) {
                    return { type: 'interact' };
                } else {
                    // Move toward forge
                    const dx = state.forge.x - state.player.x;
                    return { type: 'move', direction: dx > 0 ? 'right' : 'left', duration: 150 };
                }
            }

            if (state.forge.state === 'forging') {
                return { type: 'wait', duration: 500 };
            }

            if (state.forge.state === 'ready') {
                return { type: 'wait_for_item', duration: 100 };
            }

            if (state.forge.state === 'failed') {
                return { type: 'wait', duration: 500 };
            }

            return { type: 'wait', duration: 100 };
        },

        // Execute an action
        async executeAction(action) {
            this.lastAction = action;

            switch (action.type) {
                case 'move':
                    // Inject movement input
                    explorerInput.moveX = action.direction === 'right' ? 1 : -1;
                    await this.sleep(action.duration || 100);
                    explorerInput.moveX = 0;
                    break;

                case 'jump':
                    explorerInput.jump = true;
                    await this.sleep(50);
                    explorerInput.jump = false;
                    await this.sleep(action.duration || 300);
                    break;

                case 'interact':
                    this.logMessage('Activating forge...');
                    explorerInput.interact = true;
                    await this.sleep(50);
                    explorerInput.interact = false;
                    await this.sleep(200);
                    break;

                case 'wait':
                case 'wait_for_item':
                    await this.sleep(action.duration || 100);
                    break;
            }
        },

        sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        },

        // Generate final report
        generateReport() {
            this.logMessage('');
            this.logMessage('========================================');
            this.logMessage('       EXPLORER REPORT');
            this.logMessage('========================================');
            this.logMessage(`Items generated: ${this.generatedItems.length}`);
            this.logMessage(`Items collected: ${journal.length}`);
            this.logMessage('');

            // Code patterns - sorted by frequency
            const sortedPatterns = Object.entries(this.codePatterns)
                .sort((a, b) => b[1] - a[1]);

            if (sortedPatterns.length > 0) {
                this.logMessage('CODE PATTERNS DETECTED:');
                this.logMessage('(patterns the item AI tried to use)');
                this.logMessage('----------------------------------------');
                for (const [pattern, count] of sortedPatterns) {
                    this.logMessage(`  ${pattern}: ${count}x`);
                }
                this.logMessage('');
            }

            // Runtime API misses
            if (Object.keys(this.apiMisses).length > 0) {
                this.logMessage('RUNTIME API MISSES:');
                this.logMessage('(undefined properties accessed at runtime)');
                this.logMessage('----------------------------------------');
                for (const [key, count] of Object.entries(this.apiMisses)) {
                    this.logMessage(`  ${key}: ${count}x`);
                }
                this.logMessage('');
            }

            this.logMessage('========================================');
            this.logMessage('Report saved to window.explorerReport');
            this.logMessage('Access generated code: window.explorerReport.generatedItems');

            // Store report in window for external access
            window.explorerReport = {
                completedForges: this.completedForges,
                itemsCollected: journal.length,
                codePatterns: { ...this.codePatterns },
                apiMisses: { ...this.apiMisses },
                generatedItems: [...this.generatedItems],
                observations: [...this.observations],
                journal: [...journal],
                // Helper to print report as text
                print() {
                    console.log('\n=== EXPLORER REPORT ===');
                    console.log(`Items: ${this.itemsCollected}`);
                    console.log('\nCode patterns (what AI tried to use):');
                    Object.entries(this.codePatterns)
                        .sort((a, b) => b[1] - a[1])
                        .forEach(([p, c]) => console.log(`  ${p}: ${c}x`));
                    if (Object.keys(this.apiMisses).length > 0) {
                        console.log('\nRuntime misses:');
                        Object.entries(this.apiMisses)
                            .forEach(([k, c]) => console.log(`  ${k}: ${c}x`));
                    }
                }
            };
        }
    };

    // Explorer input state (overrides normal input when explorer is running)
    const explorerInput = {
        moveX: 0,
        jump: false,
        interact: false
    };

    // Modify getInput to merge explorer input
    const originalGetInput = getInput;

    // ============================================================
    // INITIALIZATION
    // ============================================================

    function init() {
        console.log('Oneshot Climb - M1: Static Frame');
        console.log('Controls:');
        console.log('  Xbox Controller: Left stick move, A jump, X interact');
        console.log('  Keyboard: WASD/Arrows move, Space jump, E interact');

        // Check for existing gamepads (in case already connected)
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadIndex = i;
                controllerConnected = true;
                controllerPrompt.classList.add('hidden');
                console.log('Found existing gamepad:', gamepads[i].id);
                break;
            }
        }

        // Initialize Item Detail Panel
        itemPanel.init();

        // Initialize Explorer Claude
        explorer.init();

        // Start game loop
        requestAnimationFrame(gameLoop);
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    </script>
</body>
</html>
