<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oneshot Climb</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Controller prompt overlay */
        #controller-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff8e7;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #controller-prompt.hidden {
            opacity: 0;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="controller-prompt">Press any button on controller to connect...</div>

    <script>
    // ============================================================
    // ONESHOT CLIMB - M1: Static Frame
    // A roguelike where AI generates game mechanics at runtime
    // ============================================================

    // ============================================================
    // PAPER PIXELS PALETTE
    // Fixed palette - all sprites use these characters/colors
    // ============================================================
    const PALETTE = {
        '.': 'transparent',           // Transparent
        'k': '#5d4e37',              // Outline/dark brown
        'w': '#fff8e7',              // Warm white/highlight
        'g': '#7d9f5a',              // Muted green
        'b': '#6b8fa3',              // Soft blue
        'r': '#c45c4a',              // Soft red
        'o': '#e67e22',              // Orange
        'y': '#f4d03f',              // Yellow
        'p': '#d4a5a5',              // Pink
        't': '#a8c0b0',              // Teal
        'n': '#8b7355',              // Brown (for platforms)
        'd': '#4a3728',              // Dark brown
    };

    const BACKGROUND_COLOR = '#f5f0e1'; // Cream/paper background

    // ============================================================
    // GAME CONSTANTS
    // ============================================================
    const PIXEL_SCALE = 4;           // Each sprite pixel = 4 screen pixels
    const CANVAS_WIDTH = 960;
    const CANVAS_HEIGHT = 540;

    // Player constants
    const PLAYER_SPEED = 200;        // pixels per second
    const JUMP_VELOCITY = -550;      // initial jump velocity (strong enough to reach platforms)
    const GRAVITY = 1200;            // gravity acceleration (snappier feel)
    const GROUND_Y = CANVAS_HEIGHT - 60; // ground level

    // ============================================================
    // SPRITES (Paper Pixels style - ASCII art)
    // ============================================================

    // Player sprite - blue character with yellow eyes (8x12)
    const PLAYER_SPRITE = [
        '........',
        '..bbbb..',
        '..byyb..',
        '...bb...',
        '.bbbbbb.',
        '...bb...',
        '...bb...',
        '...bb...',
        '...bb...',
        '...bb...',
        '..b..b..',
        '..b..b..',
    ];

    // Forge sprite - magical anvil/altar (16x16)
    const FORGE_SPRITE = [
        '......yyyy......',
        '.....yooooy.....',
        '....yorrrroy....',
        '...yorrrrroy....',
        '....yorrrroy....',
        '.....yooooy.....',
        '......yyyy......',
        '....kkkkkkkk....',
        '...kttttttttk...',
        '..ktttttttttk...',
        '..ktttttttttk...',
        '.kttttttttttk...',
        '.kttttttttttk...',
        'kkkkkkkkkkkkkk..',
        'knnnnnnnnnnnnk..',
        '.kkkkkkkkkkkk...',
    ];

    // Platform tile (16x8) - simple wooden platform
    const PLATFORM_SPRITE = [
        'knnnnnnnnnnnnnnk',
        'knnnnnnnnnnnnnk.',
        'kddnnddnnddnndk.',
        'kddddddddddddk..',
        'kdddddddddddk...',
        '.kdddddddddk....',
        '..kkkkkkkkk.....',
        '................',
    ];

    // ============================================================
    // GAME STATE
    // ============================================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const controllerPrompt = document.getElementById('controller-prompt');

    // Set canvas size
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Player state
    const player = {
        x: 100,
        y: GROUND_Y - 48,  // Start on ground
        vx: 0,
        vy: 0,
        width: 8 * PIXEL_SCALE,
        height: 12 * PIXEL_SCALE,
        onGround: true,
        facingRight: true,
    };

    // Platforms - static for M1
    const platforms = [
        // Ground platform (long)
        { x: 0, y: GROUND_Y, width: CANVAS_WIDTH, height: 60, isGround: true },
        // Floating platforms
        { x: 200, y: 380, width: 128, height: 32 },
        { x: 450, y: 300, width: 128, height: 32 },
        { x: 700, y: 350, width: 128, height: 32 },
        { x: 350, y: 200, width: 128, height: 32 },  // Forge platform
    ];

    // Forge - on the high platform
    const forge = {
        x: 380,
        y: 200 - 64,  // On top of the platform at y=200
        width: 16 * PIXEL_SCALE,
        height: 16 * PIXEL_SCALE,
        state: 'idle',        // 'idle' | 'forging' | 'ready' | 'failed'
        forgeTimer: 0,        // Time spent forging
        forgeDuration: 2.0,   // Minimum visual duration (inference may take longer)
        pendingItem: null,    // Item waiting to be collected
        inferencePromise: null, // Active inference call
    };

    // Journal - tracks collected items for prompt context
    const journal = [];

    // Spawned item waiting to be picked up
    let spawnedItem = null;

    // Controller state
    let gamepadIndex = null;
    let controllerConnected = false;

    // Keyboard state (fallback)
    const keys = {};

    // ============================================================
    // INFERENCE & ITEM GENERATION
    // ============================================================

    const ITEM_GENERATION_PROMPT = `You are generating a unique item for a roguelite game. Return ONLY JavaScript code - no markdown, no explanation.

When the player picks up your item it should cause a change to the world. Giving the player new powers? Spawning entities? Changing stats or physics? Be creative!

## Item Registration API

Call registerItem() exactly once to define your item:

  registerItem({
    name: "Item Name",           // short, evocative name
    description: "What it does", // prose description for the journal
    sprite: \`
      ..kkkk..
      .kwwwwk.
      kwwwwwwk
      kwwwwwwk
      .kwwwwk.
      ..kkkk..
      ........
      ........
    \`,  // 8x8 grid using palette below

    onPickup() {
      // Effects go here - runs when player collects the item
    }
  });

## Sprite Palette (8x8 grid)
Use ONLY these characters:
  . = transparent
  k = outline/dark brown
  w = warm white/highlight
  g = muted green
  b = soft blue
  r = soft red
  o = orange
  y = yellow
  p = pink
  t = teal
  n = brown
  d = dark brown

## Player API (available in onPickup)

  player.x, player.y           // position (read-only)
  player.heal(amount)
  player.damage(amount)
  player.addSpeed(multiplier)  // e.g. 0.2 for 20% faster
  player.addJumpPower(amount)  // e.g. 50 for higher jumps

## World API (available in onPickup)

  // Define new entity types (must define before spawning!)
  world.defineEntity("typename", {
    sprite: \`...8x8...\`,
    damage: 5,           // optional: damage on contact
    lifetime: 3,         // optional: seconds before despawn
    friendly: true,      // optional: doesn't hurt player
  });

  world.spawn("typename", x, y)     // spawn a defined entity
  world.onUpdate(callback)          // register per-frame logic: fn(dt)
  world.onPlayerHit(callback)       // when player takes damage
  world.damageNearby(x, y, radius, amount)
  world.entities                    // current entities array
  world.win()                       // trigger win condition

## Constraints
- No infinite loops
- No window/document/eval/fetch access
- Keep it under 40 lines
- Call registerItem exactly once

## Example

registerItem({
  name: "Ember Heart",
  description: "A smoldering core that leaves fire in your wake",
  sprite: \`
    ...rr...
    ..roor..
    .roooor.
    .roooor.
    ..roor..
    ...rr...
    ........
    ........
  \`,

  onPickup() {
    world.defineEntity("fire", {
      sprite: \`
        ...rr...
        ..royr..
        .royyor.
        ..royr..
        ...rr...
        ........
        ........
        ........
      \`,
      damage: 3,
      lifetime: 2
    });

    world.onUpdate((dt) => {
      if (Math.random() < 0.1) {
        world.spawn("fire", player.x, player.y + 20);
      }
    });
  }
});`;

    /**
     * Build the full prompt with current game state
     */
    function buildItemPrompt() {
        let prompt = ITEM_GENERATION_PROMPT;

        // Add current state
        prompt += `\n\n## Current State\n`;
        prompt += `- Items collected so far: ${journal.length}\n`;

        // Add journal context
        if (journal.length > 0) {
            prompt += `\n## Previous Items (for narrative continuity)\n`;
            for (const item of journal.slice(-5)) {  // Last 5 items
                prompt += `- "${item.name}": ${item.description}\n`;
            }
            prompt += `\nBuild on what exists. Create something that complements or contrasts with previous items.\n`;
        } else {
            prompt += `\nThis is the first item! Set the tone for the run.\n`;
        }

        return prompt;
    }

    /**
     * Call inference API to generate item
     */
    async function generateItem() {
        const prompt = buildItemPrompt();

        try {
            const response = await fetch('/api/inference/anthropic/messages', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    messages: [{ role: 'user', content: prompt }],
                    model: 'claude-haiku-4-5-20251001',  // Fast model for gameplay
                    max_tokens: 1500
                })
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error || 'Inference failed');
            }

            const data = await response.json();
            const code = data.content[0].text;

            console.log('Generated item code:', code);
            return parseItemCode(code);

        } catch (e) {
            console.error('Inference error:', e);
            return null;
        }
    }

    /**
     * Forbidden patterns for safety
     */
    const FORBIDDEN_PATTERNS = [
        'window', 'document', 'eval', 'Function(',
        'fetch', 'XMLHttpRequest', 'import',
        'while(true)', 'for(;;)', 'localStorage', 'sessionStorage'
    ];

    /**
     * Parse and validate generated item code
     * Returns item metadata + raw code for later execution
     */
    function parseItemCode(code) {
        // Strip markdown code fences if present
        code = code.replace(/^```(?:javascript|js)?\n?/i, '').replace(/\n?```$/i, '').trim();

        // Check for forbidden patterns
        for (const pattern of FORBIDDEN_PATTERNS) {
            if (code.includes(pattern)) {
                console.warn('Forbidden pattern found:', pattern);
                return null;
            }
        }

        // Create item registry to capture metadata only
        let registeredItem = null;

        const registerItem = (def) => {
            if (registeredItem) {
                throw new Error('registerItem called twice');
            }

            // Validate required fields
            if (!def.name || !def.description || !def.sprite) {
                throw new Error('Missing required item fields');
            }

            // Parse sprite (trim and split into lines)
            const spriteLines = def.sprite.trim().split('\n').map(line => line.trim());

            // Only capture metadata - we'll re-execute for effects
            registeredItem = {
                name: def.name,
                description: def.description,
                sprite: spriteLines,
            };
        };

        // First pass: validate syntax and capture metadata
        try {
            const execute = new Function('registerItem', 'player', 'world', code);
            // Use stub APIs - just capturing metadata
            execute(registerItem, {}, {});
        } catch (e) {
            console.error('Item code execution error:', e);
            return null;
        }

        if (!registeredItem) {
            console.warn('No item was registered');
            return null;
        }

        // Store raw code for execution at pickup time
        registeredItem.code = code;
        return registeredItem;
    }

    // ============================================================
    // SPRITE RENDERING
    // ============================================================

    /**
     * Render an ASCII sprite to canvas
     * @param {string[]} sprite - Array of strings representing pixel rows
     * @param {number} x - X position (top-left)
     * @param {number} y - Y position (top-left)
     * @param {number} scale - Pixel scale (default PIXEL_SCALE)
     * @param {boolean} flipX - Flip horizontally
     */
    function drawSprite(sprite, x, y, scale = PIXEL_SCALE, flipX = false) {
        const width = sprite[0].length;
        const height = sprite.length;

        for (let row = 0; row < height; row++) {
            for (let col = 0; col < width; col++) {
                const char = sprite[row][flipX ? width - 1 - col : col];
                const color = PALETTE[char];

                if (color && color !== 'transparent') {
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        Math.floor(x + col * scale),
                        Math.floor(y + row * scale),
                        scale,
                        scale
                    );
                }
            }
        }
    }

    /**
     * Draw a platform using tiled sprites
     */
    function drawPlatform(platform) {
        if (platform.isGround) {
            // Ground is just a solid color
            ctx.fillStyle = PALETTE['n'];
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            // Top edge
            ctx.fillStyle = PALETTE['g'];
            ctx.fillRect(platform.x, platform.y, platform.width, 8);
            return;
        }

        // Tile the platform sprite
        const tileWidth = 16 * PIXEL_SCALE;
        const tilesNeeded = Math.ceil(platform.width / tileWidth);

        for (let i = 0; i < tilesNeeded; i++) {
            const tileX = platform.x + i * tileWidth;
            // Clip to platform width
            if (tileX < platform.x + platform.width) {
                drawSprite(PLATFORM_SPRITE, tileX, platform.y);
            }
        }
    }

    // ============================================================
    // INPUT HANDLING
    // ============================================================

    // Keyboard events (fallback)
    window.addEventListener('keydown', (e) => {
        keys[e.code] = true;
    });

    window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    // Gamepad connection
    window.addEventListener('gamepadconnected', (e) => {
        console.log('Gamepad connected:', e.gamepad.id);
        gamepadIndex = e.gamepad.index;
        controllerConnected = true;
        controllerPrompt.classList.add('hidden');
    });

    window.addEventListener('gamepaddisconnected', (e) => {
        console.log('Gamepad disconnected');
        if (e.gamepad.index === gamepadIndex) {
            gamepadIndex = null;
            controllerConnected = false;
            controllerPrompt.classList.remove('hidden');
        }
    });

    /**
     * Get current input state from controller or keyboard
     */
    function getInput() {
        const input = {
            moveX: 0,
            jump: false,
            interact: false,
        };

        // Try gamepad first
        if (gamepadIndex !== null) {
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];

            if (gamepad) {
                // Left stick X axis (with deadzone)
                const deadzone = 0.15;
                const stickX = gamepad.axes[0];
                if (Math.abs(stickX) > deadzone) {
                    input.moveX = stickX;
                }

                // A button = Jump (button 0)
                input.jump = gamepad.buttons[0].pressed;

                // X button = Interact (button 2)
                input.interact = gamepad.buttons[2].pressed;
            }
        }

        // Keyboard fallback (or combine)
        if (keys['ArrowLeft'] || keys['KeyA']) {
            input.moveX = -1;
        }
        if (keys['ArrowRight'] || keys['KeyD']) {
            input.moveX = 1;
        }
        if (keys['ArrowUp'] || keys['KeyW'] || keys['Space']) {
            input.jump = true;
        }
        if (keys['KeyE'] || keys['KeyX']) {
            input.interact = true;
        }

        return input;
    }

    // Track previous input state for edge detection
    let prevInput = { jump: false, interact: false };

    // ============================================================
    // PHYSICS & COLLISION
    // ============================================================

    /**
     * Check if player is colliding with a platform from above
     */
    function checkPlatformCollision(px, py, pw, ph) {
        for (const platform of platforms) {
            // Simple AABB collision
            const onPlatform =
                px + pw > platform.x &&
                px < platform.x + platform.width &&
                py + ph >= platform.y &&
                py + ph <= platform.y + 20 && // Only collide from above
                player.vy >= 0;  // Only when falling

            if (onPlatform) {
                return platform;
            }
        }
        return null;
    }

    /**
     * Update player physics
     */
    function updatePlayer(dt, input) {
        // Horizontal movement (with speed modifier from items)
        player.vx = input.moveX * PLAYER_SPEED * playerAPI.speedMultiplier;

        // Update facing direction
        if (input.moveX > 0) player.facingRight = true;
        if (input.moveX < 0) player.facingRight = false;

        // Jump (only on button press, not hold) - with jump bonus from items
        if (input.jump && !prevInput.jump && player.onGround) {
            player.vy = JUMP_VELOCITY - playerAPI.jumpBonus;
            player.onGround = false;
        }

        // Apply gravity
        if (!player.onGround) {
            player.vy += GRAVITY * dt;
        }

        // Update position
        player.x += player.vx * dt;
        player.y += player.vy * dt;

        // Check platform collision
        const platform = checkPlatformCollision(
            player.x, player.y, player.width, player.height
        );

        if (platform) {
            player.y = platform.y - player.height;
            player.vy = 0;
            player.onGround = true;
        } else if (player.vy > 0) {
            player.onGround = false;
        }

        // Screen bounds
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > CANVAS_WIDTH) {
            player.x = CANVAS_WIDTH - player.width;
        }

        // Prevent falling through bottom (safety)
        if (player.y > CANVAS_HEIGHT) {
            player.y = GROUND_Y - player.height;
            player.vy = 0;
            player.onGround = true;
        }
    }

    // ============================================================
    // FORGE LOGIC
    // ============================================================

    /**
     * Check if player is near the forge
     */
    function isPlayerNearForge() {
        const distToForge = Math.hypot(
            (player.x + player.width/2) - (forge.x + forge.width/2),
            (player.y + player.height/2) - (forge.y + forge.height/2)
        );
        return distToForge < 80;
    }

    /**
     * Check if player is touching the spawned item
     */
    function isPlayerTouchingItem() {
        if (!spawnedItem) return false;
        return (
            player.x < spawnedItem.x + spawnedItem.width &&
            player.x + player.width > spawnedItem.x &&
            player.y < spawnedItem.y + spawnedItem.height &&
            player.y + player.height > spawnedItem.y
        );
    }

    /**
     * Update forge state
     */
    function updateForge(dt, input) {
        if (forge.state === 'idle') {
            // Check for interaction (button press, not hold)
            if (input.interact && !prevInput.interact && isPlayerNearForge()) {
                forge.state = 'forging';
                forge.forgeTimer = 0;
                forge.pendingItem = null;
                console.log('Forge activated! Calling inference...');

                // Start inference (async)
                forge.inferencePromise = generateItem().then(item => {
                    forge.pendingItem = item;
                    forge.inferencePromise = null;
                    console.log('Inference complete:', item ? item.name : 'failed');
                });
            }
        } else if (forge.state === 'forging') {
            forge.forgeTimer += dt;

            // Wait for both: minimum visual duration AND inference complete
            const visualReady = forge.forgeTimer >= forge.forgeDuration;
            const inferenceReady = forge.inferencePromise === null;

            if (visualReady && inferenceReady) {
                if (forge.pendingItem) {
                    // Success! Spawn the item
                    forge.state = 'ready';
                    spawnedItem = {
                        ...forge.pendingItem,
                        x: forge.x + forge.width/2 - 16,  // Center above forge
                        y: forge.y - 40,
                        width: 8 * PIXEL_SCALE,
                        height: 8 * PIXEL_SCALE,
                    };
                    console.log('Item spawned:', spawnedItem.name);
                } else {
                    // Failure - creation unstable
                    forge.state = 'failed';
                    forge.forgeTimer = 0;  // Reuse for failure animation
                    console.log('Creation unstable - forge failed');
                }
            }
        } else if (forge.state === 'ready') {
            // Item can be collected by touching it
            if (isPlayerTouchingItem()) {
                collectItem(spawnedItem);
                spawnedItem = null;
                forge.state = 'idle';
            }
        } else if (forge.state === 'failed') {
            // Brief failure animation then reset
            forge.forgeTimer += dt;
            if (forge.forgeTimer >= 1.5) {
                forge.state = 'idle';
            }
        }
    }

    // ============================================================
    // WORLD & PLAYER APIs (for item effects)
    // ============================================================

    // Persistent world state for item effects
    const world = {
        entityTypes: {},
        entities: [],
        updateCallbacks: [],
        playerHitCallbacks: [],
        hasWon: false,

        defineEntity(name, def) {
            console.log('Entity type defined:', name, def);
            // Parse sprite
            if (def.sprite) {
                def.sprite = def.sprite.trim().split('\n').map(line => line.trim());
            }
            this.entityTypes[name] = def;
        },

        spawn(type, x, y) {
            const typeDef = this.entityTypes[type];
            if (!typeDef) {
                console.warn('Unknown entity type:', type);
                return null;
            }
            const entity = {
                type,
                x,
                y,
                width: 8 * PIXEL_SCALE,
                height: 8 * PIXEL_SCALE,
                lifetime: typeDef.lifetime || Infinity,
                age: 0,
                ...typeDef
            };
            this.entities.push(entity);
            return entity;
        },

        onUpdate(callback) {
            console.log('Update callback registered');
            this.updateCallbacks.push(callback);
        },

        onPlayerHit(callback) {
            console.log('Player hit callback registered');
            this.playerHitCallbacks.push(callback);
        },

        damageNearby(x, y, radius, amount) {
            console.log('Area damage:', amount, 'at', x, y, 'radius', radius);
            // Damage entities in radius
            for (const entity of this.entities) {
                if (entity.friendly) continue;
                const dist = Math.hypot(entity.x - x, entity.y - y);
                if (dist < radius) {
                    entity.health = (entity.health || 0) - amount;
                }
            }
        },

        win() {
            if (this.hasWon) return;
            this.hasWon = true;
            console.log('=== YOU WIN! ===');
            // Could trigger a win screen here
        }
    };

    // Player API proxy (exposes safe interface)
    const playerAPI = {
        get x() { return player.x; },
        get y() { return player.y; },
        speedMultiplier: 1,
        jumpBonus: 0,

        heal(amount) {
            console.log('Player healed:', amount);
            // TODO: implement health system
        },

        damage(amount) {
            console.log('Player damaged:', amount);
            // TODO: implement health system
        },

        addSpeed(multiplier) {
            this.speedMultiplier += multiplier;
            console.log('Player speed now:', this.speedMultiplier);
        },

        addJumpPower(amount) {
            this.jumpBonus += amount;
            console.log('Player jump bonus now:', this.jumpBonus);
        }
    };

    /**
     * Collect an item - re-execute code with real APIs
     */
    function collectItem(item) {
        console.log('=== Collecting item:', item.name, '===');

        // Add to journal
        journal.push({
            name: item.name,
            description: item.description
        });

        // Re-execute the full code with real APIs
        // This time onPickup will run with working player/world refs
        try {
            let pickupFn = null;

            const registerItem = (def) => {
                // Capture the onPickup function
                pickupFn = def.onPickup;
            };

            // Execute with real APIs in scope
            const execute = new Function('registerItem', 'player', 'world', item.code);
            execute(registerItem, playerAPI, world);

            // Now call onPickup if it exists
            if (pickupFn) {
                pickupFn();
                console.log('Item effects activated!');
            }
        } catch (e) {
            console.warn('onPickup error:', e);
            // Item still collected, effects just don't work
        }
    }

    /**
     * Update world entities and callbacks
     */
    function updateWorld(dt) {
        // Run item update callbacks
        for (const callback of world.updateCallbacks) {
            try {
                callback(dt);
            } catch (e) {
                console.warn('Update callback error:', e);
            }
        }

        // Update entities
        for (let i = world.entities.length - 1; i >= 0; i--) {
            const entity = world.entities[i];
            entity.age += dt;

            // Remove expired entities
            if (entity.age >= entity.lifetime) {
                world.entities.splice(i, 1);
                continue;
            }

            // Check collision with player (for damaging entities)
            if (entity.damage && !entity.friendly) {
                const touching =
                    player.x < entity.x + entity.width &&
                    player.x + player.width > entity.x &&
                    player.y < entity.y + entity.height &&
                    player.y + player.height > entity.y;

                if (touching) {
                    console.log('Player hit by', entity.type, 'for', entity.damage);
                    // TODO: apply damage to player
                    for (const cb of world.playerHitCallbacks) {
                        try { cb(entity.damage, entity); } catch (e) {}
                    }
                }
            }
        }
    }

    /**
     * Render world entities
     */
    function renderEntities() {
        for (const entity of world.entities) {
            if (entity.sprite) {
                drawSprite(entity.sprite, entity.x, entity.y, PIXEL_SCALE);
            }
        }
    }

    // ============================================================
    // RENDERING
    // ============================================================

    function render() {
        // Clear with background color
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw platforms
        for (const platform of platforms) {
            drawPlatform(platform);
        }

        // Draw forge
        drawSprite(FORGE_SPRITE, forge.x, forge.y, PIXEL_SCALE);

        // Draw world entities (from item effects)
        renderEntities();

        // Draw player
        drawSprite(
            PLAYER_SPRITE,
            player.x,
            player.y,
            PIXEL_SCALE,
            !player.facingRight  // Flip if facing left
        );

        // Draw spawned item if exists
        if (spawnedItem) {
            // Floating animation
            const floatY = Math.sin(Date.now() / 300) * 4;
            drawSprite(spawnedItem.sprite, spawnedItem.x, spawnedItem.y + floatY, PIXEL_SCALE);

            // Glow effect
            const glow = Math.sin(Date.now() / 200) * 0.2 + 0.5;
            ctx.fillStyle = `rgba(244, 208, 63, ${glow * 0.3})`;
            ctx.beginPath();
            ctx.arc(
                spawnedItem.x + spawnedItem.width/2,
                spawnedItem.y + spawnedItem.height/2 + floatY,
                30,
                0, Math.PI * 2
            );
            ctx.fill();

            // Item name label
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            const nameWidth = ctx.measureText(spawnedItem.name).width + 16;
            ctx.fillRect(
                spawnedItem.x + spawnedItem.width/2 - nameWidth/2,
                spawnedItem.y - 25,
                nameWidth, 20
            );
            ctx.fillStyle = '#f4d03f';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(spawnedItem.name, spawnedItem.x + spawnedItem.width/2, spawnedItem.y - 10);
            ctx.textAlign = 'left';
        }

        // Draw forge state feedback
        const nearForge = isPlayerNearForge();

        if (forge.state === 'forging') {
            // Forging animation - pulsing glow
            const pulse = Math.sin(forge.forgeTimer * 8) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(244, 208, 63, ${pulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(
                forge.x + forge.width/2,
                forge.y + forge.height/2,
                60 + Math.sin(forge.forgeTimer * 6) * 10,
                0, Math.PI * 2
            );
            ctx.fill();

            // Progress indicator (pulsing since we don't know exact duration)
            const barWidth = 80;
            const barX = forge.x + forge.width/2 - barWidth/2;
            const barY = forge.y - 35;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(barX - 2, barY - 2, barWidth + 4, 14);
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(barX, barY, barWidth, 10);

            // Animated progress (bounces while waiting for inference)
            const progress = forge.pendingItem !== null ? 1.0 :
                (Math.sin(forge.forgeTimer * 3) * 0.3 + 0.5);
            ctx.fillStyle = '#f4d03f';
            ctx.fillRect(barX, barY, barWidth * progress, 10);

            ctx.fillStyle = '#fff8e7';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Forging...', forge.x + forge.width/2, barY - 6);
            ctx.textAlign = 'left';

        } else if (forge.state === 'ready') {
            // Item ready - gentle glow on forge
            const sparkle = Math.sin(Date.now() / 100) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(244, 208, 63, ${sparkle * 0.3})`;
            ctx.beginPath();
            ctx.arc(forge.x + forge.width/2, forge.y + forge.height/2, 40, 0, Math.PI * 2);
            ctx.fill();

        } else if (forge.state === 'failed') {
            // Failed - red fizzle effect
            const fade = 1 - (forge.forgeTimer / 1.5);
            ctx.fillStyle = `rgba(196, 92, 74, ${fade * 0.5})`;
            ctx.beginPath();
            ctx.arc(forge.x + forge.width/2, forge.y + forge.height/2, 50 * fade, 0, Math.PI * 2);
            ctx.fill();

            // Failure message
            ctx.fillStyle = `rgba(0, 0, 0, ${fade * 0.7})`;
            ctx.fillRect(forge.x - 30, forge.y - 35, 140, 24);
            ctx.fillStyle = `rgba(196, 92, 74, ${fade})`;
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Creation unstable...', forge.x + forge.width/2, forge.y - 18);
            ctx.textAlign = 'left';

        } else if (nearForge) {
            // Idle - show interact prompt
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(forge.x - 10, forge.y - 30, 100, 24);
            ctx.fillStyle = '#fff8e7';
            ctx.font = '14px monospace';
            ctx.fillText(controllerConnected ? '[X] Forge' : '[E] Forge', forge.x, forge.y - 12);
        }

        // Debug: show status
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(10, 10, 200, 80);
        ctx.fillStyle = '#fff8e7';
        ctx.font = '12px monospace';
        ctx.fillText(`Controller: ${controllerConnected ? 'Connected' : 'None'}`, 20, 28);
        ctx.fillText(`Player: (${Math.floor(player.x)}, ${Math.floor(player.y)})`, 20, 44);
        ctx.fillText(`Forge: ${forge.state}`, 20, 60);
        ctx.fillText(`Items: ${journal.length}`, 20, 76);
    }

    // ============================================================
    // GAME LOOP
    // ============================================================

    let lastTime = 0;

    function gameLoop(timestamp) {
        // Calculate delta time (capped at 100ms to prevent spiral of death)
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;

        // Get input
        const input = getInput();

        // Update
        updatePlayer(dt, input);
        updateForge(dt, input);
        updateWorld(dt);

        // Store previous input for edge detection
        prevInput = { ...input };

        // Render
        render();

        // Next frame
        requestAnimationFrame(gameLoop);
    }

    // ============================================================
    // INITIALIZATION
    // ============================================================

    function init() {
        console.log('Oneshot Climb - M1: Static Frame');
        console.log('Controls:');
        console.log('  Xbox Controller: Left stick move, A jump, X interact');
        console.log('  Keyboard: WASD/Arrows move, Space jump, E interact');

        // Check for existing gamepads (in case already connected)
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadIndex = i;
                controllerConnected = true;
                controllerPrompt.classList.add('hidden');
                console.log('Found existing gamepad:', gamepads[i].id);
                break;
            }
        }

        // Start game loop
        requestAnimationFrame(gameLoop);
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    </script>
</body>
</html>
