<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oneshot Climb</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Controller prompt overlay */
        #controller-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff8e7;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #controller-prompt.hidden {
            opacity: 0;
        }

        /* Explorer Panel */
        #explorer-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: #1a1a2e;
            border-left: 2px solid #5d4e37;
            font-family: monospace;
            font-size: 12px;
            color: #fff8e7;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        #explorer-panel.collapsed {
            transform: translateX(280px);
        }

        #explorer-toggle {
            position: absolute;
            left: -32px;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 80px;
            background: #1a1a2e;
            border: 2px solid #5d4e37;
            border-right: none;
            border-radius: 8px 0 0 8px;
            color: #f4d03f;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        #explorer-header {
            padding: 12px;
            background: #2a2a4e;
            border-bottom: 1px solid #5d4e37;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #explorer-header h3 {
            margin: 0;
            color: #f4d03f;
            font-size: 14px;
        }

        #explorer-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            background: #4a3728;
        }

        #explorer-status.running { background: #7d9f5a; color: #1a1a2e; }
        #explorer-status.error { background: #c45c4a; }

        #explorer-state {
            padding: 12px;
            border-bottom: 1px solid #5d4e37;
            flex-shrink: 0;
        }

        #explorer-state h4 {
            margin: 0 0 8px 0;
            color: #a8c0b0;
            font-size: 11px;
            text-transform: uppercase;
        }

        .state-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 12px;
        }

        .state-label { color: #6b8fa3; }
        .state-value { color: #fff8e7; text-align: right; }

        #explorer-observations {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            border-bottom: 1px solid #5d4e37;
        }

        #explorer-observations h4 {
            margin: 0 0 8px 0;
            color: #a8c0b0;
            font-size: 11px;
            text-transform: uppercase;
        }

        .observation {
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            background: #2a2a4e;
        }

        .observation.success { border-left: 3px solid #7d9f5a; }
        .observation.failure { border-left: 3px solid #c45c4a; }
        .observation.info { border-left: 3px solid #6b8fa3; }

        #explorer-log {
            height: 120px;
            overflow-y: auto;
            padding: 8px 12px;
            background: #0a0a1e;
            font-size: 10px;
            color: #a8c0b0;
        }

        #explorer-controls {
            padding: 12px;
            display: flex;
            gap: 8px;
        }

        #explorer-controls button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #btn-run {
            background: #7d9f5a;
            color: #1a1a2e;
        }

        #btn-run:hover { background: #8daf6a; }
        #btn-run:disabled { background: #4a4a4a; color: #888; cursor: not-allowed; }

        #btn-stop {
            background: #c45c4a;
            color: #fff8e7;
        }

        #btn-stop:hover { background: #d46c5a; }
        #btn-stop:disabled { background: #4a4a4a; color: #888; cursor: not-allowed; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="controller-prompt">Press any button on controller to connect...</div>

    <!-- Explorer Panel -->
    <div id="explorer-panel" class="collapsed">
        <button id="explorer-toggle">◀</button>
        <div id="explorer-header">
            <h3>Explorer Claude</h3>
            <span id="explorer-status">idle</span>
        </div>
        <div id="explorer-state">
            <h4>Game State</h4>
            <div class="state-grid">
                <span class="state-label">Player:</span>
                <span class="state-value" id="state-player">-</span>
                <span class="state-label">Forge:</span>
                <span class="state-value" id="state-forge">-</span>
                <span class="state-label">Items:</span>
                <span class="state-value" id="state-items">0</span>
                <span class="state-label">Entities:</span>
                <span class="state-value" id="state-entities">0</span>
                <span class="state-label">Forges done:</span>
                <span class="state-value" id="state-forges">0</span>
                <span class="state-label">API misses:</span>
                <span class="state-value" id="state-misses">0</span>
                <span class="state-label">Patterns:</span>
                <span class="state-value" id="state-patterns">0</span>
            </div>
        </div>
        <div id="explorer-observations">
            <h4>API Observations</h4>
            <div id="observations-list">
                <div class="observation info">Waiting to start...</div>
            </div>
        </div>
        <div id="explorer-log"></div>
        <div id="explorer-controls">
            <button id="btn-run">Run (10 forges)</button>
            <button id="btn-stop" disabled>Stop</button>
        </div>
    </div>

    <script>
    // ============================================================
    // ONESHOT CLIMB - M1: Static Frame
    // A roguelike where AI generates game mechanics at runtime
    // ============================================================

    // ============================================================
    // PAPER PIXELS PALETTE
    // Fixed palette - all sprites use these characters/colors
    // ============================================================
    const PALETTE = {
        '.': 'transparent',           // Transparent
        'k': '#5d4e37',              // Outline/dark brown
        'w': '#fff8e7',              // Warm white/highlight
        'g': '#7d9f5a',              // Muted green
        'b': '#6b8fa3',              // Soft blue
        'r': '#c45c4a',              // Soft red
        'o': '#e67e22',              // Orange
        'y': '#f4d03f',              // Yellow
        'p': '#d4a5a5',              // Pink
        't': '#a8c0b0',              // Teal
        'n': '#8b7355',              // Brown (for platforms)
        'd': '#4a3728',              // Dark brown
    };

    const BACKGROUND_COLOR = '#f5f0e1'; // Cream/paper background

    // ============================================================
    // GAME CONSTANTS
    // ============================================================
    const PIXEL_SCALE = 4;           // Each sprite pixel = 4 screen pixels
    const CANVAS_WIDTH = 960;
    const CANVAS_HEIGHT = 540;

    // Player constants
    const PLAYER_SPEED = 200;        // pixels per second
    const JUMP_VELOCITY = -550;      // initial jump velocity (strong enough to reach platforms)
    const GRAVITY = 1200;            // gravity acceleration (snappier feel)
    const GROUND_Y = CANVAS_HEIGHT - 60; // ground level

    // ============================================================
    // SPRITES (Paper Pixels style - ASCII art)
    // ============================================================

    // Player sprite - blue character with yellow eyes (8x12)
    const PLAYER_SPRITE = [
        '........',
        '..bbbb..',
        '..byyb..',
        '...bb...',
        '.bbbbbb.',
        '...bb...',
        '...bb...',
        '...bb...',
        '...bb...',
        '...bb...',
        '..b..b..',
        '..b..b..',
    ];

    // Forge sprite - magical anvil/altar (16x16)
    const FORGE_SPRITE = [
        '......yyyy......',
        '.....yooooy.....',
        '....yorrrroy....',
        '...yorrrrroy....',
        '....yorrrroy....',
        '.....yooooy.....',
        '......yyyy......',
        '....kkkkkkkk....',
        '...kttttttttk...',
        '..ktttttttttk...',
        '..ktttttttttk...',
        '.kttttttttttk...',
        '.kttttttttttk...',
        'kkkkkkkkkkkkkk..',
        'knnnnnnnnnnnnk..',
        '.kkkkkkkkkkkk...',
    ];

    // Platform tile (16x8) - simple wooden platform
    const PLATFORM_SPRITE = [
        'knnnnnnnnnnnnnnk',
        'knnnnnnnnnnnnnk.',
        'kddnnddnnddnndk.',
        'kddddddddddddk..',
        'kdddddddddddk...',
        '.kdddddddddk....',
        '..kkkkkkkkk.....',
        '................',
    ];

    // ============================================================
    // GAME STATE
    // ============================================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const controllerPrompt = document.getElementById('controller-prompt');

    // Set canvas size
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Player state
    const player = {
        x: 100,
        y: GROUND_Y - 48,  // Start on ground
        vx: 0,
        vy: 0,
        width: 8 * PIXEL_SCALE,
        height: 12 * PIXEL_SCALE,
        onGround: true,
        facingRight: true,
        health: 100,
        maxHealth: 100,
        invincibleTimer: 0,  // Brief invincibility after taking damage
    };

    // Platforms - static for M1
    const platforms = [
        // Ground platform (long)
        { x: 0, y: GROUND_Y, width: CANVAS_WIDTH, height: 60, isGround: true },
        // Floating platforms
        { x: 200, y: 380, width: 128, height: 32 },
        { x: 450, y: 300, width: 128, height: 32 },
        { x: 700, y: 350, width: 128, height: 32 },
        { x: 350, y: 200, width: 128, height: 32 },  // Forge platform
    ];

    // Forge - right at player start for easy testing
    const forge = {
        x: 100,
        y: GROUND_Y - 64,  // On the ground, at player start
        width: 16 * PIXEL_SCALE,
        height: 16 * PIXEL_SCALE,
        state: 'idle',        // 'idle' | 'forging' | 'ready' | 'failed'
        forgeTimer: 0,        // Time spent forging
        forgeDuration: 2.0,   // Minimum visual duration (inference may take longer)
        pendingItem: null,    // Item waiting to be collected
        inferencePromise: null, // Active inference call
    };

    // Journal - tracks collected items for prompt context
    const journal = [];

    // Spawned item waiting to be picked up
    let spawnedItem = null;

    // Controller state
    let gamepadIndex = null;
    let controllerConnected = false;

    // Keyboard state (fallback)
    const keys = {};

    // ============================================================
    // INFERENCE & ITEM GENERATION
    // ============================================================

    const ITEM_GENERATION_PROMPT = `You are generating a unique item for a roguelite game. Return ONLY JavaScript code - no markdown, no explanation.

## Item Variety (IMPORTANT!)

Items should NOT always be beneficial. Create variety:

- **Pure good** (~30%): Buffs, heals, friendly helpers
- **Pure bad** (~30%): Spawns enemies, debuffs, hazards
- **Mixed** (~40%): Tradeoffs! Speed boost + chasing enemy, heal + boss spawn, powerful ability + penalty

ENEMIES make the game interesting! Don't be afraid to spawn dangerous things.
Set \`friendly: false\` to create hostile entities that damage the player.

Enemy spawn patterns to consider:
- Single tough enemy (boss-like)
- Horde of weak enemies
- Continuous drip spawning (enemies appear over time)
- Triggered spawns (when player uses ability, takes damage, etc)

When the player picks up your item it should cause a change to the world. Giving the player new powers? Spawning entities? Changing stats or physics? Be creative!

## Item Registration API

Call registerItem() exactly once to define your item:

  registerItem({
    name: "Item Name",           // short, evocative name
    description: "What it does", // prose description for the journal
    sprite: \`
      ..kkkk..
      .kwwwwk.
      kwwwwwwk
      kwwwwwwk
      .kwwwwk.
      ..kkkk..
      ........
      ........
    \`,  // 8x8 grid using palette below

    onPickup() {
      // Effects go here - runs when player collects the item
    }
  });

## Sprite Palette (8x8 grid)
Use ONLY these characters:
  . = transparent
  k = outline/dark brown
  w = warm white/highlight
  g = muted green
  b = soft blue
  r = soft red
  o = orange
  y = yellow
  p = pink
  t = teal
  n = brown
  d = dark brown

## Player API (available in onPickup)

  player.x, player.y           // position (read-only)
  player.heal(amount)
  player.damage(amount)
  player.addSpeed(multiplier)  // e.g. 0.2 for 20% faster
  player.addJumpPower(amount)  // e.g. 50 for higher jumps

## World API (available in onPickup)

  // Define new entity types (must define before spawning!)
  world.defineEntity("typename", {
    sprite: \`...8x8...\`,
    damage: 5,           // optional: damage on contact
    lifetime: 3,         // optional: seconds before despawn
    friendly: true,      // optional: doesn't hurt player
    health: 10,          // optional: health points (dies at 0)
    vx: 0, vy: 0,        // optional: initial velocity
    flying: true,        // optional: ignores gravity
  });

  // Spawning returns the entity object
  const e = world.spawn("typename", x, y);

  // Entity properties (read/write after spawning):
  e.x, e.y               // position - can be modified!
  e.vx, e.vy             // velocity - entities move automatically
  e.health               // reduce to 0 to kill
  e.type                 // the type name string

  // World methods
  world.onUpdate(callback)          // register per-frame logic: fn(dt)
  world.onPlayerHit(callback)       // when player takes damage
  world.damageNearby(x, y, radius, amount)
  world.removeEntity(entity)        // explicitly remove an entity
  world.getEntitiesInRadius(x, y, r) // find entities near a point
  world.getEntitiesOfType("type")   // find entities by type
  world.entities                    // all entities array
  world.win()                       // trigger win condition

## Constraints
- No infinite loops
- No window/document/eval/fetch access
- Keep it under 40 lines
- Call registerItem exactly once

## Example

registerItem({
  name: "Gravity Well",
  description: "Spawns orbs that orbit you and pull enemies inward",
  sprite: \`
    ..kbbk..
    .kbttbk.
    kbttttbk
    kbttttbk
    .kbttbk.
    ..kbbk..
    ........
    ........
  \`,

  onPickup() {
    world.defineEntity("orb", {
      sprite: \`
        ..tt....
        .tttt...
        .tttt...
        ..tt....
        ........
        ........
        ........
        ........
      \`,
      friendly: true,
      flying: true
    });

    // Spawn 3 orbiting orbs
    for (let i = 0; i < 3; i++) {
      world.spawn("orb", player.x, player.y - 40);
    }

    let angle = 0;
    world.onUpdate((dt) => {
      angle += dt * 3;
      // Make orbs orbit the player
      const orbs = world.getEntitiesOfType("orb");
      orbs.forEach((orb, i) => {
        const a = angle + (i * Math.PI * 2 / 3);
        orb.x = player.x + Math.cos(a) * 60;
        orb.y = player.y + Math.sin(a) * 40;
      });

      // Pull nearby enemies toward player
      const nearby = world.getEntitiesInRadius(player.x, player.y, 150);
      nearby.forEach(e => {
        if (!e.friendly) {
          const dx = player.x - e.x;
          const dy = player.y - e.y;
          e.vx += dx * 0.5 * dt;
          e.vy += dy * 0.5 * dt;
        }
      });
    });
  }
});

## Example 2: Enemy Item (DANGEROUS!)

registerItem({
  name: "Cursed Totem",
  description: "Spawns hunting spirits that pursue relentlessly",
  sprite: \`
    ..rrrr..
    .rkkkrk.
    rkwwwwkr
    rkwkkwkr
    rkwwwwkr
    .rkkkrk.
    ..rrrr..
    ........
  \`,

  onPickup() {
    world.defineEntity("hunter", {
      sprite: \`
        ..pp....
        .pppp...
        ppkkpp..
        pppppp..
        .pppp...
        ..pp....
        ........
        ........
      \`,
      damage: 8,
      health: 15,
      friendly: false  // HOSTILE - damages player on contact!
    });

    // Spawn initial hunters
    for (let i = 0; i < 3; i++) {
      const x = Math.random() * 700 + 50;
      const e = world.spawn("hunter", x, 100);
      e.vy = 50;  // Fall down
    }

    // Hunters chase the player
    world.onUpdate((dt) => {
      world.getEntitiesOfType("hunter").forEach(e => {
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        e.vx += Math.sign(dx) * 200 * dt;
        e.vy += Math.sign(dy) * 100 * dt;
        // Limit speed
        e.vx = Math.max(-150, Math.min(150, e.vx));
      });
    });
  }
});`;

    /**
     * Build the full prompt with current game state
     */
    function buildItemPrompt() {
        let prompt = ITEM_GENERATION_PROMPT;

        // Add current state
        prompt += `\n\n## Current State\n`;
        prompt += `- Items collected so far: ${journal.length}\n`;

        // Count enemies and friendlies
        const enemies = world.entities.filter(e => !e.friendly).length;
        const friendlies = world.entities.filter(e => e.friendly).length;
        prompt += `- Enemies on screen: ${enemies}\n`;
        prompt += `- Friendly entities: ${friendlies}\n`;

        // Encourage variety based on current state
        if (enemies === 0 && journal.length > 0) {
            prompt += `\n⚠️ NO ENEMIES! Consider creating something dangerous to spice things up!\n`;
        } else if (enemies > 5) {
            prompt += `\n⚠️ Many enemies active! Maybe create something helpful... or add even MORE chaos!\n`;
        }

        // Add journal context
        if (journal.length > 0) {
            prompt += `\n## Previous Items (for narrative continuity)\n`;
            for (const item of journal.slice(-5)) {  // Last 5 items
                prompt += `- "${item.name}": ${item.description}\n`;
            }
            prompt += `\nBuild on what exists. Create something that complements or contrasts with previous items.\n`;
        } else {
            prompt += `\nThis is the first item! Set the tone for the run.\n`;
        }

        return prompt;
    }

    /**
     * Call inference API to generate item
     */
    async function generateItem() {
        const prompt = buildItemPrompt();

        try {
            const response = await fetch('/api/inference/anthropic/messages', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    messages: [{ role: 'user', content: prompt }],
                    model: 'claude-haiku-4-5-20251001',  // Fast model for gameplay
                    max_tokens: 1500
                })
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error || 'Inference failed');
            }

            const data = await response.json();
            const code = data.content[0].text;

            console.log('Generated item code:', code);
            return parseItemCode(code);

        } catch (e) {
            console.error('Inference error:', e);
            return null;
        }
    }

    /**
     * Forbidden patterns for safety
     */
    const FORBIDDEN_PATTERNS = [
        'window', 'document', 'eval', 'Function(',
        'fetch', 'XMLHttpRequest', 'import',
        'while(true)', 'for(;;)', 'localStorage', 'sessionStorage'
    ];

    /**
     * Patterns to detect in generated code for API discovery
     */
    const API_PATTERNS = [
        // Entity property access
        { regex: /entity\.x\b(?!\s*[+\-*\/]?=)/g, name: 'entity.x (read)' },
        { regex: /entity\.x\s*[+\-*\/]?=/g, name: 'entity.x (write)' },
        { regex: /entity\.y\b(?!\s*[+\-*\/]?=)/g, name: 'entity.y (read)' },
        { regex: /entity\.y\s*[+\-*\/]?=/g, name: 'entity.y (write)' },
        { regex: /entity\.vx/g, name: 'entity.vx' },
        { regex: /entity\.vy/g, name: 'entity.vy' },
        { regex: /entity\.velocity/g, name: 'entity.velocity' },
        { regex: /entity\.health/g, name: 'entity.health' },
        { regex: /entity\.type\b/g, name: 'entity.type' },
        { regex: /entity\.id\b/g, name: 'entity.id' },
        { regex: /entity\.frozen/g, name: 'entity.frozen' },
        { regex: /entity\.remove|entity\.destroy/g, name: 'entity.remove()' },

        // World queries
        { regex: /world\.entities\b/g, name: 'world.entities (direct)' },
        { regex: /world\.getEntities\w*/g, name: 'world.getEntities*()' },
        { regex: /world\.findEntit/g, name: 'world.findEntit*()' },
        { regex: /world\.getNearby/g, name: 'world.getNearby()' },

        // Entity iteration
        { regex: /for\s*\([^)]*entit/gi, name: 'for-loop entities' },
        { regex: /\.forEach\s*\([^)]*entit/gi, name: 'forEach entities' },
        { regex: /\.filter\s*\([^)]*entit/gi, name: 'filter entities' },

        // Player props
        { regex: /player\.health/g, name: 'player.health' },
        { regex: /player\.vx/g, name: 'player.vx' },
        { regex: /player\.vy/g, name: 'player.vy' },
        { regex: /player\.speed\b/g, name: 'player.speed' },

        // World modification
        { regex: /world\.removeEntity/g, name: 'world.removeEntity()' },
        { regex: /world\.destroyEntity/g, name: 'world.destroyEntity()' },

        // Timing
        { regex: /setTimeout/g, name: 'setTimeout' },
        { regex: /setInterval/g, name: 'setInterval' },
    ];

    /**
     * Analyze generated code for API usage patterns
     */
    function analyzeGeneratedCode(code) {
        const results = {};
        for (const pattern of API_PATTERNS) {
            const matches = code.match(pattern.regex);
            if (matches) {
                results[pattern.name] = matches.length;
            }
        }
        return results;
    }

    /**
     * Parse and validate generated item code
     * Returns item metadata + raw code for later execution
     */
    function parseItemCode(code) {
        // Strip markdown code fences if present
        code = code.replace(/^```(?:javascript|js)?\n?/i, '').replace(/\n?```$/i, '').trim();

        // Check for forbidden patterns
        for (const pattern of FORBIDDEN_PATTERNS) {
            if (code.includes(pattern)) {
                console.warn('Forbidden pattern found:', pattern);
                return null;
            }
        }

        // Create item registry to capture metadata only
        let registeredItem = null;

        const registerItem = (def) => {
            if (registeredItem) {
                throw new Error('registerItem called twice');
            }

            // Validate required fields
            if (!def.name || !def.description || !def.sprite) {
                throw new Error('Missing required item fields');
            }

            // Parse sprite (trim and split into lines)
            const spriteLines = def.sprite.trim().split('\n').map(line => line.trim());

            // Only capture metadata - we'll re-execute for effects
            registeredItem = {
                name: def.name,
                description: def.description,
                sprite: spriteLines,
            };
        };

        // First pass: validate syntax and capture metadata
        try {
            const execute = new Function('registerItem', 'player', 'world', code);
            // Use stub APIs - just capturing metadata
            execute(registerItem, {}, {});
        } catch (e) {
            console.error('Item code execution error:', e);
            return null;
        }

        if (!registeredItem) {
            console.warn('No item was registered');
            return null;
        }

        // Store raw code for execution at pickup time
        registeredItem.code = code;
        return registeredItem;
    }

    // ============================================================
    // SPRITE RENDERING
    // ============================================================

    /**
     * Render an ASCII sprite to canvas
     * @param {string[]} sprite - Array of strings representing pixel rows
     * @param {number} x - X position (top-left)
     * @param {number} y - Y position (top-left)
     * @param {number} scale - Pixel scale (default PIXEL_SCALE)
     * @param {boolean} flipX - Flip horizontally
     */
    function drawSprite(sprite, x, y, scale = PIXEL_SCALE, flipX = false) {
        const width = sprite[0].length;
        const height = sprite.length;

        for (let row = 0; row < height; row++) {
            for (let col = 0; col < width; col++) {
                const char = sprite[row][flipX ? width - 1 - col : col];
                const color = PALETTE[char];

                if (color && color !== 'transparent') {
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        Math.floor(x + col * scale),
                        Math.floor(y + row * scale),
                        scale,
                        scale
                    );
                }
            }
        }
    }

    /**
     * Draw a platform using tiled sprites
     */
    function drawPlatform(platform) {
        if (platform.isGround) {
            // Ground is just a solid color
            ctx.fillStyle = PALETTE['n'];
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            // Top edge
            ctx.fillStyle = PALETTE['g'];
            ctx.fillRect(platform.x, platform.y, platform.width, 8);
            return;
        }

        // Tile the platform sprite
        const tileWidth = 16 * PIXEL_SCALE;
        const tilesNeeded = Math.ceil(platform.width / tileWidth);

        for (let i = 0; i < tilesNeeded; i++) {
            const tileX = platform.x + i * tileWidth;
            // Clip to platform width
            if (tileX < platform.x + platform.width) {
                drawSprite(PLATFORM_SPRITE, tileX, platform.y);
            }
        }
    }

    // ============================================================
    // INPUT HANDLING
    // ============================================================

    // Keyboard events (fallback)
    window.addEventListener('keydown', (e) => {
        keys[e.code] = true;
    });

    window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    // Gamepad connection
    window.addEventListener('gamepadconnected', (e) => {
        console.log('Gamepad connected:', e.gamepad.id);
        gamepadIndex = e.gamepad.index;
        controllerConnected = true;
        controllerPrompt.classList.add('hidden');
    });

    window.addEventListener('gamepaddisconnected', (e) => {
        console.log('Gamepad disconnected');
        if (e.gamepad.index === gamepadIndex) {
            gamepadIndex = null;
            controllerConnected = false;
            controllerPrompt.classList.remove('hidden');
        }
    });

    /**
     * Get current input state from controller or keyboard
     */
    function getInput() {
        const input = {
            moveX: 0,
            jump: false,
            interact: false,
        };

        // Explorer input takes priority when running
        if (explorer.running) {
            input.moveX = explorerInput.moveX;
            input.jump = explorerInput.jump;
            input.interact = explorerInput.interact;
            return input;
        }

        // Try gamepad first
        if (gamepadIndex !== null) {
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];

            if (gamepad) {
                // Left stick X axis (with deadzone)
                const deadzone = 0.15;
                const stickX = gamepad.axes[0];
                if (Math.abs(stickX) > deadzone) {
                    input.moveX = stickX;
                }

                // A button = Jump (button 0)
                input.jump = gamepad.buttons[0].pressed;

                // X button = Interact (button 2)
                input.interact = gamepad.buttons[2].pressed;
            }
        }

        // Keyboard fallback (or combine)
        if (keys['ArrowLeft'] || keys['KeyA']) {
            input.moveX = -1;
        }
        if (keys['ArrowRight'] || keys['KeyD']) {
            input.moveX = 1;
        }
        if (keys['ArrowUp'] || keys['KeyW'] || keys['Space']) {
            input.jump = true;
        }
        if (keys['KeyE'] || keys['KeyX']) {
            input.interact = true;
        }

        return input;
    }

    // Track previous input state for edge detection
    let prevInput = { jump: false, interact: false };

    // ============================================================
    // PHYSICS & COLLISION
    // ============================================================

    /**
     * Check if player is colliding with a platform from above
     */
    function checkPlatformCollision(px, py, pw, ph) {
        for (const platform of platforms) {
            // Simple AABB collision
            const onPlatform =
                px + pw > platform.x &&
                px < platform.x + platform.width &&
                py + ph >= platform.y &&
                py + ph <= platform.y + 20 && // Only collide from above
                player.vy >= 0;  // Only when falling

            if (onPlatform) {
                return platform;
            }
        }
        return null;
    }

    /**
     * Update player physics
     */
    function updatePlayer(dt, input) {
        // Tick invincibility timer
        if (player.invincibleTimer > 0) {
            player.invincibleTimer -= dt;
        }

        // Horizontal movement (with speed modifier from items)
        player.vx = input.moveX * PLAYER_SPEED * playerAPI.speedMultiplier;

        // Update facing direction
        if (input.moveX > 0) player.facingRight = true;
        if (input.moveX < 0) player.facingRight = false;

        // Jump (only on button press, not hold) - with jump bonus from items
        if (input.jump && !prevInput.jump && player.onGround) {
            player.vy = JUMP_VELOCITY - playerAPI.jumpBonus;
            player.onGround = false;
        }

        // Apply gravity
        if (!player.onGround) {
            player.vy += GRAVITY * dt;
        }

        // Update position
        player.x += player.vx * dt;
        player.y += player.vy * dt;

        // Check platform collision
        const platform = checkPlatformCollision(
            player.x, player.y, player.width, player.height
        );

        if (platform) {
            player.y = platform.y - player.height;
            player.vy = 0;
            player.onGround = true;
        } else if (player.vy > 0) {
            player.onGround = false;
        }

        // Screen bounds
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > CANVAS_WIDTH) {
            player.x = CANVAS_WIDTH - player.width;
        }

        // Prevent falling through bottom (safety)
        if (player.y > CANVAS_HEIGHT) {
            player.y = GROUND_Y - player.height;
            player.vy = 0;
            player.onGround = true;
        }
    }

    // ============================================================
    // FORGE LOGIC
    // ============================================================

    /**
     * Check if player is near the forge
     */
    function isPlayerNearForge() {
        const distToForge = Math.hypot(
            (player.x + player.width/2) - (forge.x + forge.width/2),
            (player.y + player.height/2) - (forge.y + forge.height/2)
        );
        return distToForge < 80;
    }

    /**
     * Check if player is touching the spawned item
     */
    function isPlayerTouchingItem() {
        if (!spawnedItem) return false;
        return (
            player.x < spawnedItem.x + spawnedItem.width &&
            player.x + player.width > spawnedItem.x &&
            player.y < spawnedItem.y + spawnedItem.height &&
            player.y + player.height > spawnedItem.y
        );
    }

    /**
     * Update forge state
     */
    function updateForge(dt, input) {
        if (forge.state === 'idle') {
            // Check for interaction (button press, not hold)
            if (input.interact && !prevInput.interact && isPlayerNearForge()) {
                forge.state = 'forging';
                forge.forgeTimer = 0;
                forge.pendingItem = null;
                console.log('Forge activated! Calling inference...');

                // Start inference (async)
                forge.inferencePromise = generateItem().then(item => {
                    forge.pendingItem = item;
                    forge.inferencePromise = null;
                    console.log('Inference complete:', item ? item.name : 'failed');
                });
            }
        } else if (forge.state === 'forging') {
            forge.forgeTimer += dt;

            // Wait for both: minimum visual duration AND inference complete
            const visualReady = forge.forgeTimer >= forge.forgeDuration;
            const inferenceReady = forge.inferencePromise === null;

            if (visualReady && inferenceReady) {
                if (forge.pendingItem) {
                    // Success! Spawn the item
                    forge.state = 'ready';
                    spawnedItem = {
                        ...forge.pendingItem,
                        x: forge.x + forge.width/2 - 16,  // Center above forge
                        y: forge.y - 40,
                        width: 8 * PIXEL_SCALE,
                        height: 8 * PIXEL_SCALE,
                    };
                    console.log('Item spawned:', spawnedItem.name);
                } else {
                    // Failure - creation unstable
                    forge.state = 'failed';
                    forge.forgeTimer = 0;  // Reuse for failure animation
                    console.log('Creation unstable - forge failed');
                }
            }
        } else if (forge.state === 'ready') {
            // Item can be collected by touching it
            if (isPlayerTouchingItem()) {
                collectItem(spawnedItem);
                spawnedItem = null;
                forge.state = 'idle';
            }
        } else if (forge.state === 'failed') {
            // Brief failure animation then reset
            forge.forgeTimer += dt;
            if (forge.forgeTimer >= 1.5) {
                forge.state = 'idle';
            }
        }
    }

    // ============================================================
    // WORLD & PLAYER APIs (for item effects)
    // ============================================================

    // Persistent world state for item effects
    const world = {
        entityTypes: {},
        entities: [],
        updateCallbacks: [],
        playerHitCallbacks: [],
        hasWon: false,

        defineEntity(name, def) {
            console.log('Entity type defined:', name, def);
            // Parse sprite
            if (def.sprite) {
                def.sprite = def.sprite.trim().split('\n').map(line => line.trim());
            }
            this.entityTypes[name] = def;
        },

        spawn(type, x, y) {
            const typeDef = this.entityTypes[type];
            if (!typeDef) {
                console.warn('Unknown entity type:', type);
                return null;
            }
            const entity = {
                type,
                x,
                y,
                vx: typeDef.vx || 0,    // Velocity (can be set by item code)
                vy: typeDef.vy || 0,
                width: 8 * PIXEL_SCALE,
                height: 8 * PIXEL_SCALE,
                lifetime: typeDef.lifetime || Infinity,
                health: typeDef.health || 10,  // Default health
                age: 0,
                ...typeDef
            };
            this.entities.push(entity);
            return entity;
        },

        onUpdate(callback) {
            console.log('Update callback registered');
            this.updateCallbacks.push(callback);
        },

        onPlayerHit(callback) {
            console.log('Player hit callback registered');
            this.playerHitCallbacks.push(callback);
        },

        damageNearby(x, y, radius, amount) {
            // Damage entities in radius (throttled logging)
            let damaged = 0;
            for (const entity of this.entities) {
                if (entity.friendly) continue;
                const dist = Math.hypot(entity.x - x, entity.y - y);
                if (dist < radius) {
                    entity.health = (entity.health || 10) - amount;
                    damaged++;
                }
            }
            if (damaged > 0) {
                console.log('Area damage:', amount, 'hit', damaged, 'entities');
            }
        },

        removeEntity(entity) {
            const idx = this.entities.indexOf(entity);
            if (idx !== -1) {
                this.entities.splice(idx, 1);
                return true;
            }
            return false;
        },

        getEntitiesInRadius(x, y, radius) {
            return this.entities.filter(e => {
                const dist = Math.hypot(e.x - x, e.y - y);
                return dist < radius;
            });
        },

        getEntitiesOfType(type) {
            return this.entities.filter(e => e.type === type);
        },

        win() {
            if (this.hasWon) return;
            this.hasWon = true;
            console.log('=== YOU WIN! ===');
            // Could trigger a win screen here
        }
    };

    // Player API proxy (exposes safe interface)
    const playerAPI = {
        get x() { return player.x; },
        get y() { return player.y; },
        speedMultiplier: 1,
        jumpBonus: 0,

        heal(amount) {
            player.health = Math.min(player.maxHealth, player.health + amount);
            console.log('Player healed:', amount, '→', player.health);
        },

        damage(amount) {
            if (player.invincibleTimer > 0) return; // I-frames
            player.health = Math.max(0, player.health - amount);
            player.invincibleTimer = 0.5; // Half second of invincibility
            console.log('Player damaged:', amount, '→', player.health);
            if (player.health <= 0) {
                console.log('PLAYER DIED!');
                // TODO: death/respawn
            }
        },

        addSpeed(multiplier) {
            this.speedMultiplier += multiplier;
            console.log('Player speed now:', this.speedMultiplier);
        },

        addJumpPower(amount) {
            this.jumpBonus += amount;
            console.log('Player jump bonus now:', this.jumpBonus);
        }
    };

    /**
     * Create instrumented proxy for observation
     */
    function createInstrumentedProxy(target, name) {
        return new Proxy(target, {
            get(obj, prop) {
                // Check if property exists
                if (prop in obj) {
                    const value = obj[prop];
                    // Log method calls
                    if (typeof value === 'function') {
                        return function(...args) {
                            if (explorer.running) {
                                explorer.recordApiSuccess(prop, name);
                            }
                            return value.apply(obj, args);
                        };
                    }
                    return value;
                } else {
                    // Property doesn't exist - record the miss!
                    if (explorer.running) {
                        explorer.recordApiMiss(prop, name);
                    }
                    console.warn(`[API Miss] ${name}.${prop} is undefined`);
                    return undefined;
                }
            },
            set(obj, prop, value) {
                // Record attempts to set properties
                if (!(prop in obj)) {
                    if (explorer.running) {
                        explorer.recordApiMiss(prop + ' (write)', name);
                    }
                    console.warn(`[API Miss] Attempted to set ${name}.${prop}`);
                }
                obj[prop] = value;
                return true;
            }
        });
    }

    /**
     * Collect an item - re-execute code with real APIs
     */
    function collectItem(item) {
        console.log('=== Collecting item:', item.name, '===');

        // Add to journal
        journal.push({
            name: item.name,
            description: item.description
        });

        // Analyze code patterns if explorer is running
        if (explorer.running) {
            explorer.analyzeItemCode(item);
        }

        // Create instrumented versions of APIs for observation
        const instrumentedPlayer = createInstrumentedProxy(playerAPI, 'player');
        const instrumentedWorld = createInstrumentedProxy(world, 'world');

        // Re-execute the full code with instrumented APIs
        // This time onPickup will run with working player/world refs
        try {
            let pickupFn = null;

            const registerItem = (def) => {
                // Capture the onPickup function
                pickupFn = def.onPickup;
            };

            // Execute with instrumented APIs in scope
            const execute = new Function('registerItem', 'player', 'world', item.code);
            execute(registerItem, instrumentedPlayer, instrumentedWorld);

            // Now call onPickup if it exists
            if (pickupFn) {
                pickupFn();
                console.log('Item effects activated!');
                if (explorer.running) {
                    explorer.addObservation('success', `Item collected: ${item.name}`);
                }
            }
        } catch (e) {
            console.warn('onPickup error:', e);
            if (explorer.running) {
                explorer.addObservation('failure', `Item error: ${e.message}`);
            }
            // Item still collected, effects just don't work
        }
    }

    /**
     * Update world entities and callbacks
     */
    function updateWorld(dt) {
        // Run item update callbacks
        for (const callback of world.updateCallbacks) {
            try {
                callback(dt);
            } catch (e) {
                console.warn('Update callback error:', e);
            }
        }

        // Update entities
        for (let i = world.entities.length - 1; i >= 0; i--) {
            const entity = world.entities[i];
            entity.age += dt;

            // Apply velocity (entities can now move!)
            entity.x += entity.vx * dt;
            entity.y += entity.vy * dt;

            // Apply gravity to non-flying entities (if not explicitly marked as flying)
            if (!entity.flying && !entity.friendly) {
                entity.vy += GRAVITY * 0.5 * dt;  // Half gravity for floatier feel
            }

            // Keep entities on screen (simple bounds)
            if (entity.x < 0) entity.x = 0;
            if (entity.x > CANVAS_WIDTH - entity.width) entity.x = CANVAS_WIDTH - entity.width;
            if (entity.y > GROUND_Y - entity.height) {
                entity.y = GROUND_Y - entity.height;
                entity.vy = 0;  // Stop falling when hitting ground
            }

            // Remove expired entities
            if (entity.age >= entity.lifetime) {
                world.entities.splice(i, 1);
                continue;
            }

            // Remove dead entities (health <= 0)
            if (entity.health <= 0) {
                console.log('Entity died:', entity.type);
                world.entities.splice(i, 1);
                continue;
            }

            // Check collision with player (for damaging entities)
            if (entity.damage && !entity.friendly) {
                const touching =
                    player.x < entity.x + entity.width &&
                    player.x + player.width > entity.x &&
                    player.y < entity.y + entity.height &&
                    player.y + player.height > entity.y;

                if (touching && player.invincibleTimer <= 0) {
                    // Actually damage the player!
                    playerAPI.damage(entity.damage);

                    // Notify callbacks
                    for (const cb of world.playerHitCallbacks) {
                        try { cb(entity.damage, entity); } catch (e) {}
                    }
                }
            }
        }
    }

    /**
     * Render world entities
     */
    function renderEntities() {
        for (const entity of world.entities) {
            if (entity.sprite) {
                drawSprite(entity.sprite, entity.x, entity.y, PIXEL_SCALE);
            }
        }
    }

    // ============================================================
    // RENDERING
    // ============================================================

    function render() {
        // Clear with background color
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw platforms
        for (const platform of platforms) {
            drawPlatform(platform);
        }

        // Draw forge
        drawSprite(FORGE_SPRITE, forge.x, forge.y, PIXEL_SCALE);

        // Draw world entities (from item effects)
        renderEntities();

        // Draw player (flicker when invincible)
        const showPlayer = player.invincibleTimer <= 0 || Math.floor(player.invincibleTimer * 10) % 2 === 0;
        if (showPlayer) {
            drawSprite(
                PLAYER_SPRITE,
                player.x,
                player.y,
                PIXEL_SCALE,
                !player.facingRight  // Flip if facing left
            );
        }

        // Draw health bar (top-left corner)
        const healthBarWidth = 150;
        const healthBarHeight = 16;
        const healthBarX = 20;
        const healthBarY = 20;
        const healthPct = player.health / player.maxHealth;

        // Background (dark)
        ctx.fillStyle = '#2c1810';
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

        // Health fill (green → yellow → red based on health)
        let healthColor;
        if (healthPct > 0.6) healthColor = '#7daa73'; // green
        else if (healthPct > 0.3) healthColor = '#f4d03f'; // yellow
        else healthColor = '#cf6a4c'; // red

        ctx.fillStyle = healthColor;
        ctx.fillRect(healthBarX + 2, healthBarY + 2, (healthBarWidth - 4) * healthPct, healthBarHeight - 4);

        // Border
        ctx.strokeStyle = '#d9c4a5';
        ctx.lineWidth = 2;
        ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

        // Health text
        ctx.fillStyle = '#d9c4a5';
        ctx.font = '10px monospace';
        ctx.fillText(`HP: ${Math.ceil(player.health)}/${player.maxHealth}`, healthBarX + 4, healthBarY + 12);

        // Draw spawned item if exists
        if (spawnedItem) {
            // Floating animation
            const floatY = Math.sin(Date.now() / 300) * 4;
            drawSprite(spawnedItem.sprite, spawnedItem.x, spawnedItem.y + floatY, PIXEL_SCALE);

            // Glow effect
            const glow = Math.sin(Date.now() / 200) * 0.2 + 0.5;
            ctx.fillStyle = `rgba(244, 208, 63, ${glow * 0.3})`;
            ctx.beginPath();
            ctx.arc(
                spawnedItem.x + spawnedItem.width/2,
                spawnedItem.y + spawnedItem.height/2 + floatY,
                30,
                0, Math.PI * 2
            );
            ctx.fill();

            // Item name label
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            const nameWidth = ctx.measureText(spawnedItem.name).width + 16;
            ctx.fillRect(
                spawnedItem.x + spawnedItem.width/2 - nameWidth/2,
                spawnedItem.y - 25,
                nameWidth, 20
            );
            ctx.fillStyle = '#f4d03f';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(spawnedItem.name, spawnedItem.x + spawnedItem.width/2, spawnedItem.y - 10);
            ctx.textAlign = 'left';
        }

        // Draw forge state feedback
        const nearForge = isPlayerNearForge();

        if (forge.state === 'forging') {
            // Forging animation - pulsing glow
            const pulse = Math.sin(forge.forgeTimer * 8) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(244, 208, 63, ${pulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(
                forge.x + forge.width/2,
                forge.y + forge.height/2,
                60 + Math.sin(forge.forgeTimer * 6) * 10,
                0, Math.PI * 2
            );
            ctx.fill();

            // Progress indicator (pulsing since we don't know exact duration)
            const barWidth = 80;
            const barX = forge.x + forge.width/2 - barWidth/2;
            const barY = forge.y - 35;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(barX - 2, barY - 2, barWidth + 4, 14);
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(barX, barY, barWidth, 10);

            // Animated progress (bounces while waiting for inference)
            const progress = forge.pendingItem !== null ? 1.0 :
                (Math.sin(forge.forgeTimer * 3) * 0.3 + 0.5);
            ctx.fillStyle = '#f4d03f';
            ctx.fillRect(barX, barY, barWidth * progress, 10);

            ctx.fillStyle = '#fff8e7';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Forging...', forge.x + forge.width/2, barY - 6);
            ctx.textAlign = 'left';

        } else if (forge.state === 'ready') {
            // Item ready - gentle glow on forge
            const sparkle = Math.sin(Date.now() / 100) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(244, 208, 63, ${sparkle * 0.3})`;
            ctx.beginPath();
            ctx.arc(forge.x + forge.width/2, forge.y + forge.height/2, 40, 0, Math.PI * 2);
            ctx.fill();

        } else if (forge.state === 'failed') {
            // Failed - red fizzle effect
            const fade = 1 - (forge.forgeTimer / 1.5);
            ctx.fillStyle = `rgba(196, 92, 74, ${fade * 0.5})`;
            ctx.beginPath();
            ctx.arc(forge.x + forge.width/2, forge.y + forge.height/2, 50 * fade, 0, Math.PI * 2);
            ctx.fill();

            // Failure message
            ctx.fillStyle = `rgba(0, 0, 0, ${fade * 0.7})`;
            ctx.fillRect(forge.x - 30, forge.y - 35, 140, 24);
            ctx.fillStyle = `rgba(196, 92, 74, ${fade})`;
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Creation unstable...', forge.x + forge.width/2, forge.y - 18);
            ctx.textAlign = 'left';

        } else if (nearForge) {
            // Idle - show interact prompt
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(forge.x - 10, forge.y - 30, 100, 24);
            ctx.fillStyle = '#fff8e7';
            ctx.font = '14px monospace';
            ctx.fillText(controllerConnected ? '[X] Forge' : '[E] Forge', forge.x, forge.y - 12);
        }

        // Debug: show status
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(10, 10, 200, 80);
        ctx.fillStyle = '#fff8e7';
        ctx.font = '12px monospace';
        ctx.fillText(`Controller: ${controllerConnected ? 'Connected' : 'None'}`, 20, 28);
        ctx.fillText(`Player: (${Math.floor(player.x)}, ${Math.floor(player.y)})`, 20, 44);
        ctx.fillText(`Forge: ${forge.state}`, 20, 60);
        ctx.fillText(`Items: ${journal.length}`, 20, 76);
    }

    // ============================================================
    // GAME LOOP
    // ============================================================

    let lastTime = 0;

    function gameLoop(timestamp) {
        // Calculate delta time (capped at 100ms to prevent spiral of death)
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;

        // Get input
        const input = getInput();

        // Update
        updatePlayer(dt, input);
        updateForge(dt, input);
        updateWorld(dt);

        // Store previous input for edge detection
        prevInput = { ...input };

        // Render
        render();

        // Next frame
        requestAnimationFrame(gameLoop);
    }

    // ============================================================
    // EXPLORER CLAUDE - Autonomous playtesting agent
    // ============================================================

    const explorer = {
        running: false,
        targetForges: 10,
        completedForges: 0,
        observations: [],      // API observations
        apiMisses: {},         // Tracks undefined property access counts
        codePatterns: {},      // Tracks patterns found in generated code
        generatedItems: [],    // Stores raw code from each item for analysis
        lastAction: null,
        actionQueue: [],       // Commands to execute

        // UI elements (set in init)
        panel: null,
        toggle: null,
        status: null,
        log: null,

        // Initialize explorer
        init() {
            this.panel = document.getElementById('explorer-panel');
            this.toggle = document.getElementById('explorer-toggle');
            this.status = document.getElementById('explorer-status');
            this.log = document.getElementById('explorer-log');

            // Toggle panel
            this.toggle.addEventListener('click', () => {
                this.panel.classList.toggle('collapsed');
                this.toggle.textContent = this.panel.classList.contains('collapsed') ? '◀' : '▶';
            });

            // Run/Stop buttons
            document.getElementById('btn-run').addEventListener('click', () => this.start());
            document.getElementById('btn-stop').addEventListener('click', () => this.stop());

            // Start state update loop
            setInterval(() => this.updateStateDisplay(), 100);

            this.logMessage('Explorer initialized. Click Run to start autonomous exploration.');
        },

        // Update state display in panel
        updateStateDisplay() {
            document.getElementById('state-player').textContent =
                `(${Math.floor(player.x)}, ${Math.floor(player.y)})`;
            document.getElementById('state-forge').textContent = forge.state;
            document.getElementById('state-items').textContent = journal.length;
            document.getElementById('state-entities').textContent = world.entities.length;
            document.getElementById('state-forges').textContent = this.completedForges;
            document.getElementById('state-misses').textContent = Object.keys(this.apiMisses).length;
            document.getElementById('state-patterns').textContent = Object.keys(this.codePatterns).length;
        },

        // Log message to explorer console
        logMessage(msg) {
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            this.log.innerHTML += `<div>[${time}] ${msg}</div>`;
            this.log.scrollTop = this.log.scrollHeight;
            console.log('[Explorer]', msg);
        },

        // Add observation
        addObservation(type, message) {
            const obs = { type, message, time: Date.now() };
            this.observations.push(obs);

            const list = document.getElementById('observations-list');
            const div = document.createElement('div');
            div.className = `observation ${type}`;
            div.textContent = message;
            list.appendChild(div);
            list.scrollTop = list.scrollHeight;

            // Keep only last 50
            while (list.children.length > 50) {
                list.removeChild(list.firstChild);
            }
        },

        // Record API miss (undefined property access)
        recordApiMiss(property, context) {
            const key = `${context}.${property}`;
            this.apiMisses[key] = (this.apiMisses[key] || 0) + 1;
            if (this.apiMisses[key] === 1) {
                // First time seeing this miss
                this.addObservation('failure', `Missing: ${key}`);
            }
        },

        // Record API success
        recordApiSuccess(method, context) {
            this.addObservation('success', `Used: ${context}.${method}()`);
        },

        // Analyze item code and track patterns
        analyzeItemCode(item) {
            if (!item || !item.code) return;

            // Store the item for later inspection
            this.generatedItems.push({
                name: item.name,
                description: item.description,
                code: item.code
            });

            // Run pattern analysis
            const patterns = analyzeGeneratedCode(item.code);
            for (const [pattern, count] of Object.entries(patterns)) {
                this.codePatterns[pattern] = (this.codePatterns[pattern] || 0) + count;
                this.addObservation('pattern', `${pattern}: ${count}x`);
            }
        },

        // Start exploration
        async start() {
            if (this.running) return;

            this.running = true;
            this.completedForges = 0;
            this.observations = [];
            this.apiMisses = {};
            this.codePatterns = {};
            this.generatedItems = [];
            document.getElementById('observations-list').innerHTML = '';

            this.setStatus('running');
            document.getElementById('btn-run').disabled = true;
            document.getElementById('btn-stop').disabled = false;

            this.logMessage(`Starting exploration: ${this.targetForges} forge cycles`);
            this.addObservation('info', 'Exploration started');

            // Run the exploration loop
            await this.explorationLoop();
        },

        // Stop exploration
        stop() {
            this.running = false;
            this.setStatus('idle');
            document.getElementById('btn-run').disabled = false;
            document.getElementById('btn-stop').disabled = true;
            this.logMessage('Exploration stopped by user');
            this.generateReport();
        },

        setStatus(status) {
            this.status.textContent = status;
            this.status.className = status;
        },

        // Main exploration loop
        async explorationLoop() {
            while (this.running && this.completedForges < this.targetForges) {
                try {
                    // Get current state
                    const state = this.getGameState();

                    // Decide action via inference
                    const action = await this.decideAction(state);

                    if (!this.running) break;

                    // Execute action
                    await this.executeAction(action);

                    // Track forge completion via items collected
                    const currentItems = journal.length;
                    if (currentItems > this.completedForges) {
                        this.completedForges = currentItems;
                        this.logMessage(`Forge ${this.completedForges}/${this.targetForges} complete`);
                    }

                    // Small delay between actions
                    await this.sleep(100);

                } catch (e) {
                    this.logMessage(`Error: ${e.message}`);
                    this.setStatus('error');
                    await this.sleep(1000);
                    this.setStatus('running');
                }
            }

            if (this.completedForges >= this.targetForges) {
                this.logMessage('Exploration complete!');
                this.stop();
            }
        },

        // Get current game state for inference
        getGameState() {
            return {
                player: { x: player.x, y: player.y, onGround: player.onGround },
                forge: { x: forge.x, y: forge.y, state: forge.state },
                nearForge: isPlayerNearForge(),
                itemsCollected: journal.length,
                entities: world.entities.length,
                spawnedItem: spawnedItem ? { name: spawnedItem.name, x: spawnedItem.x, y: spawnedItem.y } : null,
                completedForges: this.completedForges,
                targetForges: this.targetForges
            };
        },

        // Decide next action - using simple heuristics first, can upgrade to inference later
        async decideAction(state) {
            // Simple state machine for now:
            // 1. If item spawned, go collect it (move + jump if needed)
            // 2. If forge idle and near it, activate
            // 3. If forge idle and not near, move toward it
            // 4. If forge forging/ready, wait

            if (state.spawnedItem) {
                // Move toward and collect item
                const dx = state.spawnedItem.x - state.player.x;
                const dy = state.spawnedItem.y - state.player.y;

                // If we're not horizontally aligned, move toward item
                if (Math.abs(dx) > 30) {
                    return { type: 'move', direction: dx > 0 ? 'right' : 'left', duration: 100 };
                }

                // If item is above us, jump to reach it
                if (dy < -20 && state.player.onGround) {
                    return { type: 'jump', duration: 400 };
                }

                // Otherwise keep trying to touch it
                if (Math.abs(dx) > 5) {
                    return { type: 'move', direction: dx > 0 ? 'right' : 'left', duration: 50 };
                }

                return { type: 'wait_for_item', duration: 100 };
            }

            if (state.forge.state === 'idle') {
                if (state.nearForge) {
                    return { type: 'interact' };
                } else {
                    // Move toward forge
                    const dx = state.forge.x - state.player.x;
                    return { type: 'move', direction: dx > 0 ? 'right' : 'left', duration: 150 };
                }
            }

            if (state.forge.state === 'forging') {
                return { type: 'wait', duration: 500 };
            }

            if (state.forge.state === 'ready') {
                return { type: 'wait_for_item', duration: 100 };
            }

            if (state.forge.state === 'failed') {
                return { type: 'wait', duration: 500 };
            }

            return { type: 'wait', duration: 100 };
        },

        // Execute an action
        async executeAction(action) {
            this.lastAction = action;

            switch (action.type) {
                case 'move':
                    // Inject movement input
                    explorerInput.moveX = action.direction === 'right' ? 1 : -1;
                    await this.sleep(action.duration || 100);
                    explorerInput.moveX = 0;
                    break;

                case 'jump':
                    explorerInput.jump = true;
                    await this.sleep(50);
                    explorerInput.jump = false;
                    await this.sleep(action.duration || 300);
                    break;

                case 'interact':
                    this.logMessage('Activating forge...');
                    explorerInput.interact = true;
                    await this.sleep(50);
                    explorerInput.interact = false;
                    await this.sleep(200);
                    break;

                case 'wait':
                case 'wait_for_item':
                    await this.sleep(action.duration || 100);
                    break;
            }
        },

        sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        },

        // Generate final report
        generateReport() {
            this.logMessage('');
            this.logMessage('========================================');
            this.logMessage('       EXPLORER REPORT');
            this.logMessage('========================================');
            this.logMessage(`Items generated: ${this.generatedItems.length}`);
            this.logMessage(`Items collected: ${journal.length}`);
            this.logMessage('');

            // Code patterns - sorted by frequency
            const sortedPatterns = Object.entries(this.codePatterns)
                .sort((a, b) => b[1] - a[1]);

            if (sortedPatterns.length > 0) {
                this.logMessage('CODE PATTERNS DETECTED:');
                this.logMessage('(patterns the item AI tried to use)');
                this.logMessage('----------------------------------------');
                for (const [pattern, count] of sortedPatterns) {
                    this.logMessage(`  ${pattern}: ${count}x`);
                }
                this.logMessage('');
            }

            // Runtime API misses
            if (Object.keys(this.apiMisses).length > 0) {
                this.logMessage('RUNTIME API MISSES:');
                this.logMessage('(undefined properties accessed at runtime)');
                this.logMessage('----------------------------------------');
                for (const [key, count] of Object.entries(this.apiMisses)) {
                    this.logMessage(`  ${key}: ${count}x`);
                }
                this.logMessage('');
            }

            this.logMessage('========================================');
            this.logMessage('Report saved to window.explorerReport');
            this.logMessage('Access generated code: window.explorerReport.generatedItems');

            // Store report in window for external access
            window.explorerReport = {
                completedForges: this.completedForges,
                itemsCollected: journal.length,
                codePatterns: { ...this.codePatterns },
                apiMisses: { ...this.apiMisses },
                generatedItems: [...this.generatedItems],
                observations: [...this.observations],
                journal: [...journal],
                // Helper to print report as text
                print() {
                    console.log('\n=== EXPLORER REPORT ===');
                    console.log(`Items: ${this.itemsCollected}`);
                    console.log('\nCode patterns (what AI tried to use):');
                    Object.entries(this.codePatterns)
                        .sort((a, b) => b[1] - a[1])
                        .forEach(([p, c]) => console.log(`  ${p}: ${c}x`));
                    if (Object.keys(this.apiMisses).length > 0) {
                        console.log('\nRuntime misses:');
                        Object.entries(this.apiMisses)
                            .forEach(([k, c]) => console.log(`  ${k}: ${c}x`));
                    }
                }
            };
        }
    };

    // Explorer input state (overrides normal input when explorer is running)
    const explorerInput = {
        moveX: 0,
        jump: false,
        interact: false
    };

    // Modify getInput to merge explorer input
    const originalGetInput = getInput;

    // ============================================================
    // INITIALIZATION
    // ============================================================

    function init() {
        console.log('Oneshot Climb - M1: Static Frame');
        console.log('Controls:');
        console.log('  Xbox Controller: Left stick move, A jump, X interact');
        console.log('  Keyboard: WASD/Arrows move, Space jump, E interact');

        // Check for existing gamepads (in case already connected)
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadIndex = i;
                controllerConnected = true;
                controllerPrompt.classList.add('hidden');
                console.log('Found existing gamepad:', gamepads[i].id);
                break;
            }
        }

        // Initialize Explorer Claude
        explorer.init();

        // Start game loop
        requestAnimationFrame(gameLoop);
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    </script>
</body>
</html>
