<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dark Rider</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';

// --- Config ---
const RENDER_W = 320;
const RENDER_H = 240;
const PIXEL_SCALE = 3;

// --- Renderer ---
const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(RENDER_W, RENDER_H);
renderer.domElement.style.width = `${RENDER_W * PIXEL_SCALE}px`;
renderer.domElement.style.height = `${RENDER_H * PIXEL_SCALE}px`;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.BasicShadowMap; // hard pixel shadows
renderer.setClearColor(0x87CEEB); // sky blue
document.body.appendChild(renderer.domElement);

// --- Scene ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x87CEEB, 0.025);

// --- Orthographic Camera (isometric) ---
const aspect = RENDER_W / RENDER_H;
const frustum = 12;
const camera = new THREE.OrthographicCamera(
    -frustum * aspect, frustum * aspect,
    frustum, -frustum,
    0.1, 100
);
// True isometric angle: rotate 45° on Y, ~35.264° on X
camera.position.set(20, 20, 20);
camera.lookAt(0, 0, 0);

// --- Toon gradient for cel-shading ---
const toonGradient = new THREE.DataTexture(
    new Uint8Array([80, 160, 255]),
    3, 1, THREE.RedFormat
);
toonGradient.minFilter = THREE.NearestFilter;
toonGradient.magFilter = THREE.NearestFilter;
toonGradient.needsUpdate = true;

function toonMat(color) {
    return new THREE.MeshToonMaterial({ color, gradientMap: toonGradient });
}

// --- Ground plane ---
const groundGeo = new THREE.PlaneGeometry(60, 60);
const groundMat = toonMat(0x4a7a3b);
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
ground.receiveShadow = true;
scene.add(ground);

// --- Path / road ---
const pathGeo = new THREE.PlaneGeometry(3, 60);
const pathMat = toonMat(0x8B7355);
const path = new THREE.Mesh(pathGeo, pathMat);
path.rotation.x = -Math.PI / 2;
path.position.y = 0.01;
path.receiveShadow = true;
scene.add(path);

// --- Collisions ---
// All collidable objects: { x, z, radius } in world space
const colliders = [];

// --- Trees ---
function createTree(x, z) {
    const group = new THREE.Group();

    // Trunk
    const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 6);
    const trunk = new THREE.Mesh(trunkGeo, toonMat(0x6B4226));
    trunk.position.y = 0.75;
    trunk.castShadow = true;
    group.add(trunk);

    // Foliage — stacked cones
    const colors = [0x2d6b1e, 0x358722, 0x3da328];
    for (let i = 0; i < 3; i++) {
        const coneGeo = new THREE.ConeGeometry(1.2 - i * 0.25, 1.2, 6);
        const cone = new THREE.Mesh(coneGeo, toonMat(colors[i]));
        cone.position.y = 1.8 + i * 0.7;
        cone.castShadow = true;
        group.add(cone);
    }

    group.position.set(x, 0, z);
    scene.add(group);
    colliders.push({ x, z, radius: 0.6 }); // trunk collision radius
    return group;
}

// Scatter trees along the sides of the path
const trees = [];
for (let i = 0; i < 20; i++) {
    const side = Math.random() > 0.5 ? 1 : -1;
    const x = side * (2.5 + Math.random() * 10);
    const z = (Math.random() - 0.5) * 40;
    trees.push(createTree(x, z));
}

// --- Rocks ---
function createRock(x, z, rockRadius) {
    const geo = new THREE.DodecahedronGeometry(rockRadius, 0);
    const rock = new THREE.Mesh(geo, toonMat(0x777777));
    rock.position.set(x, 0.2, z);
    rock.rotation.set(Math.random(), Math.random(), Math.random());
    rock.castShadow = true;
    rock.receiveShadow = true;
    scene.add(rock);
    colliders.push({ x, z, radius: rockRadius + 0.1 });
    return rock;
}

for (let i = 0; i < 12; i++) {
    const side = Math.random() > 0.5 ? 1 : -1;
    const rockRadius = 0.3 + Math.random() * 0.4;
    createRock(side * (1.8 + Math.random() * 8), (Math.random() - 0.5) * 30, rockRadius);
}

// --- Rider character ---
function createRider() {
    const group = new THREE.Group();

    // Horse body
    const bodyGeo = new THREE.BoxGeometry(0.8, 0.6, 1.4);
    const bodyMat = toonMat(0x1a1a1a);
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.9;
    body.castShadow = true;
    group.add(body);

    // Horse head
    const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.6);
    const head = new THREE.Mesh(headGeo, bodyMat);
    head.position.set(0, 1.2, -0.8);
    head.rotation.x = -0.3;
    head.castShadow = true;
    group.add(head);

    // Legs (4)
    const legGeo = new THREE.BoxGeometry(0.15, 0.6, 0.15);
    const legMat = toonMat(0x111111);
    const legPositions = [
        [-0.25, 0.3, -0.5],
        [0.25, 0.3, -0.5],
        [-0.25, 0.3, 0.5],
        [0.25, 0.3, 0.5],
    ];
    const legs = [];
    for (const [lx, ly, lz] of legPositions) {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(lx, ly, lz);
        leg.castShadow = true;
        group.add(leg);
        legs.push(leg);
    }
    group.userData.legs = legs;

    // Rider torso
    const torsoGeo = new THREE.BoxGeometry(0.5, 0.7, 0.4);
    const torso = new THREE.Mesh(torsoGeo, toonMat(0x2a1a3a));
    torso.position.y = 1.55;
    torso.castShadow = true;
    group.add(torso);

    // Rider head
    const rHeadGeo = new THREE.BoxGeometry(0.35, 0.35, 0.35);
    const rHead = new THREE.Mesh(rHeadGeo, toonMat(0xd4a574));
    rHead.position.y = 2.1;
    rHead.castShadow = true;
    group.add(rHead);

    // Hood/cloak
    const hoodGeo = new THREE.ConeGeometry(0.28, 0.4, 4);
    const hood = new THREE.Mesh(hoodGeo, toonMat(0x1a0a2a));
    hood.position.y = 2.4;
    hood.castShadow = true;
    group.add(hood);

    // Eyes — tiny red dots
    const eyeGeo = new THREE.BoxGeometry(0.06, 0.06, 0.06);
    const eyeMat = toonMat(0xff2222);
    const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
    eyeL.position.set(-0.1, 2.12, -0.18);
    group.add(eyeL);
    const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
    eyeR.position.set(0.1, 2.12, -0.18);
    group.add(eyeR);

    scene.add(group);
    return group;
}

const rider = createRider();

// --- Lighting ---
// Directional light (sun/moon)
const sun = new THREE.DirectionalLight(0xffe4b5, 1.8);
sun.position.set(10, 15, 10);
sun.castShadow = true;
sun.shadow.mapSize.set(512, 512);
sun.shadow.camera.left = -20;
sun.shadow.camera.right = 20;
sun.shadow.camera.top = 20;
sun.shadow.camera.bottom = -20;
scene.add(sun);

const ambient = new THREE.AmbientLight(0x6688aa, 0.6);
scene.add(ambient);

const hemi = new THREE.HemisphereLight(0x87CEEB, 0x4a7a3b, 0.3);
scene.add(hemi);

// --- Day/Night cycle ---
const DAY_CYCLE = 60; // seconds for a full cycle
const skyColors = {
    day:     new THREE.Color(0x87CEEB),
    sunset:  new THREE.Color(0xB8735A),
    night:   new THREE.Color(0x0f1535),
    dawn:    new THREE.Color(0xD4886B),
};
const fogDensity = { day: 0.025, night: 0.018 };
const tmpColor = new THREE.Color();

function lerpColor(a, b, t) {
    tmpColor.copy(a).lerp(b, t);
    return tmpColor;
}

function updateDayNight(time) {
    // t goes 0..1 over a full cycle. 0=noon, 0.25=sunset, 0.5=midnight, 0.75=dawn
    const t = (time % DAY_CYCLE) / DAY_CYCLE;

    // Sun angle — orbits overhead
    const sunAngle = t * Math.PI * 2 - Math.PI / 2; // starts at top
    const sunY = Math.sin(sunAngle);
    const sunXZ = Math.cos(sunAngle);
    sun.position.set(sunXZ * 15, sunY * 15 + 5, sunXZ * 10);

    // Sky color blend
    let skyColor;
    if (sunY > 0.3) {
        // Full day
        skyColor = skyColors.day;
    } else if (sunY > 0) {
        // Sunset/dawn transition
        const blend = sunY / 0.3;
        const edgeColor = t < 0.5 ? skyColors.sunset : skyColors.dawn;
        skyColor = lerpColor(edgeColor, skyColors.day, blend);
    } else {
        // Night — blend toward deep dark
        const blend = Math.min(1, -sunY / 0.5);
        const edgeColor = t < 0.5 ? skyColors.sunset : skyColors.dawn;
        skyColor = lerpColor(edgeColor, skyColors.night, blend);
    }

    renderer.setClearColor(skyColor);
    scene.fog.color.copy(skyColor);

    // Fog denser at night
    scene.fog.density = THREE.MathUtils.lerp(
        fogDensity.day, fogDensity.night,
        Math.max(0, -sunY / 0.5)
    );

    // Sun light intensity and color
    const dayIntensity = Math.max(0, sunY) * 1.8;
    sun.intensity = dayIntensity;
    if (sunY > 0) {
        // Warm at low angles, white at high
        const warmth = 1 - Math.min(1, sunY / 0.5);
        sun.color.setRGB(1, 0.9 - warmth * 0.1, 0.7 - warmth * 0.2);
    }

    // Ambient — cool blue at night, warm during day
    const nightAmbient = Math.max(0.5, sunY * 0.4 + 0.5);
    ambient.intensity = nightAmbient;
    if (sunY < 0) {
        ambient.color.setHex(0x4466aa);
    } else {
        ambient.color.setHex(0x6688aa);
    }

    // Hemisphere
    hemi.intensity = Math.max(0.15, sunY * 0.3 + 0.2);
    hemi.color.copy(skyColor);
}

// --- Input ---
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// --- Game loop ---
let time = DAY_CYCLE * 0.5; // start at noon
const worldOffset = { x: 0, z: 0 };

function animate() {
    requestAnimationFrame(animate);
    time += 0.016;

    // Movement
    let dx = 0, dz = 0;
    const speed = 0.08;
    if (keys['w'] || keys['arrowup']) dz -= speed;
    if (keys['s'] || keys['arrowdown']) dz += speed;
    if (keys['a'] || keys['arrowleft']) dx -= speed;
    if (keys['d'] || keys['arrowright']) dx += speed;

    // Collision — resolve proposed position so it never overlaps
    const riderRadius = 0.5;
    let px = worldOffset.x + dx;
    let pz = worldOffset.z + dz;
    for (const c of colliders) {
        const ex = px - c.x;
        const ez = pz - c.z;
        const dist = Math.sqrt(ex * ex + ez * ez);
        const minDist = c.radius + riderRadius;
        if (dist < minDist && dist > 0.001) {
            // Push position out to exactly the boundary
            px = c.x + (ex / dist) * minDist;
            pz = c.z + (ez / dist) * minDist;
        }
    }
    dx = px - worldOffset.x;
    dz = pz - worldOffset.z;

    // Move world instead of player (infinite scroll illusion)
    worldOffset.x += dx;
    worldOffset.z += dz;

    // Rider stays centered, animate bob
    rider.position.y = Math.sin(time * 6) * 0.05;

    // Leg animation
    const legs = rider.userData.legs;
    const isMoving = dx !== 0 || dz !== 0;
    const legSwing = isMoving ? Math.sin(time * 12) * 0.3 : 0;
    legs[0].rotation.x = legSwing;
    legs[1].rotation.x = -legSwing;
    legs[2].rotation.x = -legSwing;
    legs[3].rotation.x = legSwing;

    // Face direction of movement (+ PI because horse model faces -Z)
    if (isMoving) {
        rider.rotation.y = Math.atan2(dx, dz) + Math.PI;
    }

    // Move ground and path to follow camera
    ground.position.x = -worldOffset.x;
    ground.position.z = -worldOffset.z;
    path.position.x = -worldOffset.x;
    path.position.z = -worldOffset.z;

    // Move trees/rocks relative to world scroll
    scene.traverse(obj => {
        if (obj.userData.worldAnchor) {
            obj.position.x = obj.userData.worldAnchor.x - worldOffset.x;
            obj.position.z = obj.userData.worldAnchor.z - worldOffset.z;
        }
    });

    // Day/night cycle
    updateDayNight(time);

    // Camera follows rider
    camera.position.set(
        rider.position.x + 20,
        20,
        rider.position.z + 20
    );
    camera.lookAt(rider.position.x, 0, rider.position.z);

    renderer.render(scene, camera);
}

// Tag world objects with anchor positions so scrolling works
scene.traverse(obj => {
    if (obj.parent === scene && obj !== rider && obj !== ground &&
        obj !== path && obj !== sun && obj !== ambient && obj !== hemi) {
        obj.userData.worldAnchor = { x: obj.position.x, z: obj.position.z };
    }
});

animate();
</script>
</body>
</html>
