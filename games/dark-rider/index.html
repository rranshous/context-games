<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dark Rider</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';

// --- Config ---
const RENDER_W = 320;
const RENDER_H = 240;
const PIXEL_SCALE = 3;

// --- Renderer ---
const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(RENDER_W, RENDER_H);
renderer.domElement.style.width = `${RENDER_W * PIXEL_SCALE}px`;
renderer.domElement.style.height = `${RENDER_H * PIXEL_SCALE}px`;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.BasicShadowMap; // hard pixel shadows
renderer.setClearColor(0x87CEEB); // sky blue
document.body.appendChild(renderer.domElement);

// --- Scene ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x87CEEB, 0.015);

// --- Orthographic Camera (isometric) ---
const aspect = RENDER_W / RENDER_H;
const frustum = 12;
const camera = new THREE.OrthographicCamera(
    -frustum * aspect, frustum * aspect,
    frustum, -frustum,
    0.1, 100
);
// True isometric angle: rotate 45° on Y, ~35.264° on X
camera.position.set(20, 20, 20);
camera.lookAt(0, 0, 0);

// --- Toon gradient for cel-shading ---
const toonGradient = new THREE.DataTexture(
    new Uint8Array([80, 160, 255]),
    3, 1, THREE.RedFormat
);
toonGradient.minFilter = THREE.NearestFilter;
toonGradient.magFilter = THREE.NearestFilter;
toonGradient.needsUpdate = true;

function toonMat(color) {
    return new THREE.MeshToonMaterial({ color, gradientMap: toonGradient });
}

// --- Ground plane ---
const groundGeo = new THREE.PlaneGeometry(60, 60);
const groundMat = toonMat(0x4a7a3b);
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
ground.receiveShadow = true;
scene.add(ground);

// --- Grass detail ---
// Dark patches for ground variation
const patchGreens = [0x3d6b30, 0x567d3a, 0x426832, 0x4e8a3e];
for (let i = 0; i < 60; i++) {
    const size = 0.5 + Math.random() * 1.5;
    const geo = new THREE.CircleGeometry(size, 5 + Math.floor(Math.random() * 3));
    const mat = toonMat(patchGreens[Math.floor(Math.random() * patchGreens.length)]);
    mat.polygonOffset = true;
    mat.polygonOffsetFactor = -1 - i * 0.01; // unique offset prevents z-fighting
    mat.polygonOffsetUnits = -1;
    const patch = new THREE.Mesh(geo, mat);
    patch.rotation.x = -Math.PI / 2;
    patch.position.set(
        (Math.random() - 0.5) * 50,
        0.005 + i * 0.0001,
        (Math.random() - 0.5) * 50
    );
    patch.receiveShadow = true;
    scene.add(patch);
}

// Grass tufts — small thin cones
const tuftColors = [0x3a8a2e, 0x4a9a38, 0x2d7a22];
for (let i = 0; i < 100; i++) {
    const x = (Math.random() - 0.5) * 50;
    const z = (Math.random() - 0.5) * 50;
    // Skip tufts on the path
    if (Math.abs(x) < 2) continue;
    const cluster = new THREE.Group();
    const blades = 2 + Math.floor(Math.random() * 3);
    for (let b = 0; b < blades; b++) {
        const h = 0.15 + Math.random() * 0.25;
        const geo = new THREE.ConeGeometry(0.04, h, 3);
        const mat = toonMat(tuftColors[Math.floor(Math.random() * tuftColors.length)]);
        const blade = new THREE.Mesh(geo, mat);
        blade.position.set(
            (Math.random() - 0.5) * 0.15,
            h / 2,
            (Math.random() - 0.5) * 0.15
        );
        blade.rotation.x = (Math.random() - 0.5) * 0.3;
        blade.rotation.z = (Math.random() - 0.5) * 0.3;
        cluster.add(blade);
    }
    cluster.position.set(x, 0, z);
    scene.add(cluster);
}

// --- Path / road ---
const pathGeo = new THREE.PlaneGeometry(3, 60);
const pathMat = toonMat(0x8B7355);
const path = new THREE.Mesh(pathGeo, pathMat);
path.rotation.x = -Math.PI / 2;
path.position.y = 0.01;
path.receiveShadow = true;
scene.add(path);

// --- Collisions ---
// All collidable objects: { x, z, radius } in world space
const colliders = [];

// --- Trees ---
function createTree(x, z) {
    const group = new THREE.Group();

    // Trunk
    const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 6);
    const trunk = new THREE.Mesh(trunkGeo, toonMat(0x6B4226));
    trunk.position.y = 0.75;
    trunk.castShadow = true;
    group.add(trunk);

    // Foliage — stacked cones
    const colors = [0x2d6b1e, 0x358722, 0x3da328];
    for (let i = 0; i < 3; i++) {
        const coneGeo = new THREE.ConeGeometry(1.2 - i * 0.25, 1.2, 6);
        const cone = new THREE.Mesh(coneGeo, toonMat(colors[i]));
        cone.position.y = 1.8 + i * 0.7;
        cone.castShadow = true;
        group.add(cone);
    }

    group.position.set(x, 0, z);
    scene.add(group);
    colliders.push({ x, z, radius: 0.6 }); // trunk collision radius
    return group;
}

// Scatter trees along the sides of the path
const trees = [];
for (let i = 0; i < 20; i++) {
    const side = Math.random() > 0.5 ? 1 : -1;
    const x = side * (2.5 + Math.random() * 10);
    const z = (Math.random() - 0.5) * 40;
    trees.push(createTree(x, z));
}

// --- Rocks ---
function createRock(x, z, rockRadius) {
    const geo = new THREE.DodecahedronGeometry(rockRadius, 0);
    const rock = new THREE.Mesh(geo, toonMat(0x777777));
    rock.position.set(x, 0.2, z);
    rock.rotation.set(Math.random(), Math.random(), Math.random());
    rock.castShadow = true;
    rock.receiveShadow = true;
    scene.add(rock);
    colliders.push({ x, z, radius: rockRadius + 0.1 });
    return rock;
}

for (let i = 0; i < 12; i++) {
    const side = Math.random() > 0.5 ? 1 : -1;
    const rockRadius = 0.3 + Math.random() * 0.4;
    createRock(side * (1.8 + Math.random() * 8), (Math.random() - 0.5) * 30, rockRadius);
}

// --- Town Edge ---
function createBuilding(x, z, w, d, h, roofColor) {
    const group = new THREE.Group();

    // Walls
    const wallGeo = new THREE.BoxGeometry(w, h, d);
    const wall = new THREE.Mesh(wallGeo, toonMat(0x8B7B6B));
    wall.position.y = h / 2;
    wall.castShadow = true;
    group.add(wall);

    // Roof — pyramid via 4-sided cone
    const roofOverhang = 0.3;
    const roofH = Math.max(w, d) * 0.8;
    const roofGeo = new THREE.ConeGeometry(
        Math.max(w, d) / 2 + roofOverhang, roofH, 4
    );
    const roof = new THREE.Mesh(roofGeo, toonMat(roofColor));
    roof.position.y = h + roofH / 2;
    roof.rotation.y = Math.PI / 4;
    roof.castShadow = true;
    group.add(roof);

    // Windows — emissive planes on all four faces
    const windowMat = new THREE.MeshStandardMaterial({
        color: 0xffcc66,
        emissive: 0xffaa33,
        emissiveIntensity: 0,
    });
    const winW = new THREE.PlaneGeometry(w * 0.3, h * 0.3);
    const winD = new THREE.PlaneGeometry(d * 0.3, h * 0.3);
    const windowPositions = [
        { geo: winW, pos: [0, h * 0.5, -d / 2 - 0.01], rot: [0, Math.PI, 0] },
        { geo: winW, pos: [0, h * 0.5, d / 2 + 0.01], rot: [0, 0, 0] },
        { geo: winD, pos: [-w / 2 - 0.01, h * 0.5, 0], rot: [0, -Math.PI / 2, 0] },
        { geo: winD, pos: [w / 2 + 0.01, h * 0.5, 0], rot: [0, Math.PI / 2, 0] },
    ];
    for (const wp of windowPositions) {
        const win = new THREE.Mesh(wp.geo, windowMat);
        win.position.set(...wp.pos);
        win.rotation.set(...wp.rot);
        group.add(win);
    }
    group.userData.windowMat = windowMat;

    // Warm interior glow — small point light inside
    const glow = new THREE.PointLight(0xffaa33, 0, 8, 2);
    glow.position.set(0, h * 0.5, 0);
    group.add(glow);
    group.userData.glowLight = glow;

    group.position.set(x, 0, z);
    scene.add(group);
    colliders.push({ x, z, radius: Math.sqrt(w * w + d * d) / 2 });
    return group;
}

const buildings = [];
const townLayout = [
    { x: 19, z: -6, w: 2.5, d: 2.0, h: 2.5, roof: 0x6B3A2A },
    { x: 22, z: -3, w: 3.0, d: 2.5, h: 3.5, roof: 0x5A2E1A },
    { x: 20, z:  1, w: 2.0, d: 2.0, h: 2.0, roof: 0x7B4A3A },
    { x: 24, z:  3, w: 2.8, d: 2.2, h: 3.0, roof: 0x6B3A2A },
    { x: 21, z:  7, w: 2.2, d: 2.0, h: 2.8, roof: 0x5A2E1A },
    { x: 26, z:  0, w: 3.2, d: 2.5, h: 3.8, roof: 0x6B3A2A },
    { x: 25, z: -5, w: 2.0, d: 1.8, h: 2.2, roof: 0x7B4A3A },
    { x: 27, z:  5, w: 2.5, d: 2.0, h: 2.5, roof: 0x5A2E1A },
];
for (const b of townLayout) {
    buildings.push(createBuilding(b.x, b.z, b.w, b.d, b.h, b.roof));
}

// --- Rider character ---
function createRider() {
    const group = new THREE.Group();

    // Horse body
    const bodyGeo = new THREE.BoxGeometry(0.8, 0.6, 1.4);
    const bodyMat = toonMat(0x1a1a1a);
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.9;
    body.castShadow = true;
    group.add(body);

    // Horse head
    const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.6);
    const head = new THREE.Mesh(headGeo, bodyMat);
    head.position.set(0, 1.2, -0.8);
    head.rotation.x = -0.3;
    head.castShadow = true;
    group.add(head);

    // Legs (4)
    const legGeo = new THREE.BoxGeometry(0.15, 0.6, 0.15);
    const legMat = toonMat(0x111111);
    const legPositions = [
        [-0.25, 0.3, -0.5],
        [0.25, 0.3, -0.5],
        [-0.25, 0.3, 0.5],
        [0.25, 0.3, 0.5],
    ];
    const legs = [];
    for (const [lx, ly, lz] of legPositions) {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(lx, ly, lz);
        leg.castShadow = true;
        group.add(leg);
        legs.push(leg);
    }
    group.userData.legs = legs;

    // Rider torso
    const torsoGeo = new THREE.BoxGeometry(0.5, 0.7, 0.4);
    const torso = new THREE.Mesh(torsoGeo, toonMat(0x2a1a3a));
    torso.position.y = 1.55;
    torso.castShadow = true;
    group.add(torso);

    // Rider head
    const rHeadGeo = new THREE.BoxGeometry(0.35, 0.35, 0.35);
    const rHead = new THREE.Mesh(rHeadGeo, toonMat(0xd4a574));
    rHead.position.y = 2.1;
    rHead.castShadow = true;
    group.add(rHead);

    // Hood/cloak
    const hoodGeo = new THREE.ConeGeometry(0.28, 0.4, 4);
    const hood = new THREE.Mesh(hoodGeo, toonMat(0x1a0a2a));
    hood.position.y = 2.4;
    hood.castShadow = true;
    group.add(hood);

    // Eyes — subtle dark red, nearly flush with face
    const eyeGeo = new THREE.BoxGeometry(0.05, 0.05, 0.02);
    const eyeMat = toonMat(0x661111);
    const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
    eyeL.position.set(-0.09, 2.12, -0.175);
    group.add(eyeL);
    const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
    eyeR.position.set(0.09, 2.12, -0.175);
    group.add(eyeR);

    // Lantern mesh — small glowing box at hand height
    const lanternGeo = new THREE.BoxGeometry(0.12, 0.18, 0.12);
    const lanternMat = new THREE.MeshStandardMaterial({
        color: 0xffb347,
        emissive: 0xffb347,
        emissiveIntensity: 0.8,
    });
    const lanternMesh = new THREE.Mesh(lanternGeo, lanternMat);
    lanternMesh.position.set(0.35, 1.5, -0.3);
    group.add(lanternMesh);
    group.userData.lanternMesh = lanternMesh;

    // Lantern point light
    const lanternLight = new THREE.PointLight(0xffb347, 0, 12, 2);
    lanternLight.position.set(0.35, 1.5, -0.3);
    lanternLight.castShadow = true;
    lanternLight.shadow.mapSize.set(256, 256);
    lanternLight.shadow.camera.near = 0.1;
    lanternLight.shadow.camera.far = 12;
    group.add(lanternLight);
    group.userData.lanternLight = lanternLight;

    scene.add(group);
    return group;
}

const rider = createRider();

// --- Lighting ---
// Directional light (sun/moon)
const sun = new THREE.DirectionalLight(0xffe4b5, 1.8);
sun.position.set(10, 15, 10);
sun.castShadow = true;
sun.shadow.mapSize.set(512, 512);
sun.shadow.camera.left = -20;
sun.shadow.camera.right = 20;
sun.shadow.camera.top = 20;
sun.shadow.camera.bottom = -20;
scene.add(sun);

const ambient = new THREE.AmbientLight(0x6688aa, 0.6);
scene.add(ambient);

const hemi = new THREE.HemisphereLight(0x87CEEB, 0x4a7a3b, 0.3);
scene.add(hemi);

// --- Day/Night cycle ---
const DAY_CYCLE = 300; // seconds for a full cycle (5 minutes)
const skyColors = {
    day:     new THREE.Color(0x87CEEB),
    sunset:  new THREE.Color(0xB8735A),
    night:   new THREE.Color(0x0f1535),
    dawn:    new THREE.Color(0xD4886B),
};
const fogDensity = { day: 0.015, night: 0.012 };
let sunY = 1;
const tmpColor = new THREE.Color();

function lerpColor(a, b, t) {
    tmpColor.copy(a).lerp(b, t);
    return tmpColor;
}

function updateDayNight(time) {
    // t goes 0..1 over a full cycle. 0=noon, 0.25=sunset, 0.5=midnight, 0.75=dawn
    const t = (time % DAY_CYCLE) / DAY_CYCLE;

    // Sun angle — orbits overhead
    const sunAngle = t * Math.PI * 2 - Math.PI / 2; // starts at top
    sunY = Math.sin(sunAngle);
    const sunXZ = Math.cos(sunAngle);
    sun.position.set(sunXZ * 15, sunY * 15 + 5, sunXZ * 10);

    // Sky color blend
    let skyColor;
    if (sunY > 0.3) {
        // Full day
        skyColor = skyColors.day;
    } else if (sunY > 0) {
        // Sunset/dawn transition
        const blend = sunY / 0.3;
        const edgeColor = t < 0.5 ? skyColors.sunset : skyColors.dawn;
        skyColor = lerpColor(edgeColor, skyColors.day, blend);
    } else {
        // Night — blend toward deep dark
        const blend = Math.min(1, -sunY / 0.5);
        const edgeColor = t < 0.5 ? skyColors.sunset : skyColors.dawn;
        skyColor = lerpColor(edgeColor, skyColors.night, blend);
    }

    renderer.setClearColor(skyColor);
    scene.fog.color.copy(skyColor);

    // Fog denser at night
    scene.fog.density = THREE.MathUtils.lerp(
        fogDensity.day, fogDensity.night,
        Math.max(0, -sunY / 0.5)
    );

    // Sun light intensity and color
    const dayIntensity = Math.max(0, sunY) * 1.8;
    sun.intensity = dayIntensity;
    if (sunY > 0) {
        // Warm at low angles, white at high
        const warmth = 1 - Math.min(1, sunY / 0.5);
        sun.color.setRGB(1, 0.9 - warmth * 0.1, 0.7 - warmth * 0.2);
    }

    // Ambient — cool blue at night, warm during day
    const nightAmbient = Math.max(0.5, sunY * 0.4 + 0.5);
    ambient.intensity = nightAmbient;
    if (sunY < 0) {
        ambient.color.setHex(0x4466aa);
    } else {
        ambient.color.setHex(0x6688aa);
    }

    // Hemisphere
    hemi.intensity = Math.max(0.15, sunY * 0.3 + 0.2);
    hemi.color.copy(skyColor);
}

// --- Input ---
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// --- Game loop ---
let time = DAY_CYCLE * 0.5; // start at noon (2.5 min in)
const worldOffset = { x: 0, z: 0 };

function animate() {
    requestAnimationFrame(animate);
    time += 0.016;

    // Movement
    let dx = 0, dz = 0;
    const speed = 0.08;
    if (keys['w'] || keys['arrowup']) dz -= speed;
    if (keys['s'] || keys['arrowdown']) dz += speed;
    if (keys['a'] || keys['arrowleft']) dx -= speed;
    if (keys['d'] || keys['arrowright']) dx += speed;

    // Collision — resolve proposed position so it never overlaps
    const riderRadius = 0.5;
    let px = worldOffset.x + dx;
    let pz = worldOffset.z + dz;
    for (const c of colliders) {
        const ex = px - c.x;
        const ez = pz - c.z;
        const dist = Math.sqrt(ex * ex + ez * ez);
        const minDist = c.radius + riderRadius;
        if (dist < minDist && dist > 0.001) {
            // Push position out to exactly the boundary
            px = c.x + (ex / dist) * minDist;
            pz = c.z + (ez / dist) * minDist;
        }
    }
    dx = px - worldOffset.x;
    dz = pz - worldOffset.z;

    // Move world instead of player (infinite scroll illusion)
    worldOffset.x += dx;
    worldOffset.z += dz;

    // Rider stays centered, animate bob
    rider.position.y = Math.sin(time * 6) * 0.05;

    // Leg animation
    const legs = rider.userData.legs;
    const isMoving = dx !== 0 || dz !== 0;
    const legSwing = isMoving ? Math.sin(time * 12) * 0.3 : 0;
    legs[0].rotation.x = legSwing;
    legs[1].rotation.x = -legSwing;
    legs[2].rotation.x = -legSwing;
    legs[3].rotation.x = legSwing;

    // Face direction of movement (+ PI because horse model faces -Z)
    if (isMoving) {
        rider.rotation.y = Math.atan2(dx, dz) + Math.PI;
    }

    // Move ground and path to follow camera
    ground.position.x = -worldOffset.x;
    ground.position.z = -worldOffset.z;
    path.position.x = -worldOffset.x;
    path.position.z = -worldOffset.z;

    // Move trees/rocks relative to world scroll
    scene.traverse(obj => {
        if (obj.userData.worldAnchor) {
            obj.position.x = obj.userData.worldAnchor.x - worldOffset.x;
            obj.position.z = obj.userData.worldAnchor.z - worldOffset.z;
        }
    });

    // Day/night cycle
    updateDayNight(time);

    // Lantern intensity — ramps up at night, off during day
    const lanternT = THREE.MathUtils.smoothstep(-sunY, -0.3, 0.2);
    rider.userData.lanternLight.intensity = lanternT * 3.0;
    rider.userData.lanternMesh.material.emissiveIntensity = lanternT * 1.2;

    // Town window glow — warm at night, off during day
    const windowT = THREE.MathUtils.smoothstep(-sunY, -0.1, 0.3);
    for (const bldg of buildings) {
        bldg.userData.windowMat.emissiveIntensity = windowT * 1.5;
        bldg.userData.glowLight.intensity = windowT * 2.0;
    }

    // Camera follows rider
    camera.position.set(
        rider.position.x + 20,
        20,
        rider.position.z + 20
    );
    camera.lookAt(rider.position.x, rider.position.y * 0.5, rider.position.z);

    renderer.render(scene, camera);
}

// Tag world objects with anchor positions so scrolling works
scene.traverse(obj => {
    if (obj.parent === scene && obj !== rider && obj !== ground &&
        obj !== path && obj !== sun && obj !== ambient && obj !== hemi) {
        obj.userData.worldAnchor = { x: obj.position.x, z: obj.position.z };
    }
});

animate();
</script>
</body>
</html>
