<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rampart Ridge</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a12;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #hud {
            position: fixed;
            top: 0; left: 0; right: 0;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            color: #00ffcc;
            text-shadow: 0 0 4px #00ffcc88;
            padding: 12px 16px;
            font-size: 14px;
            z-index: 10;
        }
        #hud-bottom {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            color: #00ffcc88;
            text-shadow: 0 0 4px #00ffcc44;
            padding: 8px 16px;
            font-size: 11px;
            text-align: center;
            z-index: 10;
        }
        .hud-row { display: flex; justify-content: space-between; }
    </style>
</head>
<body>
<div id="hud">
    <div class="hud-row">
        <span id="hud-tower">No Tower</span>
        <span id="hud-gate">GATE: 100%</span>
    </div>
</div>
<div id="hud-bottom">
    <span id="hud-controls">[D-PAD] Navigate &bull; [A] Hop In/Out &bull; [WASD/SPACE on keyboard]</span>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';

// ============================================================
// CONFIG
// ============================================================
const RENDER_W = 320;
const RENDER_H = 240;
const PIXEL_SCALE = 3;

// ============================================================
// RENDERER
// ============================================================
const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(RENDER_W, RENDER_H);
renderer.domElement.style.width = `${RENDER_W * PIXEL_SCALE}px`;
renderer.domElement.style.height = `${RENDER_H * PIXEL_SCALE}px`;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.BasicShadowMap;
renderer.setClearColor(0x121225);
document.body.appendChild(renderer.domElement);

// ============================================================
// SCENE
// ============================================================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x121225, 0.012);

// ============================================================
// CAMERA — orthographic isometric
// ============================================================
const aspect = RENDER_W / RENDER_H;
const frustum = 14;
const camera = new THREE.OrthographicCamera(
    -frustum * aspect, frustum * aspect,
    frustum, -frustum,
    0.1, 120
);
// Isometric angle looking down the valley
camera.position.set(18, 22, 18);
camera.lookAt(0, 0, 0);

// ============================================================
// TOON SHADING
// ============================================================
const toonGradient = new THREE.DataTexture(
    new Uint8Array([60, 140, 240]),
    3, 1, THREE.RedFormat
);
toonGradient.minFilter = THREE.NearestFilter;
toonGradient.magFilter = THREE.NearestFilter;
toonGradient.needsUpdate = true;

function toonMat(color) {
    return new THREE.MeshToonMaterial({ color, gradientMap: toonGradient });
}

// ============================================================
// VALLEY TERRAIN
// ============================================================

// Ground — dusty sci-fi terrain
const groundGeo = new THREE.PlaneGeometry(40, 40);
const groundMat = toonMat(0x3a3530);
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
ground.receiveShadow = true;
scene.add(ground);

// Ground detail patches — darker/lighter dust
const dustColors = [0x221e1a, 0x33302a, 0x1e1b17, 0x3a3530];
for (let i = 0; i < 40; i++) {
    const size = 0.5 + Math.random() * 2;
    const geo = new THREE.CircleGeometry(size, 5 + Math.floor(Math.random() * 3));
    const mat = toonMat(dustColors[Math.floor(Math.random() * dustColors.length)]);
    mat.polygonOffset = true;
    mat.polygonOffsetFactor = -1 - i * 0.01;
    mat.polygonOffsetUnits = -1;
    const patch = new THREE.Mesh(geo, mat);
    patch.rotation.x = -Math.PI / 2;
    patch.position.set(
        (Math.random() - 0.5) * 30,
        0.005 + i * 0.0001,
        (Math.random() - 0.5) * 30
    );
    patch.receiveShadow = true;
    scene.add(patch);
}

// Metal path down the center — enemy route
const pathGeo = new THREE.PlaneGeometry(2.5, 22);
const pathMat = toonMat(0x3a3a44);
const pathMesh = new THREE.Mesh(pathGeo, pathMat);
pathMesh.rotation.x = -Math.PI / 2;
pathMesh.position.set(0, 0.01, -1);
pathMesh.receiveShadow = true;
scene.add(pathMesh);

// Path edge strips — metallic trim
for (const side of [-1, 1]) {
    const stripGeo = new THREE.PlaneGeometry(0.15, 22);
    const stripMat = toonMat(0x5a5a6a);
    const strip = new THREE.Mesh(stripGeo, stripMat);
    strip.rotation.x = -Math.PI / 2;
    strip.position.set(side * 1.35, 0.015, -1);
    strip.receiveShadow = true;
    scene.add(strip);
}

// ============================================================
// CANYON WALLS
// ============================================================
function createWallSection(x, z, width, height, depth) {
    const geo = new THREE.BoxGeometry(width, height, depth);
    const rock = new THREE.Mesh(geo, toonMat(0x5a504a));
    rock.position.set(x, height / 2, z);
    rock.castShadow = true;
    rock.receiveShadow = true;
    scene.add(rock);

    // Metal reinforcement strip
    const stripGeo = new THREE.BoxGeometry(width + 0.05, 0.2, depth + 0.05);
    const strip = new THREE.Mesh(stripGeo, toonMat(0x7a8a8a));
    strip.position.set(x, height * 0.6, z);
    scene.add(strip);

    return rock;
}

// Left wall segments
for (let i = 0; i < 8; i++) {
    const z = -10 + i * 2.8;
    const h = 2.5 + Math.random() * 1.5;
    const w = 2 + Math.random() * 1;
    createWallSection(-6, z, w, h, 2.5);
}

// Right wall segments
for (let i = 0; i < 8; i++) {
    const z = -10 + i * 2.8;
    const h = 2.5 + Math.random() * 1.5;
    const w = 2 + Math.random() * 1;
    createWallSection(6, z, w, h, 2.5);
}

// ============================================================
// ENERGY GATE
// ============================================================
function createEnergyGate() {
    const group = new THREE.Group();

    // Gate posts — tall metallic pillars
    for (const side of [-1, 1]) {
        const postGeo = new THREE.BoxGeometry(0.5, 4, 0.5);
        const post = new THREE.Mesh(postGeo, toonMat(0x6688aa));
        post.position.set(side * 2, 2, 0);
        post.castShadow = true;
        group.add(post);

        // Top cap
        const capGeo = new THREE.BoxGeometry(0.7, 0.3, 0.7);
        const cap = new THREE.Mesh(capGeo, toonMat(0x88aacc));
        cap.position.set(side * 2, 4.15, 0);
        group.add(cap);
    }

    // Crossbar
    const barGeo = new THREE.BoxGeometry(4.5, 0.3, 0.3);
    const bar = new THREE.Mesh(barGeo, toonMat(0x6688aa));
    bar.position.set(0, 4, 0);
    group.add(bar);

    // Energy barrier — glowing translucent plane
    const barrierGeo = new THREE.PlaneGeometry(3.5, 3.8);
    const barrierMat = new THREE.MeshStandardMaterial({
        color: 0x00ffcc,
        emissive: 0x00ffcc,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.35,
        side: THREE.DoubleSide,
    });
    const barrier = new THREE.Mesh(barrierGeo, barrierMat);
    barrier.position.set(0, 2, 0);
    group.add(barrier);
    group.userData.barrierMat = barrierMat;

    // Gate glow light
    const gateLight = new THREE.PointLight(0x00ffcc, 2, 8, 2);
    gateLight.position.set(0, 2, 0);
    group.add(gateLight);
    group.userData.gateLight = gateLight;

    group.position.set(0, 0, 9);
    scene.add(group);
    return group;
}

const gate = createEnergyGate();
let gateHP = 100;

// ============================================================
// TOWER PADS & TOWERS
// ============================================================
const TOWER_TYPES = {
    laser:   { name: 'Laser Turret',      color: 0xff3333, barrel: 0xcc2222 },
    missile: { name: 'Missile Pod',        color: 0x3366ff, barrel: 0x2244cc },
    shield:  { name: 'Shield Generator',   color: 0x33ff99, barrel: 0x22cc77 },
    emp:     { name: 'EMP Pylon',          color: 0xcc66ff, barrel: 0xaa44dd },
};

// Tower pad positions: 2 columns x 3 rows
const TOWER_POSITIONS = [
    { x: -3.5, z: -5, row: 0, col: 0 },  // T0 upper-left
    { x:  3.5, z: -5, row: 0, col: 1 },  // T1 upper-right
    { x: -3.5, z:  0, row: 1, col: 0 },  // T2 middle-left
    { x:  3.5, z:  0, row: 1, col: 1 },  // T3 middle-right
    { x: -3.5, z:  5, row: 2, col: 0 },  // T4 lower-left
    { x:  3.5, z:  5, row: 2, col: 1 },  // T5 lower-right
];

// Pre-assign tower types
const TOWER_ASSIGNMENTS = ['laser', 'missile', 'laser', 'emp', 'shield', 'missile'];

const towers = [];

function createTowerPad(pos, towerType, index) {
    const group = new THREE.Group();
    const info = TOWER_TYPES[towerType];

    // Platform base — hexagonal pad
    const padGeo = new THREE.CylinderGeometry(1.2, 1.3, 0.3, 6);
    const padMat = toonMat(0x3a3a44);
    const pad = new THREE.Mesh(padGeo, padMat);
    pad.position.y = 0.15;
    pad.castShadow = true;
    pad.receiveShadow = true;
    group.add(pad);

    // Platform ring — edge highlight
    const ringGeo = new THREE.TorusGeometry(1.25, 0.05, 4, 6);
    const ringMat = toonMat(0x5a6a7a);
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.31;
    group.add(ring);

    // Tower base — cylinder
    const baseGeo = new THREE.CylinderGeometry(0.5, 0.6, 0.8, 6);
    const baseMat = toonMat(0x4a4a55);
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = 0.7;
    base.castShadow = true;
    group.add(base);

    // Tower body — colored by type
    const bodyGeo = new THREE.CylinderGeometry(0.35, 0.45, 1.2, 6);
    const bodyMat = toonMat(info.color);
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 1.7;
    body.castShadow = true;
    group.add(body);

    // Tower top / barrel — varies by type
    let topMesh;
    if (towerType === 'laser') {
        const barrelGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 4);
        topMesh = new THREE.Mesh(barrelGeo, toonMat(info.barrel));
        topMesh.rotation.x = Math.PI / 2;
        topMesh.position.set(0, 2.2, -0.5);
    } else if (towerType === 'missile') {
        const podGeo = new THREE.BoxGeometry(0.6, 0.4, 0.4);
        topMesh = new THREE.Mesh(podGeo, toonMat(info.barrel));
        topMesh.position.set(0, 2.5, 0);
    } else if (towerType === 'shield') {
        const domeGeo = new THREE.SphereGeometry(0.4, 6, 4, 0, Math.PI * 2, 0, Math.PI / 2);
        topMesh = new THREE.Mesh(domeGeo, toonMat(info.barrel));
        topMesh.position.set(0, 2.3, 0);
    } else if (towerType === 'emp') {
        const antennaGeo = new THREE.CylinderGeometry(0.03, 0.03, 1.0, 4);
        topMesh = new THREE.Mesh(antennaGeo, toonMat(info.barrel));
        topMesh.position.set(0, 2.8, 0);
        // EMP ring
        const empRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.3, 0.04, 4, 8),
            toonMat(info.color)
        );
        empRing.position.set(0, 2.9, 0);
        empRing.rotation.x = Math.PI / 2;
        group.add(empRing);
    }
    if (topMesh) {
        topMesh.castShadow = true;
        group.add(topMesh);
    }

    // Cursor ring — glowing selection indicator (hidden by default)
    const cursorGeo = new THREE.TorusGeometry(1.4, 0.08, 4, 16);
    const cursorMat = new THREE.MeshStandardMaterial({
        color: 0x00ffcc,
        emissive: 0x00ffcc,
        emissiveIntensity: 1.0,
        transparent: true,
        opacity: 0,
    });
    const cursor = new THREE.Mesh(cursorGeo, cursorMat);
    cursor.rotation.x = -Math.PI / 2;
    cursor.position.y = 0.35;
    group.add(cursor);

    // Occupied indicator light
    const indicatorMat = new THREE.MeshStandardMaterial({
        color: 0x00ff88,
        emissive: 0x00ff88,
        emissiveIntensity: 0,
    });
    const indicatorGeo = new THREE.SphereGeometry(0.1, 4, 4);
    const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
    indicator.position.set(0, 3.2, 0);
    group.add(indicator);

    group.position.set(pos.x, 0, pos.z);
    scene.add(group);

    const towerData = {
        id: index,
        type: towerType,
        name: info.name,
        group,
        cursorMat,
        indicatorMat,
        occupied: false,
        playerIdx: -1,
        pos,
    };
    towers.push(towerData);
    return towerData;
}

// Create all tower pads
for (let i = 0; i < TOWER_POSITIONS.length; i++) {
    createTowerPad(TOWER_POSITIONS[i], TOWER_ASSIGNMENTS[i], i);
}

// ============================================================
// SPAWN ZONE MARKER
// ============================================================
const spawnMarkerGeo = new THREE.PlaneGeometry(4, 1);
const spawnMarkerMat = new THREE.MeshStandardMaterial({
    color: 0xff4444,
    emissive: 0xff4444,
    emissiveIntensity: 0.3,
    transparent: true,
    opacity: 0.25,
    side: THREE.DoubleSide,
});
const spawnMarker = new THREE.Mesh(spawnMarkerGeo, spawnMarkerMat);
spawnMarker.rotation.x = -Math.PI / 2;
spawnMarker.position.set(0, 0.02, -10);
scene.add(spawnMarker);

// ============================================================
// LIGHTING
// ============================================================
const sun = new THREE.DirectionalLight(0x8899bb, 1.8);
sun.position.set(10, 18, 8);
sun.castShadow = true;
sun.shadow.mapSize.set(512, 512);
sun.shadow.camera.left = -20;
sun.shadow.camera.right = 20;
sun.shadow.camera.top = 20;
sun.shadow.camera.bottom = -20;
scene.add(sun);

const ambient = new THREE.AmbientLight(0x445577, 1.0);
scene.add(ambient);

const hemi = new THREE.HemisphereLight(0x2a2a4a, 0x3a3530, 0.5);
scene.add(hemi);

// ============================================================
// PLAYER STATE
// ============================================================
const players = [
    { idx: 0, cursorAt: 0, inTower: false, color: '#00ccff', gamepadIndex: -1, active: false },
    { idx: 1, cursorAt: 1, inTower: false, color: '#ff4444', gamepadIndex: -1, active: false },
    { idx: 2, cursorAt: 2, inTower: false, color: '#44ff44', gamepadIndex: -1, active: false },
    { idx: 3, cursorAt: 3, inTower: false, color: '#ffcc00', gamepadIndex: -1, active: false },
];

// Player 0 always active (keyboard fallback)
players[0].active = true;

// ============================================================
// INPUT SYSTEM
// ============================================================
const inputQueue = []; // { playerIdx, action }
const keyState = {};
const prevKeyState = {};
const prevGamepadButtons = [[], [], [], []];

window.addEventListener('keydown', e => { keyState[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keyState[e.key.toLowerCase()] = false; });

// Gamepad connect/disconnect
window.addEventListener('gamepadconnected', e => {
    console.log(`Gamepad ${e.gamepad.index} connected: ${e.gamepad.id}`);
    // Assign to first unassigned player
    for (const p of players) {
        if (p.gamepadIndex === -1) {
            p.gamepadIndex = e.gamepad.index;
            p.active = true;
            console.log(`  → Assigned to Player ${p.idx + 1}`);
            break;
        }
    }
});

window.addEventListener('gamepaddisconnected', e => {
    console.log(`Gamepad ${e.gamepad.index} disconnected`);
    for (const p of players) {
        if (p.gamepadIndex === e.gamepad.index) {
            p.gamepadIndex = -1;
            if (p.idx !== 0) p.active = false; // P0 stays active (keyboard)
        }
    }
});

// Input cooldown per player
const inputCooldown = [0, 0, 0, 0];
const COOLDOWN_MS = 200;

function queueAction(playerIdx, action) {
    const now = performance.now();
    if (now - inputCooldown[playerIdx] < COOLDOWN_MS) return;
    inputCooldown[playerIdx] = now;
    inputQueue.push({ playerIdx, action });
}

function pollKeyboard() {
    const pressed = (key) => keyState[key] && !prevKeyState[key];
    if (pressed('w') || pressed('arrowup'))    queueAction(0, 'up');
    if (pressed('s') || pressed('arrowdown'))  queueAction(0, 'down');
    if (pressed('a') || pressed('arrowleft'))  queueAction(0, 'left');
    if (pressed('d') || pressed('arrowright')) queueAction(0, 'right');
    if (pressed(' ') || pressed('enter'))      queueAction(0, 'hop');
    Object.assign(prevKeyState, keyState);
}

function pollGamepads() {
    const gamepads = navigator.getGamepads();
    for (const p of players) {
        if (p.gamepadIndex === -1) continue;
        const gp = gamepads[p.gamepadIndex];
        if (!gp) continue;

        const prev = prevGamepadButtons[p.idx];
        const justPressed = (btnIdx) => gp.buttons[btnIdx]?.pressed && !prev[btnIdx];

        // D-pad: buttons 12=up, 13=down, 14=left, 15=right
        if (justPressed(12)) queueAction(p.idx, 'up');
        if (justPressed(13)) queueAction(p.idx, 'down');
        if (justPressed(14)) queueAction(p.idx, 'left');
        if (justPressed(15)) queueAction(p.idx, 'right');

        // Left stick with threshold (treat as d-pad)
        const lx = gp.axes[0] || 0;
        const ly = gp.axes[1] || 0;
        const stickThreshold = 0.6;
        const prevLx = p._prevLx || 0;
        const prevLy = p._prevLy || 0;
        if (ly < -stickThreshold && prevLy >= -stickThreshold) queueAction(p.idx, 'up');
        if (ly > stickThreshold && prevLy <= stickThreshold)   queueAction(p.idx, 'down');
        if (lx < -stickThreshold && prevLx >= -stickThreshold) queueAction(p.idx, 'left');
        if (lx > stickThreshold && prevLx <= stickThreshold)   queueAction(p.idx, 'right');
        p._prevLx = lx;
        p._prevLy = ly;

        // A button (button 0)
        if (justPressed(0)) queueAction(p.idx, 'hop');

        // Save button state
        prevGamepadButtons[p.idx] = gp.buttons.map(b => b.pressed);
    }
}

// ============================================================
// CURSOR & TOWER HOPPING
// ============================================================

// Navigation adjacency for 2x3 grid
// Index: row * 2 + col
function navigate(currentIdx, direction) {
    const pos = TOWER_POSITIONS[currentIdx];
    let newRow = pos.row;
    let newCol = pos.col;

    switch (direction) {
        case 'up':    newRow = Math.max(0, pos.row - 1); break;
        case 'down':  newRow = Math.min(2, pos.row + 1); break;
        case 'left':  newCol = 0; break;
        case 'right': newCol = 1; break;
    }
    return newRow * 2 + newCol;
}

function processInputs() {
    while (inputQueue.length > 0) {
        const { playerIdx, action } = inputQueue.shift();
        const player = players[playerIdx];
        if (!player.active) continue;

        if (action === 'hop') {
            if (player.inTower) {
                // Hop out
                const tower = towers[player.cursorAt];
                tower.occupied = false;
                tower.playerIdx = -1;
                player.inTower = false;
            } else {
                // Hop in (if tower not already occupied by someone else)
                const tower = towers[player.cursorAt];
                if (!tower.occupied) {
                    tower.occupied = true;
                    tower.playerIdx = playerIdx;
                    player.inTower = true;
                }
            }
        } else if (!player.inTower) {
            // Navigate between towers (only when not in a tower)
            const newIdx = navigate(player.cursorAt, action);
            player.cursorAt = newIdx;
        }
    }
}

// ============================================================
// HUD UPDATE
// ============================================================
const hudTower = document.getElementById('hud-tower');
const hudGate = document.getElementById('hud-gate');

function updateHUD() {
    const p = players[0]; // Show P1 info for now
    const tower = towers[p.cursorAt];
    const status = p.inTower ? ' [MANNED]' : '';
    hudTower.textContent = `P1 → ${tower.name}${status}`;
    hudGate.textContent = `GATE: ${gateHP}%`;
}

// ============================================================
// WINDOW API — Playwright testing
// ============================================================
window.gameState = {
    phase: 'idle',
    wave: 0,
    gateHP: 100,
    towers: [],
    enemies: [],
    players: [],
    score: 0,
};

window.injectInput = function(playerIdx, action) {
    if (playerIdx >= 0 && playerIdx < 4) {
        players[playerIdx].active = true;
        // Bypass cooldown for testing
        inputCooldown[playerIdx] = 0;
        queueAction(playerIdx, action);
        // Return promise that resolves after 2 frames (input processed + state updated)
        return new Promise(resolve => {
            requestAnimationFrame(() => requestAnimationFrame(() => {
                resolve(window.gameState);
            }));
        });
    }
    return Promise.resolve(window.gameState);
};

window.startWave = function() {
    // M2: will start enemy spawning
    console.log('startWave() — not yet implemented (M2)');
};

window.skipToWave = function(n) {
    console.log(`skipToWave(${n}) — not yet implemented (M2)`);
};

function updateWindowAPI() {
    window.gameState.gateHP = gateHP;
    window.gameState.towers = towers.map(t => ({
        id: t.id,
        type: t.type,
        name: t.name,
        occupied: t.occupied,
        playerIdx: t.playerIdx,
    }));
    window.gameState.players = players.filter(p => p.active).map(p => ({
        idx: p.idx,
        cursorAt: p.cursorAt,
        inTower: p.inTower,
        color: p.color,
    }));
}

// ============================================================
// GAME LOOP
// ============================================================
let time = 0;

function animate() {
    requestAnimationFrame(animate);
    time += 0.016;

    // Input
    pollKeyboard();
    pollGamepads();
    processInputs();

    // Update cursor visuals
    for (const tower of towers) {
        let targetOpacity = 0;
        let cursorColor = 0x00ffcc;
        let indicatorIntensity = 0;

        for (const p of players) {
            if (!p.active) continue;
            if (p.cursorAt === tower.id) {
                targetOpacity = 0.7 + Math.sin(time * 6) * 0.3; // pulse
                cursorColor = parseInt(p.color.replace('#', '0x'));
            }
        }

        if (tower.occupied) {
            indicatorIntensity = 0.8 + Math.sin(time * 4) * 0.2;
            const occupant = players[tower.playerIdx];
            if (occupant) {
                tower.indicatorMat.color.set(occupant.color);
                tower.indicatorMat.emissive.set(occupant.color);
            }
        }

        tower.cursorMat.opacity = targetOpacity;
        if (targetOpacity > 0) {
            tower.cursorMat.color.set(cursorColor);
            tower.cursorMat.emissive.set(cursorColor);
        }
        tower.indicatorMat.emissiveIntensity = indicatorIntensity;
    }

    // Gate barrier pulse
    const gateMat = gate.userData.barrierMat;
    gateMat.opacity = 0.25 + Math.sin(time * 3) * 0.1;
    gateMat.emissiveIntensity = 0.4 + Math.sin(time * 2) * 0.2;
    gate.userData.gateLight.intensity = 1.5 + Math.sin(time * 2.5) * 0.5;

    // Spawn marker pulse
    spawnMarkerMat.opacity = 0.15 + Math.sin(time * 2) * 0.1;

    // HUD
    updateHUD();

    // Window API
    updateWindowAPI();

    renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
