<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rampart Ridge</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a12;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #hud {
            position: fixed;
            top: 0; left: 0; right: 0;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            color: #00ffcc;
            text-shadow: 0 0 4px #00ffcc88;
            padding: 12px 16px;
            font-size: 14px;
            z-index: 10;
        }
        #hud-bottom {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            color: #00ffcc88;
            text-shadow: 0 0 4px #00ffcc44;
            padding: 8px 16px;
            font-size: 11px;
            text-align: center;
            z-index: 10;
        }
        .hud-row { display: flex; justify-content: space-between; }
    </style>
</head>
<body>
<div id="hud">
    <div class="hud-row">
        <span id="hud-wave">IDLE</span>
        <span id="hud-credits" style="color:#44ddff;text-shadow:0 0 4px #44ddff88">&#9889; 150</span>
        <span id="hud-gate">GATE: 100%</span>
    </div>
    <div class="hud-row" style="margin-top:4px">
        <span id="hud-score" style="color:#ffcc00;text-shadow:0 0 4px #ffcc0088">SCORE: 0</span>
        <span id="hud-enemies" style="color:#ff666688"></span>
    </div>
    <div id="hud-players" style="margin-top:6px;font-size:12px;line-height:1.6"></div>
</div>
<div id="hud-bottom">
    <span id="hud-controls">[D-PAD] Move &bull; [A] Hop &bull; [X] Build &bull; [B] Sell &bull; [RT] Fire &bull; [START] Go</span>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';

// ============================================================
// CONFIG
// ============================================================
const RENDER_W = 320;
const RENDER_H = 240;
const PIXEL_SCALE = 3;

// ============================================================
// RENDERER
// ============================================================
const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(RENDER_W, RENDER_H);
renderer.domElement.style.width = `${RENDER_W * PIXEL_SCALE}px`;
renderer.domElement.style.height = `${RENDER_H * PIXEL_SCALE}px`;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.BasicShadowMap;
renderer.setClearColor(0x121225);
document.body.appendChild(renderer.domElement);

// ============================================================
// SCENE
// ============================================================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x121225, 0.012);

// ============================================================
// CAMERA — orthographic isometric
// ============================================================
const aspect = RENDER_W / RENDER_H;
const frustum = 14;
const camera = new THREE.OrthographicCamera(
    -frustum * aspect, frustum * aspect,
    frustum, -frustum,
    0.1, 120
);
// Isometric angle looking down the valley
camera.position.set(18, 22, 18);
camera.lookAt(0, 0, 0);

// ============================================================
// TOON SHADING
// ============================================================
const toonGradient = new THREE.DataTexture(
    new Uint8Array([60, 140, 240]),
    3, 1, THREE.RedFormat
);
toonGradient.minFilter = THREE.NearestFilter;
toonGradient.magFilter = THREE.NearestFilter;
toonGradient.needsUpdate = true;

function toonMat(color) {
    return new THREE.MeshToonMaterial({ color, gradientMap: toonGradient });
}

// ============================================================
// VALLEY TERRAIN
// ============================================================

// Ground — dusty sci-fi terrain
const groundGeo = new THREE.PlaneGeometry(40, 40);
const groundMat = toonMat(0x3a3530);
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
ground.receiveShadow = true;
scene.add(ground);

// Ground detail patches — darker/lighter dust
const dustColors = [0x221e1a, 0x33302a, 0x1e1b17, 0x3a3530];
for (let i = 0; i < 40; i++) {
    const size = 0.5 + Math.random() * 2;
    const geo = new THREE.CircleGeometry(size, 5 + Math.floor(Math.random() * 3));
    const mat = toonMat(dustColors[Math.floor(Math.random() * dustColors.length)]);
    mat.polygonOffset = true;
    mat.polygonOffsetFactor = -1 - i * 0.01;
    mat.polygonOffsetUnits = -1;
    const patch = new THREE.Mesh(geo, mat);
    patch.rotation.x = -Math.PI / 2;
    patch.position.set(
        (Math.random() - 0.5) * 30,
        0.005 + i * 0.0001,
        (Math.random() - 0.5) * 30
    );
    patch.receiveShadow = true;
    scene.add(patch);
}

// Metal path down the center — enemy route
const pathGeo = new THREE.PlaneGeometry(2.5, 22);
const pathMat = toonMat(0x3a3a44);
const pathMesh = new THREE.Mesh(pathGeo, pathMat);
pathMesh.rotation.x = -Math.PI / 2;
pathMesh.position.set(0, 0.01, -1);
pathMesh.receiveShadow = true;
scene.add(pathMesh);

// Path edge strips — metallic trim
for (const side of [-1, 1]) {
    const stripGeo = new THREE.PlaneGeometry(0.15, 22);
    const stripMat = toonMat(0x5a5a6a);
    const strip = new THREE.Mesh(stripGeo, stripMat);
    strip.rotation.x = -Math.PI / 2;
    strip.position.set(side * 1.35, 0.015, -1);
    strip.receiveShadow = true;
    scene.add(strip);
}

// ============================================================
// CANYON WALLS
// ============================================================
function createWallSection(x, z, width, height, depth) {
    const geo = new THREE.BoxGeometry(width, height, depth);
    const rock = new THREE.Mesh(geo, toonMat(0x5a504a));
    rock.position.set(x, height / 2, z);
    rock.castShadow = true;
    rock.receiveShadow = true;
    scene.add(rock);

    // Metal reinforcement strip
    const stripGeo = new THREE.BoxGeometry(width + 0.05, 0.2, depth + 0.05);
    const strip = new THREE.Mesh(stripGeo, toonMat(0x7a8a8a));
    strip.position.set(x, height * 0.6, z);
    scene.add(strip);

    return rock;
}

// Left wall segments
for (let i = 0; i < 8; i++) {
    const z = -10 + i * 2.8;
    const h = 2.5 + Math.random() * 1.5;
    const w = 2 + Math.random() * 1;
    createWallSection(-6, z, w, h, 2.5);
}

// Right wall segments
for (let i = 0; i < 8; i++) {
    const z = -10 + i * 2.8;
    const h = 2.5 + Math.random() * 1.5;
    const w = 2 + Math.random() * 1;
    createWallSection(6, z, w, h, 2.5);
}

// ============================================================
// ENERGY GATE
// ============================================================
function createEnergyGate() {
    const group = new THREE.Group();

    // Gate posts — tall metallic pillars
    for (const side of [-1, 1]) {
        const postGeo = new THREE.BoxGeometry(0.5, 4, 0.5);
        const post = new THREE.Mesh(postGeo, toonMat(0x6688aa));
        post.position.set(side * 2, 2, 0);
        post.castShadow = true;
        group.add(post);

        // Top cap
        const capGeo = new THREE.BoxGeometry(0.7, 0.3, 0.7);
        const cap = new THREE.Mesh(capGeo, toonMat(0x88aacc));
        cap.position.set(side * 2, 4.15, 0);
        group.add(cap);
    }

    // Crossbar
    const barGeo = new THREE.BoxGeometry(4.5, 0.3, 0.3);
    const bar = new THREE.Mesh(barGeo, toonMat(0x6688aa));
    bar.position.set(0, 4, 0);
    group.add(bar);

    // Energy barrier — glowing translucent plane
    const barrierGeo = new THREE.PlaneGeometry(3.5, 3.8);
    const barrierMat = new THREE.MeshStandardMaterial({
        color: 0x00ffcc,
        emissive: 0x00ffcc,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.35,
        side: THREE.DoubleSide,
    });
    const barrier = new THREE.Mesh(barrierGeo, barrierMat);
    barrier.position.set(0, 2, 0);
    group.add(barrier);
    group.userData.barrierMat = barrierMat;

    // Gate glow light
    const gateLight = new THREE.PointLight(0x00ffcc, 2, 8, 2);
    gateLight.position.set(0, 2, 0);
    group.add(gateLight);
    group.userData.gateLight = gateLight;

    group.position.set(0, 0, 9);
    scene.add(group);
    return group;
}

const gate = createEnergyGate();
let gateHP = 100;

// ============================================================
// TOWER PADS & TOWERS
// ============================================================
const TOWER_TYPES = {
    laser:   { name: 'Laser Turret',      color: 0xff3333, barrel: 0xcc2222, cost: 50 },
    missile: { name: 'Missile Pod',        color: 0x3366ff, barrel: 0x2244cc, cost: 75 },
    shield:  { name: 'Shield Generator',   color: 0x33ff99, barrel: 0x22cc77, cost: 60 },
    emp:     { name: 'EMP Pylon',          color: 0xcc66ff, barrel: 0xaa44dd, cost: 80 },
};
const BUILD_ORDER = ['laser', 'missile', 'shield', 'emp'];
let credits = 150; // starting credits — enough for 2-3 towers

// Tower pad positions: 2 columns x 3 rows
const TOWER_POSITIONS = [
    { x: -3.5, z: -5, row: 0, col: 0 },  // T0 upper-left
    { x:  3.5, z: -5, row: 0, col: 1 },  // T1 upper-right
    { x: -3.5, z:  0, row: 1, col: 0 },  // T2 middle-left
    { x:  3.5, z:  0, row: 1, col: 1 },  // T3 middle-right
    { x: -3.5, z:  5, row: 2, col: 0 },  // T4 lower-left
    { x:  3.5, z:  5, row: 2, col: 1 },  // T5 lower-right
];

const towers = [];

function createTowerPad(pos, index) {
    const group = new THREE.Group();

    // Platform base — hexagonal pad
    const padGeo = new THREE.CylinderGeometry(1.2, 1.3, 0.3, 6);
    const padMat = toonMat(0x3a3a44);
    const pad = new THREE.Mesh(padGeo, padMat);
    pad.position.y = 0.15;
    pad.castShadow = true;
    pad.receiveShadow = true;
    group.add(pad);

    // Platform ring — edge highlight
    const ringGeo = new THREE.TorusGeometry(1.25, 0.05, 4, 6);
    const ringMat = toonMat(0x5a6a7a);
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.31;
    group.add(ring);

    // Occupied indicator light
    const indicatorMat = new THREE.MeshStandardMaterial({
        color: 0x00ff88,
        emissive: 0x00ff88,
        emissiveIntensity: 0,
    });
    const indicatorGeo = new THREE.SphereGeometry(0.1, 4, 4);
    const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
    indicator.position.set(0, 3.2, 0);
    group.add(indicator);

    group.position.set(pos.x, 0, pos.z);
    scene.add(group);

    const towerData = {
        id: index,
        type: null,      // null = empty pad
        name: 'Empty Pad',
        group,
        towerMeshGroup: null, // sub-group for tower meshes (removable)
        indicatorMat,
        occupied: false,
        playerIdx: -1,
        pos,
        fireCooldown: 0,
        empReady: true,
        shieldDome: null, // managed by combat system for shield towers
    };
    towers.push(towerData);
    return towerData;
}

function buildTowerMeshes(towerType) {
    const info = TOWER_TYPES[towerType];
    const sub = new THREE.Group();

    // Tower base — cylinder
    const baseGeo = new THREE.CylinderGeometry(0.5, 0.6, 0.8, 6);
    const baseMat = toonMat(0x4a4a55);
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = 0.7;
    base.castShadow = true;
    sub.add(base);

    // Tower body — colored by type
    const bodyGeo = new THREE.CylinderGeometry(0.35, 0.45, 1.2, 6);
    const bodyMat = toonMat(info.color);
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 1.7;
    body.castShadow = true;
    sub.add(body);

    // Tower top / barrel — varies by type
    let topMesh;
    if (towerType === 'laser') {
        const barrelGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 4);
        topMesh = new THREE.Mesh(barrelGeo, toonMat(info.barrel));
        topMesh.rotation.x = Math.PI / 2;
        topMesh.position.set(0, 2.2, -0.5);
    } else if (towerType === 'missile') {
        const podGeo = new THREE.BoxGeometry(0.6, 0.4, 0.4);
        topMesh = new THREE.Mesh(podGeo, toonMat(info.barrel));
        topMesh.position.set(0, 2.5, 0);
    } else if (towerType === 'shield') {
        const domeGeo = new THREE.SphereGeometry(0.4, 6, 4, 0, Math.PI * 2, 0, Math.PI / 2);
        topMesh = new THREE.Mesh(domeGeo, toonMat(info.barrel));
        topMesh.position.set(0, 2.3, 0);
    } else if (towerType === 'emp') {
        const antennaGeo = new THREE.CylinderGeometry(0.03, 0.03, 1.0, 4);
        topMesh = new THREE.Mesh(antennaGeo, toonMat(info.barrel));
        topMesh.position.set(0, 2.8, 0);
        const empRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.3, 0.04, 4, 8),
            toonMat(info.color)
        );
        empRing.position.set(0, 2.9, 0);
        empRing.rotation.x = Math.PI / 2;
        sub.add(empRing);
    }
    if (topMesh) {
        topMesh.castShadow = true;
        sub.add(topMesh);
    }

    return sub;
}

function buildTowerOn(towerData, towerType) {
    const info = TOWER_TYPES[towerType];
    towerData.type = towerType;
    towerData.name = info.name;
    towerData.fireCooldown = 0;
    towerData.empReady = true;

    // Add tower meshes
    const meshGroup = buildTowerMeshes(towerType);
    towerData.group.add(meshGroup);
    towerData.towerMeshGroup = meshGroup;
}

function sellTower(towerData) {
    if (!towerData.type) return 0;
    const refund = Math.floor(TOWER_TYPES[towerData.type].cost * 0.5);

    // Remove tower meshes
    if (towerData.towerMeshGroup) {
        towerData.group.remove(towerData.towerMeshGroup);
        towerData.towerMeshGroup = null;
    }

    // Evict any player
    if (towerData.occupied) {
        const p = players[towerData.playerIdx];
        if (p) p.inTower = false;
        towerData.occupied = false;
        towerData.playerIdx = -1;
    }

    towerData.type = null;
    towerData.name = 'Empty Pad';
    return refund;
}

// Create all tower pads (start empty)
for (let i = 0; i < TOWER_POSITIONS.length; i++) {
    createTowerPad(TOWER_POSITIONS[i], i);
}
// Give player 2 starter towers so they can fight wave 1
buildTowerOn(towers[0], 'laser');
buildTowerOn(towers[1], 'missile');

// ============================================================
// SPAWN ZONE MARKER
// ============================================================
const spawnMarkerGeo = new THREE.PlaneGeometry(4, 1);
const spawnMarkerMat = new THREE.MeshStandardMaterial({
    color: 0xff4444,
    emissive: 0xff4444,
    emissiveIntensity: 0.3,
    transparent: true,
    opacity: 0.25,
    side: THREE.DoubleSide,
});
const spawnMarker = new THREE.Mesh(spawnMarkerGeo, spawnMarkerMat);
spawnMarker.rotation.x = -Math.PI / 2;
spawnMarker.position.set(0, 0.02, -10);
scene.add(spawnMarker);

// ============================================================
// LIGHTING
// ============================================================
const sun = new THREE.DirectionalLight(0x8899bb, 1.8);
sun.position.set(10, 18, 8);
sun.castShadow = true;
sun.shadow.mapSize.set(512, 512);
sun.shadow.camera.left = -20;
sun.shadow.camera.right = 20;
sun.shadow.camera.top = 20;
sun.shadow.camera.bottom = -20;
scene.add(sun);

const ambient = new THREE.AmbientLight(0x445577, 1.0);
scene.add(ambient);

const hemi = new THREE.HemisphereLight(0x2a2a4a, 0x3a3530, 0.5);
scene.add(hemi);

// ============================================================
// ENEMY SYSTEM
// ============================================================
const ENEMY_TYPES = {
    drone:   { name: 'Drone',          hp: 20,  speed: 2.0, damage: 5,  score: 10, color: 0x88aacc, size: 0.25 },
    scout:   { name: 'Scout',          hp: 8,   speed: 4.5, damage: 3,  score: 15, color: 0xffaa33, size: 0.2 },
    walker:  { name: 'Armored Walker', hp: 60,  speed: 1.0, damage: 15, score: 25, color: 0x556655, size: 0.4 },
    heavy:   { name: 'Heavy Mech',     hp: 150, speed: 0.7, damage: 30, score: 50, color: 0x993333, size: 0.55 },
};

const enemies = [];
let nextEnemyId = 0;

function createEnemy(type, laneOffset) {
    const info = ENEMY_TYPES[type];
    const group = new THREE.Group();

    if (type === 'drone') {
        // Hovering hexagonal body
        const bodyGeo = new THREE.BoxGeometry(0.3, 0.2, 0.3);
        const body = new THREE.Mesh(bodyGeo, toonMat(info.color));
        body.castShadow = true;
        group.add(body);
        // Eye
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.8 });
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.06, 4, 4), eyeMat);
        eye.position.set(0, 0.02, -0.16);
        group.add(eye);
    } else if (type === 'scout') {
        // Wedge shape
        const bodyGeo = new THREE.ConeGeometry(0.18, 0.5, 3);
        const body = new THREE.Mesh(bodyGeo, toonMat(info.color));
        body.rotation.x = Math.PI / 2;
        body.castShadow = true;
        group.add(body);
    } else if (type === 'walker') {
        // Bulky box with legs
        const bodyGeo = new THREE.BoxGeometry(0.5, 0.35, 0.5);
        const body = new THREE.Mesh(bodyGeo, toonMat(info.color));
        body.position.y = 0.1;
        body.castShadow = true;
        group.add(body);
        for (const [lx, lz] of [[-0.2, -0.2], [0.2, -0.2], [-0.2, 0.2], [0.2, 0.2]]) {
            const leg = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.3, 0.08),
                toonMat(0x444444)
            );
            leg.position.set(lx, -0.2, lz);
            group.add(leg);
        }
    } else if (type === 'heavy') {
        // Big mech body + shoulder guns
        const bodyGeo = new THREE.BoxGeometry(0.6, 0.5, 0.6);
        const body = new THREE.Mesh(bodyGeo, toonMat(info.color));
        body.position.y = 0.15;
        body.castShadow = true;
        group.add(body);
        for (const side of [-1, 1]) {
            const gun = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.15, 0.3),
                toonMat(0x666666)
            );
            gun.position.set(side * 0.35, 0.35, -0.15);
            group.add(gun);
        }
        for (const [lx, lz] of [[-0.25, -0.25], [0.25, -0.25], [-0.25, 0.25], [0.25, 0.25]]) {
            const leg = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.35, 0.1),
                toonMat(0x444444)
            );
            leg.position.set(lx, -0.25, lz);
            group.add(leg);
        }
    }

    const spawnZ = -11;
    group.position.set(laneOffset, info.size + 0.1, spawnZ);
    scene.add(group);

    const enemy = {
        id: nextEnemyId++,
        type,
        hp: info.hp,
        maxHp: info.hp,
        speed: info.speed,
        damage: info.damage,
        score: info.score,
        group,
        x: laneOffset,
        z: spawnZ,
        stunTimer: 0,
        slowFactor: 1,
        dead: false,
    };
    enemies.push(enemy);
    return enemy;
}

function updateEnemies(dt) {
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (e.dead) continue;

        // Stun countdown
        if (e.stunTimer > 0) {
            e.stunTimer -= dt;
            // Visual: blink when stunned
            e.group.visible = Math.sin(time * 20) > 0;
            continue;
        }
        e.group.visible = true;

        // Move toward gate
        const effectiveSpeed = e.speed * e.slowFactor;
        e.z += effectiveSpeed * dt;
        e.slowFactor = 1; // Reset each frame (shield re-applies)

        // Hover bob for drones/scouts
        const bob = (e.type === 'drone' || e.type === 'scout')
            ? Math.sin(time * 5 + e.id * 2) * 0.1 + 0.3
            : ENEMY_TYPES[e.type].size + 0.1;

        e.group.position.set(e.x, bob, e.z);

        // Reached the gate?
        if (e.z >= 9) {
            gateHP = Math.max(0, gateHP - e.damage);
            triggerShake(e.type === 'heavy' ? 1.5 : 0.6);
            killEnemy(i, false); // no score for reaching gate
            if (gateHP <= 0 && gamePhase !== 'gameover') {
                gamePhase = 'gameover';
            }
        }
    }
}

function killEnemy(index, giveScore) {
    const e = enemies[index];
    e.dead = true;
    if (giveScore) {
        score += e.score;
        credits += e.score; // credits mirror score
        if (e.type === 'heavy') triggerShake(1.0);
    }

    // Death effect: flash and scale
    const pos = e.group.position.clone();
    scene.remove(e.group);
    enemies.splice(index, 1);

    // Particle burst
    spawnDeathEffect(pos, ENEMY_TYPES[e.type].color);
}

// ============================================================
// DEATH EFFECTS
// ============================================================
const deathEffects = [];

function spawnDeathEffect(pos, color) {
    const count = 6;
    for (let i = 0; i < count; i++) {
        const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const mat = new THREE.MeshStandardMaterial({
            color, emissive: color, emissiveIntensity: 1.0,
        });
        const particle = new THREE.Mesh(geo, mat);
        particle.position.copy(pos);
        const angle = (i / count) * Math.PI * 2;
        const speed = 1.5 + Math.random() * 1.5;
        scene.add(particle);
        deathEffects.push({
            mesh: particle,
            vx: Math.cos(angle) * speed,
            vy: 2 + Math.random() * 2,
            vz: Math.sin(angle) * speed,
            life: 0.5,
        });
    }
}

function updateDeathEffects(dt) {
    for (let i = deathEffects.length - 1; i >= 0; i--) {
        const p = deathEffects[i];
        p.life -= dt;
        if (p.life <= 0) {
            scene.remove(p.mesh);
            deathEffects.splice(i, 1);
            continue;
        }
        p.vy -= 8 * dt; // gravity
        p.mesh.position.x += p.vx * dt;
        p.mesh.position.y += p.vy * dt;
        p.mesh.position.z += p.vz * dt;
        p.mesh.material.opacity = p.life * 2;
        p.mesh.material.transparent = true;
    }
}

// ============================================================
// SCREEN SHAKE
// ============================================================
let shakeIntensity = 0;
const cameraBasePos = new THREE.Vector3(18, 22, 18);

function triggerShake(intensity) {
    shakeIntensity = Math.max(shakeIntensity, intensity);
}

function updateScreenShake(dt) {
    if (shakeIntensity > 0) {
        const ox = (Math.random() - 0.5) * shakeIntensity;
        const oy = (Math.random() - 0.5) * shakeIntensity;
        camera.position.set(cameraBasePos.x + ox, cameraBasePos.y + oy, cameraBasePos.z + ox);
        shakeIntensity *= 0.85; // decay
        if (shakeIntensity < 0.01) {
            shakeIntensity = 0;
            camera.position.copy(cameraBasePos);
        }
    }
}

// ============================================================
// SHIELD DOME EFFECT
// ============================================================
const shieldDomes = [];

function createShieldDome(towerPos, range) {
    const geo = new THREE.SphereGeometry(range, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
    const mat = new THREE.MeshStandardMaterial({
        color: 0x33ff99,
        emissive: 0x33ff99,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.12,
        side: THREE.DoubleSide,
        wireframe: true,
    });
    const dome = new THREE.Mesh(geo, mat);
    dome.position.set(towerPos.x, 0.3, towerPos.z);
    scene.add(dome);
    return { mesh: dome, mat };
}

// ============================================================
// EMP PULSE RING EFFECT
// ============================================================
const empPulses = [];

function spawnEmpPulse(x, z, range) {
    const geo = new THREE.TorusGeometry(0.3, 0.08, 4, 16);
    const mat = new THREE.MeshStandardMaterial({
        color: 0xcc66ff,
        emissive: 0xcc66ff,
        emissiveIntensity: 2.0,
        transparent: true,
        opacity: 1.0,
    });
    const ring = new THREE.Mesh(geo, mat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.set(x, 2, z);
    scene.add(ring);
    empPulses.push({ mesh: ring, mat, maxRadius: range, life: 0.6, maxLife: 0.6 });
}

function updateEmpPulses(dt) {
    for (let i = empPulses.length - 1; i >= 0; i--) {
        const p = empPulses[i];
        p.life -= dt;
        if (p.life <= 0) {
            scene.remove(p.mesh);
            empPulses.splice(i, 1);
            continue;
        }
        const t = 1 - (p.life / p.maxLife);
        const radius = p.maxRadius * t;
        p.mesh.scale.set(radius / 0.3, radius / 0.3, 1);
        p.mat.opacity = 1 - t;
        p.mesh.position.y = 2 + t * 0.5;
    }
}

// ============================================================
// PROJECTILE SYSTEM
// ============================================================
const projectiles = [];

function spawnProjectile(from, target, damage, splash) {
    const geo = new THREE.BoxGeometry(0.12, 0.12, 0.2);
    const mat = new THREE.MeshStandardMaterial({
        color: 0x3366ff, emissive: 0x3366ff, emissiveIntensity: 0.8,
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(from.x, 2.5, from.z);
    scene.add(mesh);
    projectiles.push({
        mesh,
        tx: target.x, tz: target.z,
        damage, splash,
        speed: 15,
    });
}

function updateProjectiles(dt) {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        const dx = p.tx - p.mesh.position.x;
        const dz = p.tz - p.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 0.3) {
            // Impact — splash damage
            for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                if (e.dead) continue;
                const ex = e.x - p.mesh.position.x;
                const ez = e.z - p.mesh.position.z;
                if (Math.sqrt(ex * ex + ez * ez) <= p.splash) {
                    e.hp -= p.damage;
                    if (e.hp <= 0) killEnemy(j, true);
                }
            }
            spawnDeathEffect(p.mesh.position.clone(), 0x3366ff);
            scene.remove(p.mesh);
            projectiles.splice(i, 1);
            continue;
        }

        const move = p.speed * dt;
        p.mesh.position.x += (dx / dist) * move;
        p.mesh.position.z += (dz / dist) * move;
        p.mesh.position.y = 2.5 - (1 - dist / 10) * 1; // slight arc
    }
}

// ============================================================
// BEAM VISUALS (for laser)
// ============================================================
const beams = [];

function showBeam(fromPos, toPos, color) {
    const dx = toPos.x - fromPos.x;
    const dy = (toPos.y || 0.5) - 2.2;
    const dz = toPos.z - fromPos.z;
    const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

    const geo = new THREE.CylinderGeometry(0.03, 0.03, length, 4);
    const mat = new THREE.MeshStandardMaterial({
        color, emissive: color, emissiveIntensity: 1.5,
        transparent: true, opacity: 0.8,
    });
    const beam = new THREE.Mesh(geo, mat);

    // Position at midpoint
    beam.position.set(
        fromPos.x + dx / 2,
        2.2 + dy / 2,
        fromPos.z + dz / 2
    );
    // Orient toward target
    beam.lookAt(toPos.x, toPos.y || 0.5, toPos.z);
    beam.rotateX(Math.PI / 2);

    scene.add(beam);
    beams.push({ mesh: beam, life: 0.05 }); // flash for ~3 frames
}

function updateBeams(dt) {
    for (let i = beams.length - 1; i >= 0; i--) {
        beams[i].life -= dt;
        if (beams[i].life <= 0) {
            scene.remove(beams[i].mesh);
            beams.splice(i, 1);
        }
    }
}

// ============================================================
// COMBAT SYSTEM
// ============================================================
const TOWER_STATS = {
    laser:   { range: 6, dps: 30, cooldown: 0 },
    missile: { range: 8, damage: 18, splash: 1.8, cooldown: 1.0 },
    shield:  { range: 4.5, slowAmount: 0.3 },
    emp:     { range: 5.5, stunDuration: 3, cooldown: 8 },
};

function findClosestEnemy(x, z, range) {
    let closest = null;
    let closestDist = range;
    for (const e of enemies) {
        if (e.dead || e.hp <= 0) continue;
        const dx = e.x - x;
        const dz = e.z - z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < closestDist) {
            closestDist = dist;
            closest = e;
        }
    }
    return closest;
}

function updateCombat(dt) {
    for (const tower of towers) {
        if (!tower.occupied || !tower.type) continue;
        const player = players[tower.playerIdx];
        if (!player || !player.firing) continue;

        const stats = TOWER_STATS[tower.type];
        const tx = tower.pos.x;
        const tz = tower.pos.z;

        if (tower.type === 'laser') {
            // Continuous beam damage to nearest enemy
            const target = findClosestEnemy(tx, tz, stats.range);
            if (target) {
                const dmg = stats.dps * dt;
                target.hp -= dmg;
                showBeam(
                    { x: tx, z: tz },
                    { x: target.x, y: ENEMY_TYPES[target.type].size + 0.1, z: target.z },
                    0xff3333
                );
                if (target.hp <= 0) {
                    const idx = enemies.indexOf(target);
                    if (idx >= 0) killEnemy(idx, true);
                }
            }
        } else if (tower.type === 'missile') {
            tower.fireCooldown -= dt;
            if (tower.fireCooldown <= 0) {
                const target = findClosestEnemy(tx, tz, stats.range);
                if (target) {
                    spawnProjectile(
                        { x: tx, z: tz },
                        { x: target.x, z: target.z },
                        stats.damage,
                        stats.splash
                    );
                    tower.fireCooldown = stats.cooldown;
                }
            }
        } else if (tower.type === 'shield') {
            // Show shield dome when firing
            if (!tower.shieldDome) {
                tower.shieldDome = createShieldDome(tower.pos, stats.range);
            }
            // Pulse dome opacity
            tower.shieldDome.mat.opacity = 0.1 + Math.sin(time * 4) * 0.05;
            tower.shieldDome.mesh.rotation.y += dt * 0.5;
            // Slow all enemies in range
            for (const e of enemies) {
                if (e.dead) continue;
                const dx = e.x - tx;
                const dz = e.z - tz;
                if (Math.sqrt(dx * dx + dz * dz) <= stats.range) {
                    e.slowFactor = stats.slowAmount;
                }
            }
        } else if (tower.type === 'emp') {
            if (tower.empReady) {
                // Stun all enemies in range
                for (const e of enemies) {
                    if (e.dead) continue;
                    const dx = e.x - tx;
                    const dz = e.z - tz;
                    if (Math.sqrt(dx * dx + dz * dz) <= stats.range) {
                        e.stunTimer = stats.stunDuration;
                    }
                }
                tower.empReady = false;
                tower.fireCooldown = stats.cooldown;
                // EMP pulse ring effect
                spawnEmpPulse(tx, tz, stats.range);
                triggerShake(0.4);
            }
        }

        // EMP cooldown recovery
        if (tower.type === 'emp' && !tower.empReady) {
            tower.fireCooldown -= dt;
            if (tower.fireCooldown <= 0) tower.empReady = true;
        }
    }

    // Remove shield domes for towers that are not actively shielding
    for (const tower of towers) {
        if (tower.shieldDome) {
            const isShielding = tower.type === 'shield' && tower.occupied && players[tower.playerIdx]?.firing;
            if (!isShielding) {
                scene.remove(tower.shieldDome.mesh);
                tower.shieldDome = null;
            }
        }
    }
}

// ============================================================
// WAVE SYSTEM
// ============================================================
let gamePhase = 'idle'; // 'idle', 'wave', 'build', 'gameover'
let currentWave = 0;
let score = 0;
let waveEnemiesLeft = 0; // enemies still to spawn
let waveSpawnTimer = 0;
let waveSpawnQueue = []; // [{type, laneOffset}]

const WAVE_DEFS = [
    // Wave 1: intro drones
    { enemies: [
        ...Array(5).fill({ type: 'drone', lane: 0 }),
    ], spawnRate: 1.2 },
    // Wave 2: drones + scouts
    { enemies: [
        ...Array(6).fill({ type: 'drone', lane: 0 }),
        ...Array(3).fill({ type: 'scout', lane: 0 }),
    ], spawnRate: 0.9 },
    // Wave 3: walkers arrive
    { enemies: [
        ...Array(4).fill({ type: 'drone', lane: 0 }),
        ...Array(3).fill({ type: 'walker', lane: 0 }),
    ], spawnRate: 1.5 },
    // Wave 4: scout swarm
    { enemies: [
        ...Array(12).fill({ type: 'scout', lane: 0 }),
    ], spawnRate: 0.4 },
    // Wave 5: boss wave
    { enemies: [
        ...Array(4).fill({ type: 'drone', lane: 0 }),
        ...Array(2).fill({ type: 'walker', lane: 0 }),
        { type: 'heavy', lane: 0 },
    ], spawnRate: 1.8 },
    // Wave 6+: escalating
    { enemies: [
        ...Array(6).fill({ type: 'drone', lane: 0 }),
        ...Array(4).fill({ type: 'scout', lane: 0 }),
        ...Array(3).fill({ type: 'walker', lane: 0 }),
        { type: 'heavy', lane: 0 },
    ], spawnRate: 0.8 },
];

function beginNextWave() {
    currentWave++;
    gamePhase = 'wave';
    const waveIdx = Math.min(currentWave - 1, WAVE_DEFS.length - 1);
    const def = WAVE_DEFS[waveIdx];

    // Scale difficulty for waves beyond defined ones
    const scale = currentWave > WAVE_DEFS.length ? 1 + (currentWave - WAVE_DEFS.length) * 0.3 : 1;

    // Build base spawn queue
    let enemyList = [...def.enemies];
    // Difficulty scaling: add extra enemies for waves beyond defined
    if (scale > 1) {
        const extras = Math.floor((scale - 1) * 4); // +4 enemies per scale step
        for (let i = 0; i < extras; i++) {
            const pick = def.enemies[Math.floor(Math.random() * def.enemies.length)];
            enemyList.push(pick);
        }
    }

    waveSpawnQueue = enemyList.map(e => ({
        type: e.type,
        laneOffset: (Math.random() - 0.5) * 1.5,
        hpScale: scale, // pass scale to createEnemy
    }));
    // Shuffle spawn order
    for (let i = waveSpawnQueue.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [waveSpawnQueue[i], waveSpawnQueue[j]] = [waveSpawnQueue[j], waveSpawnQueue[i]];
    }
    waveSpawnTimer = 0;
    waveEnemiesLeft = waveSpawnQueue.length;
}

function updateBuildPhase(dt) {
    if (gamePhase !== 'build') return;
    buildTimer -= dt;
    if (buildTimer <= 0) {
        // Auto-start next wave
        for (const p of players) p.buildMode = false;
        beginNextWave();
    }
}

function updateWaveSpawning(dt) {
    if (gamePhase !== 'wave') return;

    // Spawn enemies from queue
    if (waveSpawnQueue.length > 0) {
        waveSpawnTimer -= dt;
        if (waveSpawnTimer <= 0) {
            const next = waveSpawnQueue.shift();
            const e = createEnemy(next.type, next.laneOffset);
            // Apply difficulty HP scaling
            if (next.hpScale > 1) {
                e.hp = Math.round(e.hp * next.hpScale);
                e.maxHp = e.hp;
            }
            const waveIdx = Math.min(currentWave - 1, WAVE_DEFS.length - 1);
            waveSpawnTimer = WAVE_DEFS[waveIdx].spawnRate;
        }
    }

    // Check wave complete (all spawned + all dead)
    if (waveSpawnQueue.length === 0 && enemies.length === 0) {
        gamePhase = 'build';
        buildTimer = BUILD_TIMER_DURATION;
        // Reset tower cooldowns
        for (const t of towers) {
            t.fireCooldown = 0;
            t.empReady = true;
        }
    }
}

// ============================================================
// PLAYER STATE
// ============================================================
const BUILD_TIMER_DURATION = 15; // seconds between waves
let buildTimer = 0;

const players = [
    { idx: 0, cursorAt: 0, inTower: false, firing: false, buildMode: false, buildIdx: 0, color: '#00ccff', gamepadIndex: -1, active: false },
    { idx: 1, cursorAt: 1, inTower: false, firing: false, buildMode: false, buildIdx: 0, color: '#ff4444', gamepadIndex: -1, active: false },
    { idx: 2, cursorAt: 2, inTower: false, firing: false, buildMode: false, buildIdx: 0, color: '#44ff44', gamepadIndex: -1, active: false },
    { idx: 3, cursorAt: 3, inTower: false, firing: false, buildMode: false, buildIdx: 0, color: '#ffcc00', gamepadIndex: -1, active: false },
];

// Player 0 always active (keyboard fallback)
players[0].active = true;

// Per-player cursor rings (independent of tower pads)
const PLAYER_COLORS_HEX = [0x00ccff, 0xff4444, 0x44ff44, 0xffcc00];
const playerCursors = players.map((p, i) => {
    const geo = new THREE.TorusGeometry(1.4 + i * 0.08, 0.07, 4, 16);
    const mat = new THREE.MeshStandardMaterial({
        color: PLAYER_COLORS_HEX[i],
        emissive: PLAYER_COLORS_HEX[i],
        emissiveIntensity: 1.0,
        transparent: true,
        opacity: 0,
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = -Math.PI / 2;
    mesh.position.y = 0.35;
    scene.add(mesh);
    return { mesh, mat };
});

// ============================================================
// INPUT SYSTEM
// ============================================================
const inputQueue = []; // { playerIdx, action }
const keyState = {};
const prevKeyState = {};
const prevGamepadButtons = [[], [], [], []];

window.addEventListener('keydown', e => { keyState[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keyState[e.key.toLowerCase()] = false; });

// Gamepad connect/disconnect
window.addEventListener('gamepadconnected', e => {
    console.log(`Gamepad ${e.gamepad.index} connected: ${e.gamepad.id}`);
    // Assign to first unassigned player
    for (const p of players) {
        if (p.gamepadIndex === -1) {
            p.gamepadIndex = e.gamepad.index;
            p.active = true;
            console.log(`  → Assigned to Player ${p.idx + 1}`);
            break;
        }
    }
});

window.addEventListener('gamepaddisconnected', e => {
    console.log(`Gamepad ${e.gamepad.index} disconnected`);
    for (const p of players) {
        if (p.gamepadIndex === e.gamepad.index) {
            p.gamepadIndex = -1;
            if (p.idx !== 0) {
                p.active = false;
                // Evict from tower
                if (p.inTower) {
                    const tower = towers[p.cursorAt];
                    tower.occupied = false;
                    tower.playerIdx = -1;
                    p.inTower = false;
                }
                p.firing = false;
                p.buildMode = false;
            }
        }
    }
});

// Input cooldown per player
const inputCooldown = [0, 0, 0, 0];
const COOLDOWN_MS = 200;

function queueAction(playerIdx, action) {
    const now = performance.now();
    if (now - inputCooldown[playerIdx] < COOLDOWN_MS) return;
    inputCooldown[playerIdx] = now;
    inputQueue.push({ playerIdx, action });
}

function pollKeyboard() {
    const pressed = (key) => keyState[key] && !prevKeyState[key];
    if (pressed('w') || pressed('arrowup'))    queueAction(0, 'up');
    if (pressed('s') || pressed('arrowdown'))  queueAction(0, 'down');
    if (pressed('a') || pressed('arrowleft'))  queueAction(0, 'left');
    if (pressed('d') || pressed('arrowright')) queueAction(0, 'right');
    if (pressed(' '))                          queueAction(0, 'hop');
    if (pressed('enter'))                      queueAction(0, 'startwave');
    if (pressed('b'))                          queueAction(0, 'build');
    if (pressed('q') || pressed('escape'))     queueAction(0, 'cancel');
    // Fire is hold-based, not press-based (don't override injected fire)
    if (!players[0]._injectedFiring) {
        players[0].firing = !!(keyState['f'] || keyState['e']);
    }
    Object.assign(prevKeyState, keyState);
}

function pollGamepads() {
    const gamepads = navigator.getGamepads();
    for (const p of players) {
        if (p.gamepadIndex === -1) continue;
        const gp = gamepads[p.gamepadIndex];
        if (!gp) continue;

        const prev = prevGamepadButtons[p.idx];
        const justPressed = (btnIdx) => gp.buttons[btnIdx]?.pressed && !prev[btnIdx];

        // D-pad: buttons 12=up, 13=down, 14=left, 15=right
        if (justPressed(12)) queueAction(p.idx, 'up');
        if (justPressed(13)) queueAction(p.idx, 'down');
        if (justPressed(14)) queueAction(p.idx, 'left');
        if (justPressed(15)) queueAction(p.idx, 'right');

        // Left stick with threshold (treat as d-pad)
        const lx = gp.axes[0] || 0;
        const ly = gp.axes[1] || 0;
        const stickThreshold = 0.6;
        const prevLx = p._prevLx || 0;
        const prevLy = p._prevLy || 0;
        if (ly < -stickThreshold && prevLy >= -stickThreshold) queueAction(p.idx, 'up');
        if (ly > stickThreshold && prevLy <= stickThreshold)   queueAction(p.idx, 'down');
        if (lx < -stickThreshold && prevLx >= -stickThreshold) queueAction(p.idx, 'left');
        if (lx > stickThreshold && prevLx <= stickThreshold)   queueAction(p.idx, 'right');
        p._prevLx = lx;
        p._prevLy = ly;

        // A button (button 0)
        if (justPressed(0)) queueAction(p.idx, 'hop');

        // X button (button 2) — build / cycle
        if (justPressed(2)) queueAction(p.idx, 'build');

        // B button (button 1) — cancel / sell
        if (justPressed(1)) queueAction(p.idx, 'cancel');

        // Start button (button 9)
        if (justPressed(9)) queueAction(p.idx, 'startwave');

        // RT (button 7) — fire (hold-based, don't override injected fire)
        if (!p._injectedFiring) {
            p.firing = !!(gp.buttons[7]?.pressed);
        }

        // Save button state
        prevGamepadButtons[p.idx] = gp.buttons.map(b => b.pressed);
    }
}

// ============================================================
// CURSOR & TOWER HOPPING
// ============================================================

// Navigation adjacency for 2x3 grid
// Index: row * 2 + col
function navigate(currentIdx, direction) {
    const pos = TOWER_POSITIONS[currentIdx];
    let newRow = pos.row;
    let newCol = pos.col;

    switch (direction) {
        case 'up':    newRow = Math.max(0, pos.row - 1); break;
        case 'down':  newRow = Math.min(2, pos.row + 1); break;
        case 'left':  newCol = 0; break;
        case 'right': newCol = 1; break;
    }
    return newRow * 2 + newCol;
}

function processInputs() {
    while (inputQueue.length > 0) {
        const { playerIdx, action } = inputQueue.shift();
        const player = players[playerIdx];
        if (!player.active) continue;

        if (action === 'startwave') {
            if (gamePhase === 'idle' || gamePhase === 'build') {
                // Exit all players' build mode
                for (const p of players) p.buildMode = false;
                beginNextWave();
            } else if (gamePhase === 'gameover') {
                restartGame();
            }
            continue;
        }

        const tower = towers[player.cursorAt];

        // BUILD MODE — available during 'idle' or 'build' phase
        if (gamePhase === 'idle' || gamePhase === 'build') {
            if (action === 'build') {
                if (player.buildMode) {
                    // Cycle to next tower type
                    player.buildIdx = (player.buildIdx + 1) % BUILD_ORDER.length;
                } else if (!tower.type) {
                    // Enter build mode on empty pad
                    player.buildMode = true;
                    player.buildIdx = 0;
                } else if (tower.type && !tower.occupied) {
                    // Sell existing tower (X on a built tower = sell)
                    const refund = sellTower(tower);
                    credits += refund;
                }
                continue;
            }

            if (action === 'cancel') {
                if (player.buildMode) {
                    player.buildMode = false;
                } else if (tower.type && !tower.occupied) {
                    // Sell tower
                    const refund = sellTower(tower);
                    credits += refund;
                }
                continue;
            }

            if (action === 'hop' && player.buildMode) {
                // Confirm purchase
                const selectedType = BUILD_ORDER[player.buildIdx];
                const cost = TOWER_TYPES[selectedType].cost;
                if (credits >= cost) {
                    credits -= cost;
                    buildTowerOn(tower, selectedType);
                    player.buildMode = false;
                }
                continue;
            }
        }

        // Navigation / hopping (always available)
        if (action === 'hop') {
            if (player.inTower) {
                // Hop out
                tower.occupied = false;
                tower.playerIdx = -1;
                player.inTower = false;
            } else if (tower.type && !tower.occupied) {
                // Hop in (only if tower is built and not occupied)
                tower.occupied = true;
                tower.playerIdx = playerIdx;
                player.inTower = true;
            }
        } else if (!player.inTower && ['up', 'down', 'left', 'right'].includes(action)) {
            // Navigate between towers
            player.buildMode = false; // exit build mode on move
            const newIdx = navigate(player.cursorAt, action);
            player.cursorAt = newIdx;
        }
    }
}

// ============================================================
// HUD UPDATE
// ============================================================
const hudGate = document.getElementById('hud-gate');
const hudWave = document.getElementById('hud-wave');
const hudScore = document.getElementById('hud-score');
const hudCredits = document.getElementById('hud-credits');
const hudEnemies = document.getElementById('hud-enemies');
const hudPlayers = document.getElementById('hud-players');

const PLAYER_NAMES = ['P1', 'P2', 'P3', 'P4'];

function updateHUD() {
    const hpPct = Math.round(gateHP);
    hudGate.textContent = `GATE: ${hpPct}%`;
    hudGate.style.color = hpPct > 50 ? '#00ffcc' : hpPct > 25 ? '#ffcc00' : '#ff4444';

    if (gamePhase === 'idle') hudWave.textContent = 'PRESS START';
    else if (gamePhase === 'wave') hudWave.textContent = `WAVE ${currentWave}`;
    else if (gamePhase === 'build') {
        const secs = Math.ceil(buildTimer);
        hudWave.textContent = `BUILD (${secs}s)`;
    } else if (gamePhase === 'gameover') {
        hudWave.textContent = 'GAME OVER';
        hudWave.style.color = '#ff4444';
        hudWave.style.textShadow = '0 0 8px #ff444488';
    }

    hudScore.textContent = `SCORE: ${score}`;
    hudCredits.textContent = `⚡ ${credits}`;
    hudEnemies.textContent = gamePhase === 'wave' ? `${enemies.length} enemies` : '';

    // Per-player status lines
    let lines = '';
    for (const p of players) {
        if (!p.active) continue;
        const tower = towers[p.cursorAt];
        let info;
        if (p.buildMode) {
            const selectedType = BUILD_ORDER[p.buildIdx];
            const ti = TOWER_TYPES[selectedType];
            const afford = credits >= ti.cost ? '' : ' ✗';
            info = `BUILD: ${ti.name} (${ti.cost}⚡${afford})`;
        } else if (p.inTower) {
            info = `${tower.name}${p.firing ? ' [FIRING]' : ' [MANNED]'}`;
        } else {
            info = tower.name;
        }
        lines += `<span style="color:${p.color};text-shadow:0 0 4px ${p.color}88">${PLAYER_NAMES[p.idx]}</span> <span style="color:#aabbcc">${info}</span><br>`;
    }
    hudPlayers.innerHTML = lines;
}

// ============================================================
// WINDOW API — Playwright testing
// ============================================================
window.gameState = {
    phase: 'idle',
    wave: 0,
    gateHP: 100,
    towers: [],
    enemies: [],
    players: [],
    score: 0,
    credits: 150,
    buildTimer: 0,
};

window.injectInput = function(playerIdx, action) {
    if (playerIdx >= 0 && playerIdx < 4) {
        players[playerIdx].active = true;
        // Handle fire as a hold-state (persists until 'fire-stop')
        if (action === 'fire') {
            players[playerIdx].firing = true;
            players[playerIdx]._injectedFiring = true;
            return new Promise(resolve => {
                requestAnimationFrame(() => requestAnimationFrame(() => {
                    resolve(window.gameState);
                }));
            });
        }
        if (action === 'fire-stop') {
            players[playerIdx].firing = false;
            players[playerIdx]._injectedFiring = false;
            return new Promise(resolve => {
                requestAnimationFrame(() => requestAnimationFrame(() => {
                    resolve(window.gameState);
                }));
            });
        }
        // Bypass cooldown for testing
        inputCooldown[playerIdx] = 0;
        queueAction(playerIdx, action);
        // Return promise that resolves after 2 frames (input processed + state updated)
        return new Promise(resolve => {
            requestAnimationFrame(() => requestAnimationFrame(() => {
                resolve(window.gameState);
            }));
        });
    }
    return Promise.resolve(window.gameState);
};

window.startWave = function() {
    if (gamePhase === 'idle' || gamePhase === 'build') {
        beginNextWave();
    }
};

window.skipToWave = function(n) {
    currentWave = n - 1;
    beginNextWave();
};

window.activatePlayer = function(playerIdx) {
    if (playerIdx >= 0 && playerIdx < 4) {
        players[playerIdx].active = true;
    }
};

// Debug: set gate HP for testing
window.setGateHP = function(hp) { gateHP = hp; };

function updateWindowAPI() {
    window.gameState.phase = gamePhase;
    window.gameState.wave = currentWave;
    window.gameState.gateHP = gateHP;
    window.gameState.score = score;
    window.gameState.credits = credits;
    window.gameState.buildTimer = gamePhase === 'build' ? Math.ceil(buildTimer) : 0;
    window.gameState.towers = towers.map(t => ({
        id: t.id,
        type: t.type,
        name: t.name,
        occupied: t.occupied,
        playerIdx: t.playerIdx,
    }));
    window.gameState.enemies = enemies.map(e => ({
        id: e.id,
        type: e.type,
        hp: e.hp,
        maxHp: e.maxHp,
        x: e.x,
        z: e.z,
        stunTimer: e.stunTimer,
    }));
    window.gameState.players = players.filter(p => p.active).map(p => ({
        idx: p.idx,
        cursorAt: p.cursorAt,
        inTower: p.inTower,
        firing: p.firing,
        buildMode: p.buildMode,
        buildIdx: p.buildIdx,
        color: p.color,
    }));
}

// ============================================================
// RESTART
// ============================================================
function restartGame() {
    // Clear enemies
    for (const e of enemies) scene.remove(e.group);
    enemies.length = 0;
    // Clear projectiles
    for (const p of projectiles) scene.remove(p.mesh);
    projectiles.length = 0;
    // Clear beams
    for (const b of beams) scene.remove(b.mesh);
    beams.length = 0;
    // Clear death effects
    for (const d of deathEffects) scene.remove(d.mesh);
    deathEffects.length = 0;
    // Clear EMP pulses
    for (const p of empPulses) scene.remove(p.mesh);
    empPulses.length = 0;
    // Clear shield domes
    for (const t of towers) {
        if (t.shieldDome) { scene.remove(t.shieldDome.mesh); t.shieldDome = null; }
    }

    // Reset towers — sell all, rebuild starters
    for (const t of towers) sellTower(t);
    buildTowerOn(towers[0], 'laser');
    buildTowerOn(towers[1], 'missile');

    // Reset state
    gateHP = 100;
    score = 0;
    credits = 150;
    currentWave = 0;
    gamePhase = 'idle';
    shakeIntensity = 0;
    camera.position.copy(cameraBasePos);

    // Reset players
    for (const p of players) {
        p.inTower = false;
        p.firing = false;
        p.buildMode = false;
        p.buildIdx = 0;
    }

    // Reset HUD styling
    const hudW = document.getElementById('hud-wave');
    hudW.style.color = '#00ffcc';
    hudW.style.textShadow = '0 0 4px #00ffcc88';
}

// ============================================================
// GAME LOOP
// ============================================================
let time = 0;

function animate() {
    requestAnimationFrame(animate);
    const dt = 0.016;
    time += dt;

    // Input
    pollKeyboard();
    pollGamepads();
    processInputs();

    // Game systems (paused on game over except effects)
    if (gamePhase !== 'gameover') {
        updateBuildPhase(dt);
        updateWaveSpawning(dt);
        updateEnemies(dt);
        updateCombat(dt);
    }
    updateProjectiles(dt);
    updateBeams(dt);
    updateDeathEffects(dt);
    updateEmpPulses(dt);
    updateScreenShake(dt);

    // Update per-player cursor rings
    for (let i = 0; i < 4; i++) {
        const p = players[i];
        const pc = playerCursors[i];
        if (!p.active) {
            pc.mat.opacity = 0;
            continue;
        }
        const towerPos = TOWER_POSITIONS[p.cursorAt];
        pc.mesh.position.set(towerPos.x, 0.35, towerPos.z);
        pc.mat.opacity = 0.7 + Math.sin(time * 6 + i * 1.5) * 0.3;
    }

    // Update tower occupied indicators
    for (const tower of towers) {
        let indicatorIntensity = 0;
        if (tower.occupied) {
            indicatorIntensity = 0.8 + Math.sin(time * 4) * 0.2;
            const occupant = players[tower.playerIdx];
            if (occupant) {
                tower.indicatorMat.color.set(occupant.color);
                tower.indicatorMat.emissive.set(occupant.color);
            }
        }
        tower.indicatorMat.emissiveIntensity = indicatorIntensity;
    }

    // Gate barrier pulse
    const gateMat = gate.userData.barrierMat;
    gateMat.opacity = 0.25 + Math.sin(time * 3) * 0.1;
    gateMat.emissiveIntensity = 0.4 + Math.sin(time * 2) * 0.2;
    gate.userData.gateLight.intensity = 1.5 + Math.sin(time * 2.5) * 0.5;

    // Spawn marker pulse
    spawnMarkerMat.opacity = 0.15 + Math.sin(time * 2) * 0.1;

    // HUD
    updateHUD();

    // Window API
    updateWindowAPI();

    renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
